// vim:fileencoding=utf-8
(function(external_namespace) {
"use strict;"
var rs_version = "0.5.1";
var rs_commit_sha = "8fb87331e1f60a55975875dbcfdff5b330aec970\n";

// Embedded modules {{{
var data = {"compiler.js":"(function(){\n    \"use strict\";\n    var _$rapyd$_iterator_symbol = (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") ? Symbol.iterator : \"iterator-Symbol-5d0927e5554349048cf0e3762a228256\";\n    var _$rapyd$_kwargs_symbol = (typeof Symbol === \"function\") ? Symbol(\"kwargs-object\") : \"kwargs-object-Symbol-5d0927e5554349048cf0e3762a228256\";\n    var _$rapyd$_cond_temp;\n    var _$rapyd$_object_counter = 0;\n    function range(start, stop, step) {\n            var length;\n            if (arguments.length <= 1) {\n                stop = start || 0;\n                start = 0;\n            }\n            step = arguments[2] || 1;\n            length = Math.max(Math.ceil((stop - start) / step), 0);\n            return (function(){\n                var _$rapyd$_d = {};\n                _$rapyd$_d[_$rapyd$_iterator_symbol] = function() {\n                    return this;\n                };\n                _$rapyd$_d[\"_i\"] = start - step;\n                _$rapyd$_d[\"_idx\"] = -1;\n                _$rapyd$_d[\"next\"] = function() {\n                    this._i += step;\n                    this._idx += 1;\n                    if (this._idx >= length) {\n                        return {\n                            \"done\": true\n                        };\n                    }\n                    return {\n                        \"done\": false,\n                        \"value\": this._i\n                    };\n                };\n                return _$rapyd$_d;\n            })();\n        };\n    var len = (function _$rapyd$_len() {\n            if (typeof Set === \"function\" && typeof Map === \"function\") {\n                return function(obj) {\n                    if (_$rapyd$_arraylike(obj)) {\n                        return obj.length;\n                    }\n                    if (obj instanceof Set || obj instanceof Map) {\n                        return obj.size;\n                    }\n                    if (typeof obj.__len__ === \"function\") {\n                        return obj.__len__();\n                    }\n                    return Object.keys(obj).length;\n                };\n            }\n            return function(obj) {\n                if (_$rapyd$_arraylike(obj)) {\n                    return obj.length;\n                }\n                if (typeof obj.__len__ === \"function\") {\n                    return obj.__len__();\n                }\n                return Object.keys(obj).length;\n            };\n        })();\n    function _$rapyd$_Iterable(iterable) {\n            var iterator, ans, result;\n            if (_$rapyd$_arraylike(iterable)) {\n                return iterable;\n            }\n            if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n                iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n                ans = _$rapyd$_list_decorate([]);\n                result = iterator.next();\n                while (!result.done) {\n                    ans.push(result.value);\n                    result = iterator.next();\n                }\n                return ans;\n            }\n            return Object.keys(iterable);\n        };\n    function _$rapyd$_extends(child, parent) {\n            child.prototype = Object.create(parent.prototype);\n            child.prototype.constructor = child;\n        };\n    var _$rapyd$_in = (function _$rapyd$_in() {\n            if (typeof Map === \"function\" && typeof Set === \"function\") {\n                return function(val, arr) {\n                    if (typeof arr === \"string\") {\n                        return arr.indexOf(val) !== -1;\n                    }\n                    if (typeof arr.__contains__ === \"function\") {\n                        return arr.__contains__(val);\n                    }\n                    if ((arr instanceof Map || arr instanceof Set)) {\n                        return arr.has(val);\n                    }\n                    if (_$rapyd$_arraylike(arr)) {\n                        return _$rapyd$_list_contains.call(arr, val);\n                    }\n                    return Object.prototype.hasOwnProperty.call(arr, val);\n                };\n            }\n            return function(val, arr) {\n                if (typeof arr === \"string\") {\n                    return arr.indexOf(val) !== -1;\n                }\n                if (typeof arr.__contains__ === \"function\") {\n                    return arr.__contains__(val);\n                }\n                if (_$rapyd$_arraylike(arr)) {\n                    return _$rapyd$_list_contains.call(arr, val);\n                }\n                return Object.prototype.hasOwnProperty.call(arr, val);\n            };\n        })();\n    function enumerate(iterable) {\n            var ans, iterator;\n            if (_$rapyd$_arraylike(iterable)) {\n                ans = {\n                    \"_i\": -1,\n                    \"next\": function() {\n                        this._i += 1;\n                        if (this._i < iterable.length) {\n                            return {\n                                \"done\": false,\n                                \"value\": _$rapyd$_list_decorate([ this._i, iterable[this._i] ])\n                            };\n                        }\n                        return {\n                            \"done\": true\n                        };\n                    }\n                };\n                ans[_$rapyd$_iterator_symbol] = function() {\n                    return this;\n                };\n                return ans;\n            }\n            if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n                iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n                ans = {\n                    \"_iterator\": iterator,\n                    \"_i\": -1,\n                    \"next\": function() {\n                        var r;\n                        r = this._iterator.next();\n                        if (r.done) {\n                            return {\n                                \"done\": true\n                            };\n                        }\n                        this._i += 1;\n                        return {\n                            \"done\": false,\n                            \"value\": _$rapyd$_list_decorate([ this._i, r.value ])\n                        };\n                    }\n                };\n                ans[_$rapyd$_iterator_symbol] = function() {\n                    return this;\n                };\n                return ans;\n            }\n            return enumerate(Object.keys(iterable));\n        };\n    var Exception = Error;\nfunction AttributeError() {\n    if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n    AttributeError.prototype.__init__.apply(this, arguments);\n}\n_$rapyd$_extends(AttributeError, Error);\nAttributeError.prototype.__init__ = function __init__(msg) {\n    var self = this;\n    self.message = msg;\n    self.stack = new Error().stack;\n};\nAttributeError.prototype.__repr__ = function __repr__ () {\n    return \"<\" + __name__ + \".\" + \"AttributeError\" + \" #\" + this._$rapyd$_object_id + \">\";\n};\nAttributeError.prototype.__str__ = function __str__ () {\n    return this.__repr__();\n};\nAttributeError.prototype.name = \"AttributeError\";\n\nfunction IndexError() {\n    if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n    IndexError.prototype.__init__.apply(this, arguments);\n}\n_$rapyd$_extends(IndexError, Error);\nIndexError.prototype.__init__ = function __init__(msg) {\n    var self = this;\n    self.message = msg;\n    self.stack = new Error().stack;\n};\nIndexError.prototype.__repr__ = function __repr__ () {\n    return \"<\" + __name__ + \".\" + \"IndexError\" + \" #\" + this._$rapyd$_object_id + \">\";\n};\nIndexError.prototype.__str__ = function __str__ () {\n    return this.__repr__();\n};\nIndexError.prototype.name = \"IndexError\";\n\nfunction KeyError() {\n    if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n    KeyError.prototype.__init__.apply(this, arguments);\n}\n_$rapyd$_extends(KeyError, Error);\nKeyError.prototype.__init__ = function __init__(msg) {\n    var self = this;\n    self.message = msg;\n    self.stack = new Error().stack;\n};\nKeyError.prototype.__repr__ = function __repr__ () {\n    return \"<\" + __name__ + \".\" + \"KeyError\" + \" #\" + this._$rapyd$_object_id + \">\";\n};\nKeyError.prototype.__str__ = function __str__ () {\n    return this.__repr__();\n};\nKeyError.prototype.name = \"KeyError\";\n\nfunction ValueError() {\n    if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n    ValueError.prototype.__init__.apply(this, arguments);\n}\n_$rapyd$_extends(ValueError, Error);\nValueError.prototype.__init__ = function __init__(msg) {\n    var self = this;\n    self.message = msg;\n    self.stack = new Error().stack;\n};\nValueError.prototype.__repr__ = function __repr__ () {\n    return \"<\" + __name__ + \".\" + \"ValueError\" + \" #\" + this._$rapyd$_object_id + \">\";\n};\nValueError.prototype.__str__ = function __str__ () {\n    return this.__repr__();\n};\nValueError.prototype.name = \"ValueError\";\n;\n    var _$rapyd$_chain_assign_temp;\nfunction _$rapyd$_equals(a, b) {\n    var _$rapyd$_unpack, akeys, bkeys, key;\n    if (a === b) {\n        return true;\n    }\n    if (a && typeof a.__eq__ === \"function\") {\n        return a.__eq__(b);\n    }\n    if (b && typeof b.__eq__ === \"function\") {\n        return b.__eq__(a);\n    }\n    if (_$rapyd$_arraylike(a) && _$rapyd$_arraylike(b)) {\n        if ((a.length !== b.length && (typeof a.length !== \"object\" || _$rapyd$_not_equals(a.length, b.length)))) {\n            return false;\n        }\n        for (var i=0; i < a.length; i++) {\n            if (!((a[i] === b[i] || typeof a[i] === \"object\" && _$rapyd$_equals(a[i], b[i])))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (a && b && a.constructor === b.constructor && a.constructor === Object) {\n        _$rapyd$_unpack = [Object.keys(a), Object.keys(b)];\n        akeys = _$rapyd$_unpack[0];\n        bkeys = _$rapyd$_unpack[1];\n        if (akeys.length !== bkeys.length) {\n            return false;\n        }\n        for (var i=0; i < akeys.length; i++) {\n            key = akeys[i];\n            if (!((a[key] === b[key] || typeof a[key] === \"object\" && _$rapyd$_equals(a[key], b[key])))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nfunction _$rapyd$_not_equals(a, b) {\n    if (a === b) {\n        return false;\n    }\n    if (a && typeof a.__ne__ === \"function\") {\n        return a.__ne__(b);\n    }\n    if (b && typeof b.__ne__ === \"function\") {\n        return b.__ne__(a);\n    }\n    return !_$rapyd$_equals(a, b);\n}\nvar equals = _$rapyd$_equals;;\nfunction _$rapyd$_list_extend(iterable) {\n    var start, iterator, result;\n    if (Array.isArray(iterable) || typeof iterable === \"string\") {\n        start = this.length;\n        this.length += iterable.length;\n        for (var i = 0; i < iterable.length; i++) {\n            this[start + i] = iterable[i];\n        }\n    } else {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n        result = iterator.next();\n        while (!result.done) {\n            this.push(result.value);\n            result = iterator.next();\n        }\n    }\n}\nfunction _$rapyd$_list_index(val, start, stop) {\n    var idx;\n    start = start || 0;\n    if (start < 0) {\n        start = this.length + start;\n    }\n    if (start < 0) {\n        throw new ValueError(val + \" is not in list\");\n    }\n    if (stop === undefined) {\n        idx = this.indexOf(val, start);\n        if (idx === -1) {\n            throw new ValueError(val + \" is not in list\");\n        }\n        return idx;\n    }\n    if (stop < 0) {\n        stop = this.length + stop;\n    }\n    for (var i = start; i < stop; i++) {\n        if ((this[i] === val || typeof this[i] === \"object\" && _$rapyd$_equals(this[i], val))) {\n            return i;\n        }\n    }\n    throw new ValueError(val + \" is not in list\");\n}\nfunction _$rapyd$_list_pop(index) {\n    var ans;\n    if (this.length === 0) {\n        throw new IndexError(\"list is empty\");\n    }\n    ans = this.splice(index, 1);\n    if (!ans.length) {\n        throw new IndexError(\"pop index out of range\");\n    }\n    return ans[0];\n}\nfunction _$rapyd$_list_remove(value) {\n    var idx;\n    idx = this.indexOf(value);\n    if (idx === -1) {\n        throw new ValueError(value + \" not in list\");\n    }\n    this.splice(idx, 1);\n}\nfunction _$rapyd$_list_to_string() {\n    return \"[\" + this.join(\", \") + \"]\";\n}\nfunction _$rapyd$_list_insert(index, val) {\n    if (index < 0) {\n        index += this.length;\n    }\n    index = min(this.length, max(index, 0));\n    if (index === 0) {\n        this.unshift(val);\n        return;\n    }\n    for (var i = this.length; i > index; i--) {\n        this[i] = this[i - 1];\n    }\n    this[index] = val;\n}\nfunction _$rapyd$_list_copy() {\n    return _$rapyd$_list_constructor(this);\n}\nfunction _$rapyd$_list_clear() {\n    this.length = 0;\n}\nfunction _$rapyd$_list_as_array() {\n    return Array.prototype.slice.call(this);\n}\nfunction _$rapyd$_list_count(value) {\n    return this.reduce(function(n, val) {\n        return n + (val === value);\n    }, 0);\n}\nfunction _$rapyd$_list_sort_key(value) {\n    var t;\n    t = typeof value;\n    if (t === \"string\" || t === \"number\") {\n        return value;\n    }\n    return value.toString();\n}\nfunction _$rapyd$_list_sort_cmp(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nfunction _$rapyd$_list_sort() {\n    var key = (arguments[0] === undefined || ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? (null) : arguments[0];\n    var reverse = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? (false) : arguments[1];\n    var _$rapyd$_kwargs_obj = arguments[arguments.length-1];\n    if (_$rapyd$_kwargs_obj === null || typeof _$rapyd$_kwargs_obj !== \"object\" || _$rapyd$_kwargs_obj [_$rapyd$_kwargs_symbol] !== true) _$rapyd$_kwargs_obj = {};\n    if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"key\")){\n        key = _$rapyd$_kwargs_obj.key;\n    }\n    if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"reverse\")){\n        reverse = _$rapyd$_kwargs_obj.reverse;\n    }\n    var mult, keymap, k;\n    key = key || _$rapyd$_list_sort_key;\n    mult = (reverse) ? -1 : 1;\n    keymap = dict();\n    for (var i=0; i < this.length; i++) {\n        k = this[i];\n        keymap.set(k, key(k));\n    }\n    this.sort(function(a, b) {\n        return mult * _$rapyd$_list_sort_cmp(keymap.get(a), keymap.get(b));\n    });\n}\nfunction _$rapyd$_list_concat() {\n    var ans;\n    ans = Array.prototype.concat.apply(this, arguments);\n    _$rapyd$_list_decorate(ans);\n    return ans;\n}\nfunction _$rapyd$_list_slice() {\n    var ans;\n    ans = Array.prototype.slice.apply(this, arguments);\n    _$rapyd$_list_decorate(ans);\n    return ans;\n}\nfunction _$rapyd$_list_iterator(value) {\n    var self;\n    self = this;\n    return {\n        \"_i\": -1,\n        \"_list\": self,\n        \"next\": function() {\n            this._i += 1;\n            if (this._i >= this._list.length) {\n                return {\n                    \"done\": true\n                };\n            }\n            return {\n                \"done\": false,\n                \"value\": this._list[this._i]\n            };\n        }\n    };\n}\nfunction _$rapyd$_list_len() {\n    return this.length;\n}\nfunction _$rapyd$_list_contains(val) {\n    for (var i = 0; i < this.length; i++) {\n        if ((this[i] === val || typeof this[i] === \"object\" && _$rapyd$_equals(this[i], val))) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction _$rapyd$_list_eq(other) {\n    if (!_$rapyd$_arraylike(other)) {\n        return false;\n    }\n    if ((this.length !== other.length && (typeof this.length !== \"object\" || _$rapyd$_not_equals(this.length, other.length)))) {\n        return false;\n    }\n    for (var i = 0; i < this.length; i++) {\n        if (!((this[i] === other[i] || typeof this[i] === \"object\" && _$rapyd$_equals(this[i], other[i])))) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction _$rapyd$_list_decorate(ans) {\n    ans.append = Array.prototype.push;\n    ans.toString = _$rapyd$_list_to_string;\n    ans.inspect = _$rapyd$_list_to_string;\n    ans.extend = _$rapyd$_list_extend;\n    ans.index = _$rapyd$_list_index;\n    ans.pypop = _$rapyd$_list_pop;\n    ans.remove = _$rapyd$_list_remove;\n    ans.insert = _$rapyd$_list_insert;\n    ans.copy = _$rapyd$_list_copy;\n    ans.clear = _$rapyd$_list_clear;\n    ans.count = _$rapyd$_list_count;\n    ans.concat = _$rapyd$_list_concat;\n    ans.pysort = _$rapyd$_list_sort;\n    ans.slice = _$rapyd$_list_slice;\n    ans.as_array = _$rapyd$_list_as_array;\n    ans.__len__ = _$rapyd$_list_len;\n    ans.__contains__ = _$rapyd$_list_contains;\n    ans.__eq__ = _$rapyd$_list_eq;\n    ans.constructor = _$rapyd$_list_constructor;\n    if (typeof ans[_$rapyd$_iterator_symbol] !== \"function\") {\n        ans[_$rapyd$_iterator_symbol] = _$rapyd$_list_iterator;\n    }\n    return ans;\n}\nfunction _$rapyd$_list_constructor(iterable) {\n    var ans, iterator, result;\n    if (iterable === undefined) {\n        ans = [];\n    } else if (_$rapyd$_arraylike(iterable)) {\n        ans = new Array(iterable.length);\n        for (var i = 0; i < iterable.length; i++) {\n            ans[i] = iterable[i];\n        }\n    } else if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n        ans = _$rapyd$_list_decorate([]);\n        result = iterator.next();\n        while (!result.done) {\n            ans.push(result.value);\n            result = iterator.next();\n        }\n    } else if (typeof iterable === \"number\") {\n        ans = new Array(iterable);\n    } else {\n        ans = Object.keys(iterable);\n    }\n    return _$rapyd$_list_decorate(ans);\n}\n_$rapyd$_list_constructor.__name__ = \"list\";\nvar list = _$rapyd$_list_constructor, list_wrap = _$rapyd$_list_decorate;\nfunction sorted() {\n    var iterable = ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true) ? undefined : arguments[0];\n    var key = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? (null) : arguments[1];\n    var reverse = (arguments[2] === undefined || ( 2 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? (false) : arguments[2];\n    var _$rapyd$_kwargs_obj = arguments[arguments.length-1];\n    if (_$rapyd$_kwargs_obj === null || typeof _$rapyd$_kwargs_obj !== \"object\" || _$rapyd$_kwargs_obj [_$rapyd$_kwargs_symbol] !== true) _$rapyd$_kwargs_obj = {};\n    if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"key\")){\n        key = _$rapyd$_kwargs_obj.key;\n    }\n    if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"reverse\")){\n        reverse = _$rapyd$_kwargs_obj.reverse;\n    }\n    var ans;\n    ans = _$rapyd$_list_constructor(iterable);\n    ans.pysort(key, reverse);\n    return ans;\n}\nvar _$rapyd$_global_object_id = 0, _$rapyd$_set_implementation;\nfunction _$rapyd$_set_keyfor(x) {\n    var t, ans;\n    t = typeof x;\n    if (t === \"string\" || t === \"number\" || t === \"boolean\") {\n        return \"_\" + t[0] + x;\n    }\n    if (x === null) {\n        return \"__!@#$0\";\n    }\n    ans = x._$rapyd$_hash_key_prop;\n    if (ans === undefined) {\n        ans = \"_!@#$\" + (++_$rapyd$_global_object_id);\n        Object.defineProperty(x, \"_$rapyd$_hash_key_prop\", {\n            \"value\": ans\n        });\n    }\n    return ans;\n}\nfunction _$rapyd$_set_polyfill() {\n    this._store = {};\n    this.size = 0;\n}\n_$rapyd$_set_polyfill.prototype.add = function(x) {\n    var key;\n    key = _$rapyd$_set_keyfor(x);\n    if (!Object.hasOwnProperty.call(this._store, key)) {\n        this.size += 1;\n        this._store[key] = x;\n    }\n    return this;\n};\n_$rapyd$_set_polyfill.prototype.clear = function(x) {\n    this._store = {};\n    this.size = 0;\n};\n_$rapyd$_set_polyfill.prototype.delete = function(x) {\n    var key;\n    key = _$rapyd$_set_keyfor(x);\n    if (Object.hasOwnProperty.call(this._store, key)) {\n        this.size -= 1;\n        delete this._store[key];\n        return true;\n    }\n    return false;\n};\n_$rapyd$_set_polyfill.prototype.has = function(x) {\n    return Object.hasOwnProperty.call(this._store, _$rapyd$_set_keyfor(x));\n};\n_$rapyd$_set_polyfill.prototype.values = function(x) {\n    var keys, s;\n    keys = Object.keys(this._store);\n    s = this._store;\n    return (function(){\n        var _$rapyd$_d = {};\n        _$rapyd$_d[\"_keys\"] = keys;\n        _$rapyd$_d[\"_i\"] = -1;\n        _$rapyd$_d[\"_s\"] = s;\n        _$rapyd$_d[_$rapyd$_iterator_symbol] = function() {\n            return this;\n        };\n        _$rapyd$_d[\"next\"] = function() {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {\n                    \"done\": true\n                };\n            }\n            return {\n                \"done\": false,\n                \"value\": s[this._keys[this._i]]\n            };\n        };\n        return _$rapyd$_d;\n    })();\n};\nif (typeof Set !== \"function\" || typeof Set.prototype.delete !== \"function\") {\n    _$rapyd$_set_implementation = _$rapyd$_set_polyfill;\n} else {\n    _$rapyd$_set_implementation = Set;\n}\nfunction _$rapyd$_set(iterable) {\n    var ans, s, iterator, result, keys;\n    if (this instanceof _$rapyd$_set) {\n        this.jsset = new _$rapyd$_set_implementation();\n        ans = this;\n        if (iterable === undefined) {\n            return ans;\n        }\n        s = ans.jsset;\n        if (_$rapyd$_arraylike(iterable)) {\n            for (var i = 0; i < iterable.length; i++) {\n                s.add(iterable[i]);\n            }\n        } else if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n            iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n            result = iterator.next();\n            while (!result.done) {\n                s.add(result.value);\n                result = iterator.next();\n            }\n        } else {\n            keys = Object.keys(iterable);\n            for (var i=0; i < keys.length; i++) {\n                s.add(keys[i]);\n            }\n        }\n        return ans;\n    } else {\n        return new _$rapyd$_set(iterable);\n    }\n}\n_$rapyd$_set.prototype.__name__ = \"set\";\nObject.defineProperties(_$rapyd$_set.prototype, {\n    \"length\": {\n        \"get\": function() {\n            return this.jsset.size;\n        }\n    },\n    \"size\": {\n        \"get\": function() {\n            return this.jsset.size;\n        }\n    }\n});\n_$rapyd$_set.prototype.__len__ = function() {\n    return this.jsset.size;\n};\n_$rapyd$_chain_assign_temp = function(x) {\n    return this.jsset.has(x);\n};\n_$rapyd$_set.prototype.has = _$rapyd$_chain_assign_temp;\n_$rapyd$_set.prototype.__contains__ = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_set.prototype.add = function(x) {\n    this.jsset.add(x);\n};\n_$rapyd$_set.prototype.clear = function() {\n    this.jsset.clear();\n};\n_$rapyd$_set.prototype.copy = function() {\n    return _$rapyd$_set(this);\n};\n_$rapyd$_set.prototype.discard = function(x) {\n    this.jsset.delete(x);\n};\n_$rapyd$_set.prototype[_$rapyd$_iterator_symbol] = function() {\n    return this.jsset.values();\n};\n_$rapyd$_set.prototype.difference = function() {\n    var ans, s, iterator, r, x, has;\n    ans = new _$rapyd$_set();\n    s = ans.jsset;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        has = false;\n        for (var i = 0; i < arguments.length; i++) {\n            if (arguments[i].has(x)) {\n                has = true;\n                break;\n            }\n        }\n        if (!has) {\n            s.add(x);\n        }\n        r = iterator.next();\n    }\n    return ans;\n};\n_$rapyd$_set.prototype.difference_update = function() {\n    var s, remove, iterator, r, x;\n    s = this.jsset;\n    remove = [];\n    iterator = s.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        for (var i = 0; i < arguments.length; i++) {\n            if (arguments[i].has(x)) {\n                remove.push(x);\n                break;\n            }\n        }\n        r = iterator.next();\n    }\n    for (var i = 0; i < remove.length; i++) {\n        s.delete(remove[i]);\n    }\n};\n_$rapyd$_set.prototype.intersection = function() {\n    var ans, s, iterator, r, x, has;\n    ans = new _$rapyd$_set();\n    s = ans.jsset;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        has = true;\n        for (var i = 0; i < arguments.length; i++) {\n            if (!arguments[i].has(x)) {\n                has = false;\n                break;\n            }\n        }\n        if (has) {\n            s.add(x);\n        }\n        r = iterator.next();\n    }\n    return ans;\n};\n_$rapyd$_set.prototype.intersection_update = function() {\n    var s, remove, iterator, r, x;\n    s = this.jsset;\n    remove = [];\n    iterator = s.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        for (var i = 0; i < arguments.length; i++) {\n            if (!arguments[i].has(x)) {\n                remove.push(x);\n                break;\n            }\n        }\n        r = iterator.next();\n    }\n    for (var i = 0; i < remove.length; i++) {\n        s.delete(remove[i]);\n    }\n};\n_$rapyd$_set.prototype.isdisjoint = function(other) {\n    var iterator, r, x;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        if (other.has(x)) {\n            return false;\n        }\n        r = iterator.next();\n    }\n    return true;\n};\n_$rapyd$_set.prototype.issubset = function(other) {\n    var iterator, r, x;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        if (!other.has(x)) {\n            return false;\n        }\n        r = iterator.next();\n    }\n    return true;\n};\n_$rapyd$_set.prototype.issuperset = function(other) {\n    var s, iterator, r, x;\n    s = this.jsset;\n    iterator = other.jsset.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        if (!s.has(x)) {\n            return false;\n        }\n        r = iterator.next();\n    }\n    return true;\n};\n_$rapyd$_set.prototype.pop = function() {\n    var iterator, r;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    if (r.done) {\n        throw new KeyError(\"pop from an empty set\");\n    }\n    this.jsset.delete(r.value);\n    return r.value;\n};\n_$rapyd$_set.prototype.remove = function(x) {\n    if (!this.jsset.delete(x)) {\n        throw new KeyError(x.toString());\n    }\n};\n_$rapyd$_set.prototype.symmetric_difference = function(other) {\n    return this.union(other).difference(this.intersection(other));\n};\n_$rapyd$_set.prototype.symmetric_difference_update = function(other) {\n    var common;\n    common = this.intersection(other);\n    this.update(other);\n    this.difference_update(common);\n};\n_$rapyd$_set.prototype.union = function() {\n    var ans;\n    ans = _$rapyd$_set(this);\n    ans.update.apply(ans, arguments);\n    return ans;\n};\n_$rapyd$_set.prototype.update = function() {\n    var s, iterator, r;\n    s = this.jsset;\n    for (var i=0; i < arguments.length; i++) {\n        iterator = arguments[i][_$rapyd$_iterator_symbol]();\n        r = iterator.next();\n        while (!r.done) {\n            s.add(r.value);\n            r = iterator.next();\n        }\n    }\n};\n_$rapyd$_chain_assign_temp = function() {\n    return \"{\" + list(this).join(\", \") + \"}\";\n};\n_$rapyd$_set.prototype.toString = _$rapyd$_chain_assign_temp;\n_$rapyd$_set.prototype.inspect = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_set.prototype.__eq__ = function(other) {\n    var iterator, r;\n    if (!(other instanceof this.constructor)) {\n        return false;\n    }\n    if (other.size !== this.size) {\n        return false;\n    }\n    if (other.size === 0) {\n        return true;\n    }\n    iterator = other[_$rapyd$_iterator_symbol]();\n    r = iterator.next();\n    while (!r.done) {\n        if (!this.has(r.value)) {\n            return false;\n        }\n        r = iterator.next();\n    }\n    return true;\n};\nfunction _$rapyd$_set_wrap(x) {\n    var ans;\n    ans = new _$rapyd$_set();\n    ans.jsset = x;\n    return ans;\n}\nvar set = _$rapyd$_set, set_wrap = _$rapyd$_set_wrap;\nvar _$rapyd$_dict_implementation;\nfunction _$rapyd$_dict_polyfill() {\n    this._store = {};\n    this.size = 0;\n}\n_$rapyd$_dict_polyfill.prototype.set = function(x, value) {\n    var key;\n    key = _$rapyd$_set_keyfor(x);\n    if (!Object.hasOwnProperty.call(this._store, key)) {\n        this.size += 1;\n    }\n    this._store[key] = [x, value];\n    return this;\n};\n_$rapyd$_dict_polyfill.prototype.clear = function(x) {\n    this._store = {};\n    this.size = 0;\n};\n_$rapyd$_dict_polyfill.prototype.delete = function(x) {\n    var key;\n    key = _$rapyd$_set_keyfor(x);\n    if (Object.hasOwnProperty.call(this._store, key)) {\n        this.size -= 1;\n        delete this._store[key];\n        return true;\n    }\n    return false;\n};\n_$rapyd$_dict_polyfill.prototype.has = function(x) {\n    return Object.hasOwnProperty.call(this._store, _$rapyd$_set_keyfor(x));\n};\n_$rapyd$_dict_polyfill.prototype.get = function(x) {\n    try {\n        return this._store[_$rapyd$_set_keyfor(x)][1];\n    } catch (_$rapyd$_Exception) {\n        if (_$rapyd$_Exception instanceof TypeError) {\n            return undefined;\n        } else {\n            throw _$rapyd$_Exception;\n        }\n    }\n};\n_$rapyd$_dict_polyfill.prototype.values = function(x) {\n    var keys, s;\n    keys = Object.keys(this._store);\n    s = this._store;\n    return (function(){\n        var _$rapyd$_d = {};\n        _$rapyd$_d[\"_keys\"] = keys;\n        _$rapyd$_d[\"_i\"] = -1;\n        _$rapyd$_d[\"_s\"] = s;\n        _$rapyd$_d[_$rapyd$_iterator_symbol] = function() {\n            return this;\n        };\n        _$rapyd$_d[\"next\"] = function() {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {\n                    \"done\": true\n                };\n            }\n            return {\n                \"done\": false,\n                \"value\": s[this._keys[this._i]][1]\n            };\n        };\n        return _$rapyd$_d;\n    })();\n};\n_$rapyd$_dict_polyfill.prototype.keys = function(x) {\n    var keys, s;\n    keys = Object.keys(this._store);\n    s = this._store;\n    return (function(){\n        var _$rapyd$_d = {};\n        _$rapyd$_d[\"_keys\"] = keys;\n        _$rapyd$_d[\"_i\"] = -1;\n        _$rapyd$_d[\"_s\"] = s;\n        _$rapyd$_d[_$rapyd$_iterator_symbol] = function() {\n            return this;\n        };\n        _$rapyd$_d[\"next\"] = function() {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {\n                    \"done\": true\n                };\n            }\n            return {\n                \"done\": false,\n                \"value\": s[this._keys[this._i]][0]\n            };\n        };\n        return _$rapyd$_d;\n    })();\n};\n_$rapyd$_dict_polyfill.prototype.entries = function(x) {\n    var keys, s;\n    keys = Object.keys(this._store);\n    s = this._store;\n    return (function(){\n        var _$rapyd$_d = {};\n        _$rapyd$_d[\"_keys\"] = keys;\n        _$rapyd$_d[\"_i\"] = -1;\n        _$rapyd$_d[\"_s\"] = s;\n        _$rapyd$_d[_$rapyd$_iterator_symbol] = function() {\n            return this;\n        };\n        _$rapyd$_d[\"next\"] = function() {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {\n                    \"done\": true\n                };\n            }\n            return {\n                \"done\": false,\n                \"value\": s[this._keys[this._i]]\n            };\n        };\n        return _$rapyd$_d;\n    })();\n};\nif (typeof Map !== \"function\" || typeof Map.prototype.delete !== \"function\") {\n    _$rapyd$_dict_implementation = _$rapyd$_dict_polyfill;\n} else {\n    _$rapyd$_dict_implementation = Map;\n}\nfunction _$rapyd$_dict(iterable) {\n    if (this instanceof _$rapyd$_dict) {\n        this.jsmap = new _$rapyd$_dict_implementation();\n        if (iterable !== undefined) {\n            this.update(iterable);\n        }\n        return this;\n    } else {\n        return new _$rapyd$_dict(iterable);\n    }\n}\n_$rapyd$_dict.prototype.__name__ = \"dict\";\nObject.defineProperties(_$rapyd$_dict.prototype, {\n    \"length\": {\n        \"get\": function() {\n            return this.jsmap.size;\n        }\n    },\n    \"size\": {\n        \"get\": function() {\n            return this.jsmap.size;\n        }\n    }\n});\n_$rapyd$_dict.prototype.__len__ = function() {\n    return this.jsmap.size;\n};\n_$rapyd$_chain_assign_temp = function(x) {\n    return this.jsmap.has(x);\n};\n_$rapyd$_dict.prototype.has = _$rapyd$_chain_assign_temp;\n_$rapyd$_dict.prototype.__contains__ = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_chain_assign_temp = function(key, value) {\n    this.jsmap.set(key, value);\n};\n_$rapyd$_dict.prototype.set = _$rapyd$_chain_assign_temp;\n_$rapyd$_dict.prototype.__setitem__ = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_dict.prototype.clear = function() {\n    this.jsmap.clear();\n};\n_$rapyd$_dict.prototype.copy = function() {\n    return _$rapyd$_dict(this);\n};\n_$rapyd$_dict.prototype.keys = function() {\n    return this.jsmap.keys();\n};\n_$rapyd$_dict.prototype.values = function() {\n    return this.jsmap.values();\n};\n_$rapyd$_chain_assign_temp = function() {\n    return this.jsmap.entries();\n};\n_$rapyd$_dict.prototype.items = _$rapyd$_chain_assign_temp;\n_$rapyd$_dict.prototype.entries = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_dict.prototype[_$rapyd$_iterator_symbol] = function() {\n    return this.jsmap.keys();\n};\n_$rapyd$_dict.prototype.__getitem__ = function(key) {\n    var ans;\n    ans = this.jsmap.get(key);\n    if (ans === undefined && !this.jsmap.has(key)) {\n        throw new KeyError(key + \"\");\n    }\n    return ans;\n};\n_$rapyd$_dict.prototype.get = function(key, defval) {\n    var ans;\n    ans = this.jsmap.get(key);\n    if (ans === undefined && !this.jsmap.has(key)) {\n        return (defval === undefined) ? null : defval;\n    }\n    return ans;\n};\n_$rapyd$_dict.prototype.set_default = function(key, defval) {\n    var j;\n    j = this.jsmap;\n    if (!j.has(key)) {\n        j.set(key, defval);\n        return defval;\n    }\n    return j.get(key);\n};\n_$rapyd$_chain_assign_temp = function() {\n    var iterable = ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true) ? undefined : arguments[0];\n    var value = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? (null) : arguments[1];\n    var _$rapyd$_kwargs_obj = arguments[arguments.length-1];\n    if (_$rapyd$_kwargs_obj === null || typeof _$rapyd$_kwargs_obj !== \"object\" || _$rapyd$_kwargs_obj [_$rapyd$_kwargs_symbol] !== true) _$rapyd$_kwargs_obj = {};\n    if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"value\")){\n        value = _$rapyd$_kwargs_obj.value;\n    }\n    var ans, iterator, r;\n    ans = _$rapyd$_dict();\n    iterator = iter(iterable);\n    r = iterator.next();\n    while (!r.done) {\n        ans.set(r.value, value);\n        r = iterator.next();\n    }\n    return ans;\n};\n_$rapyd$_dict.fromkeys = _$rapyd$_chain_assign_temp;\n_$rapyd$_dict.prototype.fromkeys = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_dict.prototype.pop = function(key, defval) {\n    var ans;\n    ans = this.jsmap.get(key);\n    if (ans === undefined && !this.jsmap.has(key)) {\n        if (defval === undefined) {\n            throw new KeyError(key);\n        }\n        return defval;\n    }\n    this.jsmap.delete(key);\n    return ans;\n};\n_$rapyd$_dict.prototype.popitem = function() {\n    var r;\n    r = this.jsmap.entries().next();\n    if (r.done) {\n        throw new KeyError(\"dict is empty\");\n    }\n    this.jsmap.delete(r.value[0]);\n    return r.value;\n};\n_$rapyd$_dict.prototype.update = function() {\n    var m, iterable, iterator, result, keys;\n    if (arguments.length === 0) {\n        return;\n    }\n    m = this.jsmap;\n    iterable = arguments[0];\n    if (Array.isArray(iterable)) {\n        for (var i = 0; i < iterable.length; i++) {\n            m.set(iterable[i][0], iterable[i][1]);\n        }\n    } else if (iterable instanceof _$rapyd$_dict) {\n        iterator = iterable.items();\n        result = iterator.next();\n        while (!result.done) {\n            m.set(result.value[0], result.value[1]);\n            result = iterator.next();\n        }\n    } else if (typeof Map === \"function\" && iterable instanceof Map) {\n        iterator = iterable.entries();\n        result = iterator.next();\n        while (!result.done) {\n            m.set(result.value[0], result.value[1]);\n            result = iterator.next();\n        }\n    } else if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n        iterator = iterable[_$rapyd$_iterator_symbol]();\n        result = iterator.next();\n        while (!result.done) {\n            m.set(result.value[0], result.value[1]);\n            result = iterator.next();\n        }\n    } else {\n        keys = Object.keys(iterable);\n        for (var i=0; i < keys.length; i++) {\n            if (keys[i] !== _$rapyd$_iterator_symbol) {\n                m.set(keys[i], iterable[keys[i]]);\n            }\n        }\n    }\n    if (arguments.length > 1) {\n        _$rapyd$_dict.prototype.update.call(this, arguments[1]);\n    }\n};\n_$rapyd$_chain_assign_temp = function() {\n    var entries, iterator, r;\n    entries = [];\n    iterator = this.jsmap.entries();\n    r = iterator.next();\n    while (!r.done) {\n        entries.push(r.value[0] + \": \" + r.value[1]);\n        r = iterator.next();\n    }\n    return \"{\" + entries.join(\", \") + \"}\";\n};\n_$rapyd$_dict.prototype.toString = _$rapyd$_chain_assign_temp;\n_$rapyd$_dict.prototype.inspect = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_dict.prototype.__eq__ = function(other) {\n    var iterator, r, x;\n    if (!(other instanceof this.constructor)) {\n        return false;\n    }\n    if (other.size !== this.size) {\n        return false;\n    }\n    if (other.size === 0) {\n        return true;\n    }\n    iterator = other.items();\n    r = iterator.next();\n    while (!r.done) {\n        x = this.jsmap.get(r.value[0]);\n        if (x === undefined && !this.jsmap.has(r.value[0]) || x !== r.value[1]) {\n            return false;\n        }\n        r = iterator.next();\n    }\n    return true;\n};\n_$rapyd$_dict.prototype.as_object = function(other) {\n    var ans, iterator, r;\n    ans = {};\n    iterator = this.jsmap.entries();\n    r = iterator.next();\n    while (!r.done) {\n        ans[r.value[0]] = r.value[1];\n        r = iterator.next();\n    }\n    return ans;\n};\nfunction _$rapyd$_dict_wrap(x) {\n    var ans;\n    ans = new _$rapyd$_dict();\n    ans.jsmap = x;\n    return ans;\n}\nvar dict = _$rapyd$_dict, dict_wrap = _$rapyd$_dict_wrap;;\n    function _$rapyd$_bool(val) {\n    return !!val;\n}\nfunction _$rapyd$_bind(fn, thisArg) {\n    var ret;\n    if (fn.orig) {\n        fn = fn.orig;\n    }\n    if (thisArg === false) {\n        return fn;\n    }\n    ret = function() {\n        return fn.apply(thisArg, arguments);\n    };\n    ret.orig = fn;\n    return ret;\n}\nfunction _$rapyd$_rebind_all(thisArg, rebind) {\n    if (typeof rebind === \"undefined\") {\n        rebind = true;\n    }\n    for (var p in thisArg) {\n        if (thisArg[p] && thisArg[p].orig) {\n            if (rebind) {\n                thisArg[p] = _$rapyd$_bind(thisArg[p], thisArg);\n            } else {\n                thisArg[p] = thisArg[p].orig;\n            }\n        }\n    }\n}\nfunction _$rapyd$_eslice(arr, step, start, end) {\n    var isString;\n    arr = arr.slice(0);\n    if (typeof arr === \"string\" || arr instanceof String) {\n        isString = true;\n        arr = arr.split(\"\");\n    }\n    if (step < 0) {\n        step = -step;\n        arr.reverse();\n        if (typeof start !== \"undefined\") {\n            start = arr.length - start - 1;\n        }\n        if (typeof end !== \"undefined\") {\n            end = arr.length - end - 1;\n        }\n    }\n    if (typeof start === \"undefined\") {\n        start = 0;\n    }\n    if (typeof end === \"undefined\") {\n        end = arr.length;\n    }\n    arr = arr.slice(start, end).filter(function(e, i) {\n        return i % step === 0;\n    });\n    return (isString) ? arr.join(\"\") : arr;\n}\nfunction _$rapyd$_mixin(target, source, overwrite) {\n    for (var i in source) {\n        if (source.hasOwnProperty(i) && overwrite || typeof target[i] === \"undefined\") {\n            target[i] = source[i];\n        }\n    }\n}\nfunction _$rapyd$_print() {\n    var parts;\n    if (typeof console === \"object\") {\n        parts = [];\n        for (var i = 0; i < arguments.length; i++) {\n            parts.push(_$rapyd$_str(arguments[i]));\n        }\n        console.log(parts.join(\" \"));\n    }\n}\nfunction _$rapyd$_int(val, base) {\n    var ans;\n    ans = parseInt(val, base || 10);\n    if (isNaN(ans)) {\n        throw new ValueError(\"Invalid literal for int with base \" + (base || 10) + \": \" + val);\n    }\n    return ans;\n}\nfunction _$rapyd$_float() {\n    var ans;\n    ans = parseFloat.apply(null, arguments);\n    if (isNaN(ans)) {\n        throw new ValueError(\"Could not convert string to float: \" + arguments[0]);\n    }\n    return ans;\n}\nfunction _$rapyd$_arraylike_creator() {\n    var names;\n    if (typeof HTMLCollection === \"function\") {\n        names = [\"[object HTMLCollection]\", \"[object NodeList]\", \"[object NamedNodeMap]\"];\n        return function(x) {\n            if (Array.isArray(x) || typeof x === \"string\" || names.indexOf(Object.prototype.toString.call(x)) > -1) {\n                return true;\n            }\n            return false;\n        };\n    }\n    return function(x) {\n        if (Array.isArray(x) || typeof x === \"string\") {\n            return true;\n        }\n        return false;\n    };\n}\nfunction options_object(f) {\n    return function() {\n        if (typeof arguments[arguments.length - 1] === \"object\") {\n            arguments[arguments.length - 1][_$rapyd$_kwargs_symbol] = true;\n        }\n        return f.apply(this, arguments);\n    };\n}\nfunction _$rapyd$_id(x) {\n    return x._$rapyd$_object_id;\n}\nvar bool = _$rapyd$_bool, bind = _$rapyd$_bind, rebind_all = _$rapyd$_rebind_all;\nvar float = _$rapyd$_float, int = _$rapyd$_int, arraylike = _$rapyd$_arraylike_creator(), _$rapyd$_arraylike = arraylike;\nvar mixin = _$rapyd$_mixin, print = _$rapyd$_print, eslice = _$rapyd$_eslice, id = _$rapyd$_id;;\n    function _$rapyd$_repr_js_builtin(x, as_array) {\n    var ans, b, keys, key;\n    ans = [];\n    b = \"{}\";\n    if (as_array) {\n        b = \"[]\";\n        for (var i = 0; i < x.length; i++) {\n            ans.push(_$rapyd$_repr(x[i]));\n        }\n    } else {\n        keys = Object.keys(x);\n        for (var k = 0; k < keys.length; k++) {\n            key = keys[k];\n            ans.push(JSON.stringify(key) + \":\" + _$rapyd$_repr(x[key]));\n        }\n    }\n    return b[0] + ans.join(\", \") + b[1];\n}\nfunction _$rapyd$_repr(x) {\n    var ans;\n    if (x === null) {\n        return \"None\";\n    }\n    if (x === undefined) {\n        return \"undefined\";\n    }\n    ans = x;\n    if (typeof x.__repr__ === \"function\") {\n        ans = x.__repr__();\n    } else if (x === true || x === false) {\n        ans = (x) ? \"True\" : \"False\";\n    } else if (Array.isArray(x)) {\n        ans = _$rapyd$_repr_js_builtin(x, true);\n    } else if (typeof x === \"function\") {\n        ans = x.toString();\n    } else {\n        ans = (typeof x.toString === \"function\") ? x.toString() : x;\n        if (ans === \"[object Object]\") {\n            return _$rapyd$_repr_js_builtin(x);\n        }\n        try {\n            ans = JSON.stringify(x);\n        } catch (_$rapyd$_Exception) {\n        }\n    }\n    return ans + \"\";\n}\nfunction _$rapyd$_str(x) {\n    var ans;\n    if (x === null) {\n        return \"None\";\n    }\n    if (x === undefined) {\n        return \"undefined\";\n    }\n    ans = x;\n    if (typeof x.__str__ === \"function\") {\n        ans = x.__str__();\n    } else if (typeof x.__repr__ === \"function\") {\n        ans = x.__repr__();\n    } else if (x === true || x === false) {\n        ans = (x) ? \"True\" : \"False\";\n    } else if (Array.isArray(x)) {\n        ans = _$rapyd$_repr_js_builtin(x, true);\n    } else if (typeof x.toString === \"function\") {\n        ans = x.toString();\n        if (ans === \"[object Object]\") {\n            ans = _$rapyd$_repr_js_builtin(x);\n        }\n    }\n    return ans + \"\";\n}\n_$rapyd$_str.format = function() {\n    var template, args, kwargs, explicit, implicit, _$rapyd$_chain_assign_temp, idx, ans, pos, in_brace, markup, ch;\n    template = arguments[0];\n    if (template === undefined) {\n        throw new TypeError(\"Template is required\");\n    }\n    args = Array.prototype.slice.call(arguments, 1);\n    kwargs = {};\n    if (args.length && args[args.length-1][_$rapyd$_kwargs_symbol] !== undefined) {\n        kwargs = args[args.length-1];\n        args = args.slice(0, -1);\n    }\n    _$rapyd$_chain_assign_temp = false;\n    explicit = _$rapyd$_chain_assign_temp;\n    implicit = _$rapyd$_chain_assign_temp;\n;\n    idx = 0;\n    if (_$rapyd$_str.format._template_resolve_pat === undefined) {\n        _$rapyd$_str.format._template_resolve_pat = /[.\\[]/;\n    }\n    function resolve(arg, object) {\n        var _$rapyd$_unpack, first, key, rest, ans;\n        if (!arg) {\n            return object;\n        }\n        _$rapyd$_unpack = [arg[0], arg.slice(1)];\n        first = _$rapyd$_unpack[0];\n        arg = _$rapyd$_unpack[1];\n        key = arg.split(_$rapyd$_str.format._template_resolve_pat, 1)[0];\n        rest = arg.slice(key.length);\n        ans = (first === \"[\") ? object[key.slice(0, -1)] : getattr(object, key);\n        if (ans === undefined) {\n            throw new KeyError((first === \"[\") ? key.slice(0, -1) : key);\n        }\n        return resolve(rest, ans);\n    }\n    function resolve_format_spec(format_spec) {\n        if (_$rapyd$_str.format._template_resolve_fs_pat === undefined) {\n            _$rapyd$_str.format._template_resolve_fs_pat = /[{]([a-zA-Z0-9_]+)[}]/g;\n        }\n        return format_spec.replace(_$rapyd$_str.format._template_resolve_fs_pat, function(match, key) {\n            if (!Object.prototype.hasOwnProperty.call(kwargs, key)) {\n                return \"\";\n            }\n            return \"\" + kwargs[key];\n        });\n    }\n    function apply_formatting(value, format_spec) {\n        var _$rapyd$_unpack, fill, align, sign, fhash, zeropad, width, comma, precision, ftype, is_numeric, is_int, lftype, code, exp, nval, is_positive, left, right;\n        if (format_spec.indexOf(\"{\") !== -1) {\n            format_spec = resolve_format_spec(format_spec);\n        }\n        if (_$rapyd$_str.format._template_format_pat === undefined) {\n            _$rapyd$_str.format._template_format_pat = /([^{}](?=[<>=^]))?([<>=^])?([-+\\x20])?(\\#)?(0)?(\\d+)?(,)?(?:\\.(\\d+))?([bcdeEfFgGnosxX%])?/;\n        }\n        try {\n            _$rapyd$_unpack = format_spec.match(_$rapyd$_str.format._template_format_pat).slice(1);\n            fill = _$rapyd$_unpack[0];\n            align = _$rapyd$_unpack[1];\n            sign = _$rapyd$_unpack[2];\n            fhash = _$rapyd$_unpack[3];\n            zeropad = _$rapyd$_unpack[4];\n            width = _$rapyd$_unpack[5];\n            comma = _$rapyd$_unpack[6];\n            precision = _$rapyd$_unpack[7];\n            ftype = _$rapyd$_unpack[8];\n        } catch (_$rapyd$_Exception) {\n            if (_$rapyd$_Exception instanceof TypeError) {\n                return value;\n            } else {\n                throw _$rapyd$_Exception;\n            }\n        }\n        if (zeropad) {\n            fill = fill || \"0\";\n            align = align || \"=\";\n        } else {\n            fill = fill || \" \";\n            align = align || \">\";\n        }\n        is_numeric = Number(value) === value;\n        is_int = is_numeric && value % 1 === 0;\n        precision = parseInt(precision, 10);\n        lftype = (ftype || \"\").toLowerCase();\n        if (ftype === \"n\") {\n            is_numeric = true;\n            if (is_int) {\n                if (comma) {\n                    throw new ValueError(\"Cannot specify ',' with 'n'\");\n                }\n                value = parseInt(value, 10).toLocaleString();\n            } else {\n                value = parseFloat(value).toLocaleString();\n            }\n        } else if (['b', 'c', 'd', 'o', 'x'].indexOf(lftype) !== -1) {\n            value = parseInt(value, 10);\n            is_numeric = true;\n            if (!isNaN(value)) {\n                if (ftype === \"b\") {\n                    value = (value >>> 0).toString(2);\n                    if (fhash) {\n                        value = \"0b\" + value;\n                    }\n                } else if (ftype === \"c\") {\n                    if (value > 65535) {\n                        code = value - 65536;\n                        value = String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n                    } else {\n                        value = String.fromCharCode(value);\n                    }\n                } else if (ftype === \"d\") {\n                    if (comma) {\n                        value = value.toLocaleString(\"en-US\");\n                    } else {\n                        value = value.toString(10);\n                    }\n                } else if (ftype === \"o\") {\n                    value = value.toString(8);\n                    if (fhash) {\n                        value = \"0o\" + value;\n                    }\n                } else if (lftype === \"x\") {\n                    value = value.toString(16);\n                    value = (ftype === \"x\") ? value.toLowerCase() : value.toUpperCase();\n                    if (fhash) {\n                        value = \"0x\" + value;\n                    }\n                }\n            }\n        } else if (['e','f','g','%'].indexOf(lftype) !== -1) {\n            is_numeric = true;\n            value = parseFloat(value);\n            if (lftype === \"e\") {\n                value = value.toExponential((isNaN(precision)) ? 6 : precision);\n                value = (ftype === \"E\") ? value.toUpperCase() : value.toLowerCase();\n            } else if (lftype === \"f\") {\n                value = value.toFixed((isNaN(precision)) ? 6 : precision);\n                value = (ftype === \"F\") ? value.toUpperCase() : value.toLowerCase();\n            } else if (ftype === \"%\") {\n                value *= 100;\n                value = value.toFixed((isNaN(precision)) ? 6 : precision) + \"%\";\n            } else if (lftype === \"g\") {\n                if (isNaN(precision)) {\n                    precision = 6;\n                }\n                precision = max(1, precision);\n                exp = parseInt(value.toExponential(precision - 1).toLowerCase().split(\"e\")[1], 10);\n                if (-4 <= exp && exp < precision) {\n                    value = value.toFixed(precision - 1 - exp);\n                } else {\n                    value = value.toExponential(precision - 1);\n                }\n                value = value.replace(/0+$/g, \"\");\n                if (value[value.length-1] === \".\") {\n                    value = value.slice(0, -1);\n                }\n                if (ftype === \"G\") {\n                    value = value.toUpperCase();\n                }\n            }\n        } else {\n            value += \"\";\n            if (!isNaN(precision)) {\n                value = value.slice(0, precision);\n            }\n        }\n        value += \"\";\n        if (is_numeric && sign) {\n            nval = Number(value);\n            is_positive = !isNaN(nval) && nval >= 0;\n            if (is_positive && (sign === \" \" || sign === \"+\")) {\n                value = sign + value;\n            }\n        }\n        function repeat(char, num) {\n            return (new Array(num+1)).join(char);\n        }\n        if (is_numeric && width && width[0] === \"0\") {\n            width = width.slice(1);\n            _$rapyd$_unpack = [\"0\", \"=\"];\n            fill = _$rapyd$_unpack[0];\n            align = _$rapyd$_unpack[1];\n        }\n        width = parseInt(width || \"-1\", 10);\n        if (isNaN(width)) {\n            throw new ValueError(\"Invalid width specification: \" + width);\n        }\n        if (fill && value.length < width) {\n            if (align === \"<\") {\n                value = value + repeat(fill, width - value.length);\n            } else if (align === \">\") {\n                value = repeat(fill, width - value.length) + value;\n            } else if (align === \"^\") {\n                left = Math.floor((width - value.length) / 2);\n                right = width - left - value.length;\n                value = repeat(fill, left) + value + repeat(fill, right);\n            } else if (align === \"=\") {\n                if (_$rapyd$_in(value[0], \"+- \")) {\n                    value = value[0] + repeat(fill, width - value.length) + value.slice(1);\n                } else {\n                    value = repeat(fill, width - value.length) + value;\n                }\n            } else {\n                throw new ValueError(\"Unrecognized alignment: \" + align);\n            }\n        }\n        return value;\n    }\n    function parse_markup(markup) {\n        var key, transformer, format_spec, _$rapyd$_chain_assign_temp, pos, state, ch;\n        _$rapyd$_chain_assign_temp = \"\";\n        key = _$rapyd$_chain_assign_temp;\n        transformer = _$rapyd$_chain_assign_temp;\n        format_spec = _$rapyd$_chain_assign_temp;\n;\n        pos = 0;\n        state = 0;\n        while (pos < markup.length) {\n            ch = markup[pos];\n            if (state === 0) {\n                if (ch === \"!\") {\n                    state = 1;\n                } else if (ch === \":\") {\n                    state = 2;\n                } else {\n                    key += ch;\n                }\n            } else if (state === 1) {\n                if (ch === \":\") {\n                    state = 2;\n                } else {\n                    transformer += ch;\n                }\n            } else {\n                format_spec += ch;\n            }\n            pos += 1;\n        }\n        return [key, transformer, format_spec];\n    }\n    function render_markup(markup) {\n        var _$rapyd$_unpack, key, transformer, format_spec, lkey, nvalue, object, ans;\n        _$rapyd$_unpack = parse_markup(markup);\n        key = _$rapyd$_unpack[0];\n        transformer = _$rapyd$_unpack[1];\n        format_spec = _$rapyd$_unpack[2];\n        if (transformer && ['a', 'r', 's'].indexOf(transformer) === -1) {\n            throw new ValueError(\"Unknown conversion specifier: \" + transformer);\n        }\n        lkey = key.length && key.split(/[.\\[]/, 1)[0];\n        if (lkey) {\n            explicit = true;\n            if (implicit) {\n                throw new ValueError(\"cannot switch from automatic field numbering to manual field specification\");\n            }\n            nvalue = parseInt(lkey);\n            object = (isNaN(nvalue)) ? kwargs[lkey] : args[nvalue];\n            if (object === undefined) {\n                if (isNaN(nvalue)) {\n                    throw new KeyError(lkey);\n                }\n                throw new IndexError(lkey);\n            }\n            object = resolve(key.slice(lkey.length), object);\n        } else {\n            implicit = true;\n            if (explicit) {\n                throw new ValueError(\"cannot switch from manual field specification to automatic field numbering\");\n            }\n            if (idx >= args.length) {\n                throw new IndexError(\"Not enough arguments to match template: \" + template);\n            }\n            object = args[idx];\n            idx += 1;\n        }\n        if (typeof object === \"function\") {\n            object = object();\n        }\n        ans = \"\" + object;\n        if (format_spec) {\n            ans = apply_formatting(ans, format_spec);\n        }\n        return ans;\n    }\n    ans = \"\";\n    pos = 0;\n    in_brace = 0;\n    markup = \"\";\n    while (pos < template.length) {\n        ch = template[pos];\n        if (in_brace) {\n            if (ch === \"{\") {\n                in_brace += 1;\n                markup += \"{\";\n            } else if (ch === \"}\") {\n                in_brace -= 1;\n                if (in_brace > 0) {\n                    markup += \"}\";\n                } else {\n                    ans += render_markup(markup);\n                }\n            } else {\n                markup += ch;\n            }\n        } else {\n            if (ch === \"{\") {\n                if (template[pos + 1] === \"{\") {\n                    pos += 1;\n                    ans += \"{\";\n                } else {\n                    in_brace = 1;\n                    markup = \"\";\n                }\n            } else {\n                ans += ch;\n            }\n        }\n        pos += 1;\n    }\n    if (in_brace) {\n        throw new ValueError(\"expected '}' before end of string\");\n    }\n    return ans;\n};\n_$rapyd$_str.capitalize = function(string) {\n    if (string) {\n        string = string[0].toUpperCase() + string.slice(1).toLowerCase();\n    }\n    return string;\n};\n_$rapyd$_str.center = function(string, width, fill) {\n    var left, right;\n    left = Math.floor((width - string.length) / 2);\n    right = width - left - string.length;\n    fill = fill || \" \";\n    return new Array(left+1).join(fill) + string + new Array(right+1).join(fill);\n};\n_$rapyd$_str.count = function(string, needle, start, end) {\n    var _$rapyd$_unpack, pos, step, ans;\n    start = start || 0;\n    end = end || string.length;\n    if (start < 0 || end < 0) {\n        string = string.slice(start, end);\n        _$rapyd$_unpack = [0, string.length];\n        start = _$rapyd$_unpack[0];\n        end = _$rapyd$_unpack[1];\n    }\n    pos = start;\n    step = needle.length;\n    ans = 0;\n    while (pos !== -1) {\n        pos = string.indexOf(needle, pos);\n        if (pos !== -1) {\n            ans += 1;\n            pos += step;\n        }\n    }\n    return ans;\n};\n_$rapyd$_str.endswith = function(string, suffixes, start, end) {\n    var q;\n    start = start || 0;\n    if (typeof suffixes === \"string\") {\n        suffixes = [suffixes];\n    }\n    if (end !== undefined) {\n        string = string.slice(0, end);\n    }\n    for (var i = 0; i < suffixes.length; i++) {\n        q = suffixes[i];\n        if (string.indexOf(q, Math.max(start, string.length - q.length)) !== -1) {\n            return true;\n        }\n    }\n    return false;\n};\n_$rapyd$_str.startswith = function(string, prefixes, start, end) {\n    var prefix;\n    start = start || 0;\n    if (typeof prefixes === \"string\") {\n        prefixes = [prefixes];\n    }\n    for (var i = 0; i < prefixes.length; i++) {\n        prefix = prefixes[i];\n        end = (end === undefined) ? string.length : end;\n        if (end - start >= prefix.length && prefix === string.slice(start, start + prefix.length)) {\n            return true;\n        }\n    }\n    return false;\n};\n_$rapyd$_str.find = function(string, needle, start, end) {\n    var ans;\n    while (start < 0) {\n        start += string.length;\n    }\n    ans = string.indexOf(needle, start);\n    if (end !== undefined && ans !== -1) {\n        while (end < 0) {\n            end += string.length;\n        }\n        if (ans >= end - needle.length) {\n            return -1;\n        }\n    }\n    return ans;\n};\n_$rapyd$_str.rfind = function(string, needle, start, end) {\n    var ans;\n    while (end < 0) {\n        end += string.length;\n    }\n    ans = string.lastIndexOf(needle, end - 1);\n    if (start !== undefined && ans !== -1) {\n        while (start < 0) {\n            start += string.length;\n        }\n        if (ans < start) {\n            return -1;\n        }\n    }\n    return ans;\n};\n_$rapyd$_str.index = function(string, needle, start, end) {\n    var ans;\n    ans = _$rapyd$_str.find.apply(null, arguments);\n    if (ans === -1) {\n        throw new ValueError(\"substring not found\");\n    }\n    return ans;\n};\n_$rapyd$_str.rindex = function(string, needle, start, end) {\n    var ans;\n    ans = _$rapyd$_str.rfind.apply(null, arguments);\n    if (ans === -1) {\n        throw new ValueError(\"substring not found\");\n    }\n    return ans;\n};\n_$rapyd$_str.islower = function(string) {\n    return string.length > 0 && string.toUpperCase() !== string;\n};\n_$rapyd$_str.isupper = function(string) {\n    return string.length > 0 && string.toLowerCase() !== string;\n};\n_$rapyd$_str.isspace = function(string) {\n    return string.length > 0 && /^\\s+$/.test(string);\n};\n_$rapyd$_str.join = function(string, iterable) {\n    var ans, r;\n    if (Array.isArray(iterable)) {\n        return iterable.join(string);\n    }\n    ans = \"\";\n    r = iterable.next();\n    while (!r.done) {\n        if (ans) {\n            ans += string;\n        }\n        ans += r.value;\n        r = iterable.next();\n    }\n    return ans;\n};\n_$rapyd$_str.ljust = function(string, width, fill) {\n    if (width > string.length) {\n        fill = fill || \" \";\n        string += new Array(width - string.length + 1).join(fill);\n    }\n    return string;\n};\n_$rapyd$_str.rjust = function(string, width, fill) {\n    if (width > string.length) {\n        fill = fill || \" \";\n        string = new Array(width - string.length + 1).join(fill) + string;\n    }\n    return string;\n};\n_$rapyd$_str.lower = function(string) {\n    return string.toLowerCase();\n};\n_$rapyd$_str.upper = function(string) {\n    return string.toUpperCase();\n};\n_$rapyd$_str.lstrip = function(string, chars) {\n    var pos;\n    pos = 0;\n    chars = chars || _$rapyd$_str.whitespace;\n    while (chars.indexOf(string[pos]) !== -1) {\n        pos += 1;\n    }\n    if (pos) {\n        string = string.slice(pos);\n    }\n    return string;\n};\n_$rapyd$_str.rstrip = function(string, chars) {\n    var pos;\n    pos = string.length - 1;\n    chars = chars || _$rapyd$_str.whitespace;\n    while (chars.indexOf(string[pos]) !== -1) {\n        pos -= 1;\n    }\n    if (pos < string.length - 1) {\n        string = string.slice(0, pos + 1);\n    }\n    return string;\n};\n_$rapyd$_str.strip = function(string, chars) {\n    return _$rapyd$_str.lstrip(_$rapyd$_str.rstrip(string, chars), chars);\n};\n_$rapyd$_str.partition = function(string, sep) {\n    var idx;\n    idx = string.indexOf(sep);\n    if (idx === -1) {\n        return [string, \"\", \"\"];\n    }\n    return [string.slice(0, idx), sep, string.slice(idx + sep.length)];\n};\n_$rapyd$_str.rpartition = function(string, sep) {\n    var idx;\n    idx = string.lastIndexOf(sep);\n    if (idx === -1) {\n        return [\"\", \"\", string];\n    }\n    return [string.slice(0, idx), sep, string.slice(idx + sep.length)];\n};\n_$rapyd$_str.replace = function(string, old, repl, count) {\n    var pos, idx;\n    if (count === 1) {\n        return string.replace(old, repl);\n    }\n    if (count < 1) {\n        return string;\n    }\n    count = count || Number.MAX_VALUE;\n    pos = 0;\n    while (count > 0) {\n        count -= 1;\n        idx = string.indexOf(old, pos);\n        if (idx === -1) {\n            break;\n        }\n        pos = idx + repl.length;\n        string = string.slice(0, idx) + repl + string.slice(idx + old.length);\n    }\n    return string;\n};\n_$rapyd$_str.split = function(string, sep, maxsplit) {\n    var ans, extra, parts;\n    if (maxsplit === 0) {\n        return _$rapyd$_list_decorate([ string ]);\n    }\n    if (sep === undefined || sep === null) {\n        if (maxsplit > 0) {\n            ans = string.split(/(\\s+)/);\n            extra = \"\";\n            parts = [];\n            for (var i = 0; i < ans.length; i++) {\n                if (parts.length >= maxsplit + 1) {\n                    extra += ans[i];\n                } else if (i % 2 === 0) {\n                    parts.push(ans[i]);\n                }\n            }\n            parts[parts.length-1] += extra;\n            ans = parts;\n        } else {\n            ans = string.split(/\\s+/);\n        }\n    } else {\n        if (sep === \"\") {\n            throw new ValueError(\"empty separator\");\n        }\n        ans = string.split(sep);\n        if (maxsplit > 0 && ans.length > maxsplit) {\n            extra = ans.slice(maxsplit).join(sep);\n            ans = ans.slice(0, maxsplit);\n            ans.push(extra);\n        }\n    }\n    return _$rapyd$_list_decorate(ans);\n};\n_$rapyd$_str.rsplit = function(string, sep, maxsplit) {\n    var ans, is_space, pos, current, spc, ch, end, _$rapyd$_chain_assign_temp, idx;\n    if (!maxsplit) {\n        return _$rapyd$_str.split.call(null, string, sep, maxsplit);\n    }\n    if (sep === undefined || sep === null) {\n        if (maxsplit > 0) {\n            ans = [];\n            is_space = /\\s/;\n            pos = string.length - 1;\n            current = \"\";\n            while (pos > -1 && maxsplit > 0) {\n                spc = false;\n                ch = string[pos];\n                while (pos > -1 && is_space.test(ch)) {\n                    spc = true;\n                    ch = string[--pos];\n                }\n                if (spc) {\n                    if (current) {\n                        ans.push(current);\n                        maxsplit -= 1;\n                    }\n                    current = ch;\n                } else {\n                    current += ch;\n                }\n                pos -= 1;\n            }\n            ans.push(string.slice(0, pos + 1) + current);\n            ans.reverse();\n        } else {\n            ans = string.split(/\\s+/);\n        }\n    } else {\n        if (sep === \"\") {\n            throw new ValueError(\"empty separator\");\n        }\n        ans = [];\n        _$rapyd$_chain_assign_temp = string.length;\n        pos = _$rapyd$_chain_assign_temp;\n        end = _$rapyd$_chain_assign_temp;\n;\n        while (pos > -1 && maxsplit > 0) {\n            maxsplit -= 1;\n            idx = string.lastIndexOf(sep, pos);\n            if (idx === -1) {\n                break;\n            }\n            ans.push(string.slice(idx + sep.length, end));\n            pos = idx - 1;\n            end = idx;\n        }\n        ans.push(string.slice(0, end));\n        ans.reverse();\n    }\n    return _$rapyd$_list_decorate(ans);\n};\n_$rapyd$_str.splitlines = function(string, keepends) {\n    var parts, ans;\n    if (keepends) {\n        parts = string.split(/((?:\\r?\\n)|\\r)/);\n        ans = [];\n        for (var i = 0; i < parts.length; i++) {\n            if (i % 2 === 0) {\n                ans.push(parts[i]);\n            } else {\n                ans[ans.length-1] += parts[i];\n            }\n        }\n    } else {\n        ans = string.split(/(?:\\r?\\n)|\\r/);\n    }\n    return _$rapyd$_list_decorate(ans);\n};\n_$rapyd$_str.swapcase = function(string) {\n    var ans, a, b;\n    ans = new Array(string.length);\n    for (var i = 0; i < ans.length; i++) {\n        a = string[i];\n        b = a.toLowerCase();\n        if (a === b) {\n            b = a.toUpperCase();\n        }\n        ans[i] = b;\n    }\n    return ans.join(\"\");\n};\n_$rapyd$_str.zfill = function(string, width) {\n    if (width > string.length) {\n        string = new Array(width - string.length + 1).join(\"0\") + string;\n    }\n    return string;\n};\n_$rapyd$_str.uchrs = function(string, with_positions) {\n    return (function(){\n        var _$rapyd$_d = {};\n        _$rapyd$_d[\"_string\"] = string;\n        _$rapyd$_d[\"_pos\"] = 0;\n        _$rapyd$_d[_$rapyd$_iterator_symbol] = function() {\n            return this;\n        };\n        _$rapyd$_d[\"next\"] = function() {\n            var length, pos, value, ans, extra;\n            length = this._string.length;\n            if (this._pos >= length) {\n                return {\n                    \"done\": true\n                };\n            }\n            pos = this._pos;\n            value = this._string.charCodeAt(this._pos++);\n            ans = \"\\ufffd\";\n            if (55296 <= value && value <= 56319) {\n                if (this._pos < length) {\n                    extra = this._string.charCodeAt(this._pos++);\n                    if ((extra & 56320) === 56320) {\n                        ans = String.fromCharCode(value, extra);\n                    }\n                }\n            } else if ((value & 56320) !== 56320) {\n                ans = String.fromCharCode(value);\n            }\n            if (with_positions) {\n                return {\n                    \"done\": false,\n                    \"value\": _$rapyd$_list_decorate([ pos, ans ])\n                };\n            } else {\n                return {\n                    \"done\": false,\n                    \"value\": ans\n                };\n            }\n        };\n        return _$rapyd$_d;\n    })();\n};\n_$rapyd$_str.uslice = function(string, start, end) {\n    var items, iterator, r;\n    items = [];\n    iterator = _$rapyd$_str.uchrs(string);\n    r = iterator.next();\n    while (!r.done) {\n        items.push(r.value);\n        r = iterator.next();\n    }\n    return items.slice(start || 0, (end === undefined) ? items.length : end).join(\"\");\n};\n_$rapyd$_str.ulen = function(string) {\n    var iterator, r, ans;\n    iterator = _$rapyd$_str.uchrs(string);\n    r = iterator.next();\n    ans = 0;\n    while (!r.done) {\n        r = iterator.next();\n        ans += 1;\n    }\n    return ans;\n};\n_$rapyd$_str.ascii_lowercase = \"abcdefghijklmnopqrstuvwxyz\";\n_$rapyd$_str.ascii_uppercase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n_$rapyd$_str.ascii_letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n_$rapyd$_str.digits = \"0123456789\";\n_$rapyd$_str.punctuation = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\n_$rapyd$_str.printable = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~ \\t\\n\\r\\u000b\\f\";\n_$rapyd$_str.whitespace = \" \\t\\n\\r\\u000b\\f\";\nvar str = _$rapyd$_str, repr = _$rapyd$_repr;;\n    var min = (function min() {\n            return Math.min;\n        })();\n    var max = (function max() {\n            return Math.max;\n        })();\n    function iter(iterable) {\n            var ans;\n            if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n                return (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n            }\n            if (_$rapyd$_arraylike(iterable)) {\n                ans = {\n                    \"_i\": -1,\n                    \"next\": function() {\n                        this._i += 1;\n                        if (this._i < iterable.length) {\n                            return {\n                                \"done\": false,\n                                \"value\": iterable[this._i]\n                            };\n                        }\n                        return {\n                            \"done\": true\n                        };\n                    }\n                };\n                ans[_$rapyd$_iterator_symbol] = function() {\n                    return this;\n                };\n                return ans;\n            }\n            return iter(Object.keys(iterable));\n        };\n    function getattr(obj, name, defval) {\n            var ret;\n            try {\n                ret = obj[name];\n            } catch (_$rapyd$_Exception) {\n                if (_$rapyd$_Exception instanceof TypeError) {\n                    if (defval === undefined) {\n                        throw new AttributeError(\"The attribute \" + name + \" is not present\");\n                    }\n                    return defval;\n                } else {\n                    throw _$rapyd$_Exception;\n                }\n            }\n            if (ret === undefined && !(name in obj)) {\n                if (defval === undefined) {\n                    throw new AttributeError(\"The attribute \" + name + \" is not present\");\n                }\n                ret = defval;\n            }\n            return ret;\n        };\n    var _$rapyd$_modules = {};\n    _$rapyd$_modules[\"utils\"] = {};\n    _$rapyd$_modules[\"errors\"] = {};\n    _$rapyd$_modules[\"unicode_aliases\"] = {};\n    _$rapyd$_modules[\"ast\"] = {};\n    _$rapyd$_modules[\"tokenizer\"] = {};\n    _$rapyd$_modules[\"parse\"] = {};\n    _$rapyd$_modules[\"output\"] = {};\n\n    (function(){\n        var __name__ = \"utils\";\n        var MAP;\n        function array_to_hash(a) {\n            var ret, i;\n            ret = Object.create(null);\n            for (var _$rapyd$_Index0 = 0; _$rapyd$_Index0 < len(a); _$rapyd$_Index0++) {\n                i = _$rapyd$_Index0;\n                ret[a[i]] = true;\n            }\n            return ret;\n        }\n        function slice(a, start) {\n            return Array.prototype.slice.call(a, start || 0);\n        }\n        function characters(str_) {\n            return str_.split(\"\");\n        }\n        function member(name, array) {\n            var i;\n            for (var _$rapyd$_Index1 = array.length - 1; _$rapyd$_Index1 > -1; _$rapyd$_Index1-=1) {\n                i = _$rapyd$_Index1;\n                if (array[i] === name) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function repeat_string(str_, i) {\n            var d;\n            if (i <= 0) {\n                return \"\";\n            }\n            if (i === 1) {\n                return str_;\n            }\n            d = repeat_string(str_, i >> 1);\n            d += d;\n            if (i & 1) {\n                d += str_;\n            }\n            return d;\n        }\n        function DefaultsError(msg, defs) {\n            this.msg = msg;\n            this.defs = defs;\n        }\n        function defaults(args, defs, croak) {\n            var ret, i;\n            if (args === true) {\n                args = {};\n            }\n            ret = args || {};\n            if (croak) {\n                var _$rapyd$_Iter2 = _$rapyd$_Iterable(ret);\n                for (var _$rapyd$_Index2 = 0; _$rapyd$_Index2 < _$rapyd$_Iter2.length; _$rapyd$_Index2++) {\n                    i = _$rapyd$_Iter2[_$rapyd$_Index2];\n                    if (!defs.hasOwnProperty(i)) {\n                        throw new DefaultsError(\"`\" + i + \"` is not a supported option\", defs);\n                    }\n                }\n            }\n            var _$rapyd$_Iter3 = _$rapyd$_Iterable(defs);\n            for (var _$rapyd$_Index3 = 0; _$rapyd$_Index3 < _$rapyd$_Iter3.length; _$rapyd$_Index3++) {\n                i = _$rapyd$_Iter3[_$rapyd$_Index3];\n                ret[i] = (args && args.hasOwnProperty(i)) ? args[i] : defs[i];\n            }\n            return ret;\n        }\n        function merge(obj, ext) {\n            var i;\n            var _$rapyd$_Iter4 = _$rapyd$_Iterable(ext);\n            for (var _$rapyd$_Index4 = 0; _$rapyd$_Index4 < _$rapyd$_Iter4.length; _$rapyd$_Index4++) {\n                i = _$rapyd$_Iter4[_$rapyd$_Index4];\n                obj[i] = ext[i];\n            }\n            return obj;\n        }\n        function noop() {\n        }\n        MAP = function() {\n            var skip, _$rapyd$_chain_assign_temp;\n            function MAP(a, f, backwards) {\n                var ret, top, i;\n                ret = _$rapyd$_list_decorate([]);\n                top = _$rapyd$_list_decorate([]);\n                function doit() {\n                    var val, is_last;\n                    val = f(a[i], i);\n                    is_last = val instanceof Last;\n                    if (is_last) {\n                        val = val.v;\n                    }\n                    if (val instanceof AtTop) {\n                        val = val.v;\n                        if (val instanceof Splice) {\n                            top.push.apply(top, (backwards) ? val.v.slice().reverse() : val.v);\n                        } else {\n                            top.push(val);\n                        }\n                    } else if (val !== skip) {\n                        if (val instanceof Splice) {\n                            ret.push.apply(ret, (backwards) ? val.v.slice().reverse() : val.v);\n                        } else {\n                            ret.push(val);\n                        }\n                    }\n                    return is_last;\n                }\n                if (Array.isArray(a)) {\n                    if (backwards) {\n                        for (var _$rapyd$_Index5 = a.length - 1; _$rapyd$_Index5 > -1; _$rapyd$_Index5-=1) {\n                            i = _$rapyd$_Index5;\n                            if (doit()) {\n                                break;\n                            }\n                        }\n                        ret.reverse();\n                        top.reverse();\n                    } else {\n                        for (var _$rapyd$_Index6 = 0; _$rapyd$_Index6 < len(a); _$rapyd$_Index6++) {\n                            i = _$rapyd$_Index6;\n                            if (doit()) {\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    var _$rapyd$_Iter7 = _$rapyd$_Iterable(a);\n                    for (var _$rapyd$_Index7 = 0; _$rapyd$_Index7 < _$rapyd$_Iter7.length; _$rapyd$_Index7++) {\n                        i = _$rapyd$_Iter7[_$rapyd$_Index7];\n                        if (doit()) {\n                            break;\n                        }\n                    }\n                }\n                return top.concat(ret);\n            }\n            MAP.at_top = function(val) {\n                return new AtTop(val);\n            };\n            MAP.splice = function(val) {\n                return new Splice(val);\n            };\n            MAP.last = function(val) {\n                return new Last(val);\n            };\n            _$rapyd$_chain_assign_temp = {};\n            skip = _$rapyd$_chain_assign_temp;\n            MAP.skip = _$rapyd$_chain_assign_temp;\n;\n            function AtTop(val) {\n                this.v = val;\n            }\n            function Splice(val) {\n                this.v = val;\n            }\n            function Last(val) {\n                this.v = val;\n            }\n            return MAP;\n        }.call(this);\n        function push_uniq(array, el) {\n            if (array.indexOf(el) < 0) {\n                array.push(el);\n            }\n        }\n        function string_template(text, props) {\n            return text.replace(/\\{(.+?)\\}/g, function(str_, p) {\n                return props[p];\n            });\n        }\n        function remove(array, el) {\n            var i;\n            for (var _$rapyd$_Index8 = array.length - 1; _$rapyd$_Index8 > -1; _$rapyd$_Index8-=1) {\n                i = _$rapyd$_Index8;\n                if (array[i] === el) {\n                    array.splice(i, 1);\n                }\n            }\n        }\n        function mergeSort(array, cmp) {\n            if (array.length < 2) {\n                return array.slice();\n            }\n            function merge(a, b) {\n                var r, ai, bi, i;\n                r = _$rapyd$_list_decorate([]);\n                ai = 0;\n                bi = 0;\n                i = 0;\n                while (ai < a.length && bi < b.length) {\n                    if (cmp(a[ai], b[bi]) <= 0) {\n                        r[i] = a[ai];\n                        ai += 1;\n                    } else {\n                        r[i] = b[bi];\n                        bi += 1;\n                    }\n                    i += 1;\n                }\n                if (ai < a.length) {\n                    r.push.apply(r, a.slice(ai));\n                }\n                if (bi < b.length) {\n                    r.push.apply(r, b.slice(bi));\n                }\n                return r;\n            }\n            function _ms(a) {\n                var m, left, right;\n                if (a.length <= 1) {\n                    return a;\n                }\n                m = Math.floor(a.length / 2);\n                left = a.slice(0, m);\n                right = a.slice(m);\n                left = _ms(left);\n                right = _ms(right);\n                return merge(left, right);\n            }\n            return _ms(array);\n        }\n        function set_difference(a, b) {\n            return a.filter(function(el) {\n                return b.indexOf(el) < 0;\n            });\n        }\n        function set_intersection(a, b) {\n            return a.filter(function(el) {\n                return b.indexOf(el) >= 0;\n            });\n        }\n        function make_predicate(words) {\n            var a, k;\n            if (!Array.isArray(words)) {\n                words = words.split(\" \");\n            }\n            if (typeof Set === \"function\") {\n                a = new Set(words);\n                return function(x) {\n                    return a.has(x);\n                };\n            } else {\n                a = {};\n                var _$rapyd$_Iter9 = _$rapyd$_Iterable(words);\n                for (var _$rapyd$_Index9 = 0; _$rapyd$_Index9 < _$rapyd$_Iter9.length; _$rapyd$_Index9++) {\n                    k = _$rapyd$_Iter9[_$rapyd$_Index9];\n                    a[k] = true;\n                }\n                return function(x) {\n                    return a.hasOwnProperty(x);\n                };\n            }\n        }\n        _$rapyd$_modules[\"utils\"][\"MAP\"] = MAP;\n\n        _$rapyd$_modules[\"utils\"][\"array_to_hash\"] = array_to_hash;\n\n        _$rapyd$_modules[\"utils\"][\"slice\"] = slice;\n\n        _$rapyd$_modules[\"utils\"][\"characters\"] = characters;\n\n        _$rapyd$_modules[\"utils\"][\"member\"] = member;\n\n        _$rapyd$_modules[\"utils\"][\"repeat_string\"] = repeat_string;\n\n        _$rapyd$_modules[\"utils\"][\"DefaultsError\"] = DefaultsError;\n\n        _$rapyd$_modules[\"utils\"][\"defaults\"] = defaults;\n\n        _$rapyd$_modules[\"utils\"][\"merge\"] = merge;\n\n        _$rapyd$_modules[\"utils\"][\"noop\"] = noop;\n\n        _$rapyd$_modules[\"utils\"][\"push_uniq\"] = push_uniq;\n\n        _$rapyd$_modules[\"utils\"][\"string_template\"] = string_template;\n\n        _$rapyd$_modules[\"utils\"][\"remove\"] = remove;\n\n        _$rapyd$_modules[\"utils\"][\"mergeSort\"] = mergeSort;\n\n        _$rapyd$_modules[\"utils\"][\"set_difference\"] = set_difference;\n\n        _$rapyd$_modules[\"utils\"][\"set_intersection\"] = set_intersection;\n\n        _$rapyd$_modules[\"utils\"][\"make_predicate\"] = make_predicate;\n    })();\n\n    (function(){\n        var __name__ = \"errors\";\n        function SyntaxError() {\n            if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n            SyntaxError.prototype.__init__.apply(this, arguments);\n        }\n        _$rapyd$_extends(SyntaxError, Error);\n        SyntaxError.prototype.__init__ = function __init__(message, filename, line, col, pos, is_eof) {\n            var self = this;\n            self.stack = new Error().stack;\n            self.message = message;\n            self.line = line;\n            self.col = col;\n            self.pos = pos;\n            self.is_eof = is_eof;\n            self.filename = filename;\n            self.lineNumber = line;\n            self.fileName = filename;\n        };\n        SyntaxError.prototype.toString = function toString() {\n            var self = this;\n            var ans;\n            ans = self.message + \" (line: \" + self.line + \", col: \" + self.col + \", pos: \" + self.pos + \")\";\n            if (self.filename) {\n                ans = self.filename + \":\" + ans;\n            }\n            if (self.stack) {\n                ans += \"\\n\\n\" + self.stack;\n            }\n            return ans;\n        };\n        SyntaxError.prototype.__repr__ = function __repr__ () {\n            return \"<\" + __name__ + \".\" + \"SyntaxError\" + \" #\" + this._$rapyd$_object_id + \">\";\n        };\n        SyntaxError.prototype.__str__ = function __str__ () {\n            return this.__repr__();\n        };\n\n        function ImportError() {\n            if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n            ImportError.prototype.__init__.apply(this, arguments);\n        }\n        _$rapyd$_extends(ImportError, SyntaxError);\n        ImportError.prototype.__init__ = function __init__ () {\n            SyntaxError.prototype.__init__ && SyntaxError.prototype.__init__.apply(this, arguments);\n        };\n        ImportError.prototype.__repr__ = function __repr__ () {\n            return \"<\" + __name__ + \".\" + \"ImportError\" + \" #\" + this._$rapyd$_object_id + \">\";\n        };\n        ImportError.prototype.__str__ = function __str__ () {\n            return this.__repr__();\n        };\n        \n\n        _$rapyd$_modules[\"errors\"][\"SyntaxError\"] = SyntaxError;\n\n        _$rapyd$_modules[\"errors\"][\"ImportError\"] = ImportError;\n    })();\n\n    (function(){\n        var __name__ = \"unicode_aliases\";\n        var DB, ALIAS_MAP;\n        DB = \"\\n# NameAliases-8.0.0.txt\\n# Date: 2014-11-19, 01:30:00 GMT [KW, LI]\\n#\\n# This file is a normative contributory data file in the\\n# Unicode Character Database.\\n#\\n# Copyright (c) 2005-2014 Unicode, Inc.\\n# For terms of use, see http://www.unicode.org/terms_of_use.html\\n#\\n# This file defines the formal name aliases for Unicode characters.\\n#\\n# For informative aliases, see NamesList.txt\\n#\\n# The formal name aliases are divided into five types, each with a distinct label.\\n#\\n# Type Labels:\\n#\\n# 1. correction\\n#      Corrections for serious problems in the character names\\n# 2. control\\n#      ISO 6429 names for C0 and C1 control functions, and other\\n#      commonly occurring names for control codes\\n# 3. alternate\\n#      A few widely used alternate names for format characters\\n# 4. figment\\n#      Several documented labels for C1 control code points which\\n#      were never actually approved in any standard\\n# 5. abbreviation\\n#      Commonly occurring abbreviations (or acronyms) for control codes,\\n#      format characters, spaces, and variation selectors\\n#\\n# The formal name aliases are part of the Unicode character namespace, which\\n# includes the character names and the names of named character sequences.\\n# The inclusion of ISO 6429 names and other commonly occurring names and\\n# abbreviations for control codes and format characters as formal name aliases\\n# is to help avoid name collisions between Unicode character names and the\\n# labels which commonly appear in text and/or in implementations such as regex, for\\n# control codes (which for historical reasons have no Unicode character name)\\n# or for format characters.\\n#\\n# For documentation, see NamesList.html and http://www.unicode.org/reports/tr44/\\n#\\n# FORMAT\\n#\\n# Each line has three fields, as described here:\\n#\\n# First field:  Code point\\n# Second field: Alias\\n# Third field:  Type\\n#\\n# The type labels used are defined above. As for property values, comparisons\\n# of type labels should ignore case.\\n#\\n# The type labels can be mapped to other strings for display, if desired.\\n#\\n# In case multiple aliases are assigned, additional aliases\\n# are provided on separate lines. Parsers of this data file should\\n# take note that the same code point can (and does) occur more than once.\\n#\\n# Note that currently the only instances of multiple aliases of the same\\n# type for a single code point are either of type \\\"control\\\" or \\\"abbreviation\\\".\\n# An alias of type \\\"abbreviation\\\" can, in principle, be added for any code\\n# point, although currently aliases of type \\\"correction\\\" do not have\\n# any additional aliases of type \\\"abbreviation\\\". Such relationships\\n# are not enforced by stability policies.\\n#\\n#-----------------------------------------------------------------\\n\\n0000;NULL;control\\n0000;NUL;abbreviation\\n0001;START OF HEADING;control\\n0001;SOH;abbreviation\\n0002;START OF TEXT;control\\n0002;STX;abbreviation\\n0003;END OF TEXT;control\\n0003;ETX;abbreviation\\n0004;END OF TRANSMISSION;control\\n0004;EOT;abbreviation\\n0005;ENQUIRY;control\\n0005;ENQ;abbreviation\\n0006;ACKNOWLEDGE;control\\n0006;ACK;abbreviation\\n\\n# Note that no formal name alias for the ISO 6429 \\\"BELL\\\" is\\n# provided for U+0007, because of the existing name collision\\n# with U+1F514 BELL.\\n\\n0007;ALERT;control\\n0007;BEL;abbreviation\\n\\n0008;BACKSPACE;control\\n0008;BS;abbreviation\\n0009;CHARACTER TABULATION;control\\n0009;HORIZONTAL TABULATION;control\\n0009;HT;abbreviation\\n0009;TAB;abbreviation\\n000A;LINE FEED;control\\n000A;NEW LINE;control\\n000A;END OF LINE;control\\n000A;LF;abbreviation\\n000A;NL;abbreviation\\n000A;EOL;abbreviation\\n000B;LINE TABULATION;control\\n000B;VERTICAL TABULATION;control\\n000B;VT;abbreviation\\n000C;FORM FEED;control\\n000C;FF;abbreviation\\n000D;CARRIAGE RETURN;control\\n000D;CR;abbreviation\\n000E;SHIFT OUT;control\\n000E;LOCKING-SHIFT ONE;control\\n000E;SO;abbreviation\\n000F;SHIFT IN;control\\n000F;LOCKING-SHIFT ZERO;control\\n000F;SI;abbreviation\\n0010;DATA LINK ESCAPE;control\\n0010;DLE;abbreviation\\n0011;DEVICE CONTROL ONE;control\\n0011;DC1;abbreviation\\n0012;DEVICE CONTROL TWO;control\\n0012;DC2;abbreviation\\n0013;DEVICE CONTROL THREE;control\\n0013;DC3;abbreviation\\n0014;DEVICE CONTROL FOUR;control\\n0014;DC4;abbreviation\\n0015;NEGATIVE ACKNOWLEDGE;control\\n0015;NAK;abbreviation\\n0016;SYNCHRONOUS IDLE;control\\n0016;SYN;abbreviation\\n0017;END OF TRANSMISSION BLOCK;control\\n0017;ETB;abbreviation\\n0018;CANCEL;control\\n0018;CAN;abbreviation\\n0019;END OF MEDIUM;control\\n0019;EOM;abbreviation\\n001A;SUBSTITUTE;control\\n001A;SUB;abbreviation\\n001B;ESCAPE;control\\n001B;ESC;abbreviation\\n001C;INFORMATION SEPARATOR FOUR;control\\n001C;FILE SEPARATOR;control\\n001C;FS;abbreviation\\n001D;INFORMATION SEPARATOR THREE;control\\n001D;GROUP SEPARATOR;control\\n001D;GS;abbreviation\\n001E;INFORMATION SEPARATOR TWO;control\\n001E;RECORD SEPARATOR;control\\n001E;RS;abbreviation\\n001F;INFORMATION SEPARATOR ONE;control\\n001F;UNIT SEPARATOR;control\\n001F;US;abbreviation\\n0020;SP;abbreviation\\n007F;DELETE;control\\n007F;DEL;abbreviation\\n\\n# PADDING CHARACTER and HIGH OCTET PRESET represent\\n# architectural concepts initially proposed for early\\n# drafts of ISO/IEC 10646-1. They were never actually\\n# approved or standardized: hence their designation\\n# here as the \\\"figment\\\" type. Formal name aliases\\n# (and corresponding abbreviations) for these code\\n# points are included here because these names leaked\\n# out from the draft documents and were published in\\n# at least one RFC whose names for code points was\\n# implemented in Perl regex expressions.\\n\\n0080;PADDING CHARACTER;figment\\n0080;PAD;abbreviation\\n0081;HIGH OCTET PRESET;figment\\n0081;HOP;abbreviation\\n\\n0082;BREAK PERMITTED HERE;control\\n0082;BPH;abbreviation\\n0083;NO BREAK HERE;control\\n0083;NBH;abbreviation\\n0084;INDEX;control\\n0084;IND;abbreviation\\n0085;NEXT LINE;control\\n0085;NEL;abbreviation\\n0086;START OF SELECTED AREA;control\\n0086;SSA;abbreviation\\n0087;END OF SELECTED AREA;control\\n0087;ESA;abbreviation\\n0088;CHARACTER TABULATION SET;control\\n0088;HORIZONTAL TABULATION SET;control\\n0088;HTS;abbreviation\\n0089;CHARACTER TABULATION WITH JUSTIFICATION;control\\n0089;HORIZONTAL TABULATION WITH JUSTIFICATION;control\\n0089;HTJ;abbreviation\\n008A;LINE TABULATION SET;control\\n008A;VERTICAL TABULATION SET;control\\n008A;VTS;abbreviation\\n008B;PARTIAL LINE FORWARD;control\\n008B;PARTIAL LINE DOWN;control\\n008B;PLD;abbreviation\\n008C;PARTIAL LINE BACKWARD;control\\n008C;PARTIAL LINE UP;control\\n008C;PLU;abbreviation\\n008D;REVERSE LINE FEED;control\\n008D;REVERSE INDEX;control\\n008D;RI;abbreviation\\n008E;SINGLE SHIFT TWO;control\\n008E;SINGLE-SHIFT-2;control\\n008E;SS2;abbreviation\\n008F;SINGLE SHIFT THREE;control\\n008F;SINGLE-SHIFT-3;control\\n008F;SS3;abbreviation\\n0090;DEVICE CONTROL STRING;control\\n0090;DCS;abbreviation\\n0091;PRIVATE USE ONE;control\\n0091;PRIVATE USE-1;control\\n0091;PU1;abbreviation\\n0092;PRIVATE USE TWO;control\\n0092;PRIVATE USE-2;control\\n0092;PU2;abbreviation\\n0093;SET TRANSMIT STATE;control\\n0093;STS;abbreviation\\n0094;CANCEL CHARACTER;control\\n0094;CCH;abbreviation\\n0095;MESSAGE WAITING;control\\n0095;MW;abbreviation\\n0096;START OF GUARDED AREA;control\\n0096;START OF PROTECTED AREA;control\\n0096;SPA;abbreviation\\n0097;END OF GUARDED AREA;control\\n0097;END OF PROTECTED AREA;control\\n0097;EPA;abbreviation\\n0098;START OF STRING;control\\n0098;SOS;abbreviation\\n\\n# SINGLE GRAPHIC CHARACTER INTRODUCER is another\\n# architectural concept from early drafts of ISO/IEC 10646-1\\n# which was never approved and standardized.\\n\\n0099;SINGLE GRAPHIC CHARACTER INTRODUCER;figment\\n0099;SGC;abbreviation\\n\\n009A;SINGLE CHARACTER INTRODUCER;control\\n009A;SCI;abbreviation\\n009B;CONTROL SEQUENCE INTRODUCER;control\\n009B;CSI;abbreviation\\n009C;STRING TERMINATOR;control\\n009C;ST;abbreviation\\n009D;OPERATING SYSTEM COMMAND;control\\n009D;OSC;abbreviation\\n009E;PRIVACY MESSAGE;control\\n009E;PM;abbreviation\\n009F;APPLICATION PROGRAM COMMAND;control\\n009F;APC;abbreviation\\n00A0;NBSP;abbreviation\\n00AD;SHY;abbreviation\\n01A2;LATIN CAPITAL LETTER GHA;correction\\n01A3;LATIN SMALL LETTER GHA;correction\\n034F;CGJ;abbreviation\\n061C;ALM;abbreviation\\n0709;SYRIAC SUBLINEAR COLON SKEWED LEFT;correction\\n0CDE;KANNADA LETTER LLLA;correction\\n0E9D;LAO LETTER FO FON;correction\\n0E9F;LAO LETTER FO FAY;correction\\n0EA3;LAO LETTER RO;correction\\n0EA5;LAO LETTER LO;correction\\n0FD0;TIBETAN MARK BKA- SHOG GI MGO RGYAN;correction\\n180B;FVS1;abbreviation\\n180C;FVS2;abbreviation\\n180D;FVS3;abbreviation\\n180E;MVS;abbreviation\\n200B;ZWSP;abbreviation\\n200C;ZWNJ;abbreviation\\n200D;ZWJ;abbreviation\\n200E;LRM;abbreviation\\n200F;RLM;abbreviation\\n202A;LRE;abbreviation\\n202B;RLE;abbreviation\\n202C;PDF;abbreviation\\n202D;LRO;abbreviation\\n202E;RLO;abbreviation\\n202F;NNBSP;abbreviation\\n205F;MMSP;abbreviation\\n2060;WJ;abbreviation\\n2066;LRI;abbreviation\\n2067;RLI;abbreviation\\n2068;FSI;abbreviation\\n2069;PDI;abbreviation\\n2118;WEIERSTRASS ELLIPTIC FUNCTION;correction\\n2448;MICR ON US SYMBOL;correction\\n2449;MICR DASH SYMBOL;correction\\n2B7A;LEFTWARDS TRIANGLE-HEADED ARROW WITH DOUBLE VERTICAL STROKE;correction\\n2B7C;RIGHTWARDS TRIANGLE-HEADED ARROW WITH DOUBLE VERTICAL STROKE;correction\\nA015;YI SYLLABLE ITERATION MARK;correction\\nFE18;PRESENTATION FORM FOR VERTICAL RIGHT WHITE LENTICULAR BRACKET;correction\\nFE00;VS1;abbreviation\\nFE01;VS2;abbreviation\\nFE02;VS3;abbreviation\\nFE03;VS4;abbreviation\\nFE04;VS5;abbreviation\\nFE05;VS6;abbreviation\\nFE06;VS7;abbreviation\\nFE07;VS8;abbreviation\\nFE08;VS9;abbreviation\\nFE09;VS10;abbreviation\\nFE0A;VS11;abbreviation\\nFE0B;VS12;abbreviation\\nFE0C;VS13;abbreviation\\nFE0D;VS14;abbreviation\\nFE0E;VS15;abbreviation\\nFE0F;VS16;abbreviation\\nFEFF;BYTE ORDER MARK;alternate\\nFEFF;BOM;abbreviation\\nFEFF;ZWNBSP;abbreviation\\n122D4;CUNEIFORM SIGN NU11 TENU;correction\\n122D5;CUNEIFORM SIGN NU11 OVER NU11 BUR OVER BUR;correction\\n1D0C5;BYZANTINE MUSICAL SYMBOL FTHORA SKLIRON CHROMA VASIS;correction\\nE0100;VS17;abbreviation\\nE0101;VS18;abbreviation\\nE0102;VS19;abbreviation\\nE0103;VS20;abbreviation\\nE0104;VS21;abbreviation\\nE0105;VS22;abbreviation\\nE0106;VS23;abbreviation\\nE0107;VS24;abbreviation\\nE0108;VS25;abbreviation\\nE0109;VS26;abbreviation\\nE010A;VS27;abbreviation\\nE010B;VS28;abbreviation\\nE010C;VS29;abbreviation\\nE010D;VS30;abbreviation\\nE010E;VS31;abbreviation\\nE010F;VS32;abbreviation\\nE0110;VS33;abbreviation\\nE0111;VS34;abbreviation\\nE0112;VS35;abbreviation\\nE0113;VS36;abbreviation\\nE0114;VS37;abbreviation\\nE0115;VS38;abbreviation\\nE0116;VS39;abbreviation\\nE0117;VS40;abbreviation\\nE0118;VS41;abbreviation\\nE0119;VS42;abbreviation\\nE011A;VS43;abbreviation\\nE011B;VS44;abbreviation\\nE011C;VS45;abbreviation\\nE011D;VS46;abbreviation\\nE011E;VS47;abbreviation\\nE011F;VS48;abbreviation\\nE0120;VS49;abbreviation\\nE0121;VS50;abbreviation\\nE0122;VS51;abbreviation\\nE0123;VS52;abbreviation\\nE0124;VS53;abbreviation\\nE0125;VS54;abbreviation\\nE0126;VS55;abbreviation\\nE0127;VS56;abbreviation\\nE0128;VS57;abbreviation\\nE0129;VS58;abbreviation\\nE012A;VS59;abbreviation\\nE012B;VS60;abbreviation\\nE012C;VS61;abbreviation\\nE012D;VS62;abbreviation\\nE012E;VS63;abbreviation\\nE012F;VS64;abbreviation\\nE0130;VS65;abbreviation\\nE0131;VS66;abbreviation\\nE0132;VS67;abbreviation\\nE0133;VS68;abbreviation\\nE0134;VS69;abbreviation\\nE0135;VS70;abbreviation\\nE0136;VS71;abbreviation\\nE0137;VS72;abbreviation\\nE0138;VS73;abbreviation\\nE0139;VS74;abbreviation\\nE013A;VS75;abbreviation\\nE013B;VS76;abbreviation\\nE013C;VS77;abbreviation\\nE013D;VS78;abbreviation\\nE013E;VS79;abbreviation\\nE013F;VS80;abbreviation\\nE0140;VS81;abbreviation\\nE0141;VS82;abbreviation\\nE0142;VS83;abbreviation\\nE0143;VS84;abbreviation\\nE0144;VS85;abbreviation\\nE0145;VS86;abbreviation\\nE0146;VS87;abbreviation\\nE0147;VS88;abbreviation\\nE0148;VS89;abbreviation\\nE0149;VS90;abbreviation\\nE014A;VS91;abbreviation\\nE014B;VS92;abbreviation\\nE014C;VS93;abbreviation\\nE014D;VS94;abbreviation\\nE014E;VS95;abbreviation\\nE014F;VS96;abbreviation\\nE0150;VS97;abbreviation\\nE0151;VS98;abbreviation\\nE0152;VS99;abbreviation\\nE0153;VS100;abbreviation\\nE0154;VS101;abbreviation\\nE0155;VS102;abbreviation\\nE0156;VS103;abbreviation\\nE0157;VS104;abbreviation\\nE0158;VS105;abbreviation\\nE0159;VS106;abbreviation\\nE015A;VS107;abbreviation\\nE015B;VS108;abbreviation\\nE015C;VS109;abbreviation\\nE015D;VS110;abbreviation\\nE015E;VS111;abbreviation\\nE015F;VS112;abbreviation\\nE0160;VS113;abbreviation\\nE0161;VS114;abbreviation\\nE0162;VS115;abbreviation\\nE0163;VS116;abbreviation\\nE0164;VS117;abbreviation\\nE0165;VS118;abbreviation\\nE0166;VS119;abbreviation\\nE0167;VS120;abbreviation\\nE0168;VS121;abbreviation\\nE0169;VS122;abbreviation\\nE016A;VS123;abbreviation\\nE016B;VS124;abbreviation\\nE016C;VS125;abbreviation\\nE016D;VS126;abbreviation\\nE016E;VS127;abbreviation\\nE016F;VS128;abbreviation\\nE0170;VS129;abbreviation\\nE0171;VS130;abbreviation\\nE0172;VS131;abbreviation\\nE0173;VS132;abbreviation\\nE0174;VS133;abbreviation\\nE0175;VS134;abbreviation\\nE0176;VS135;abbreviation\\nE0177;VS136;abbreviation\\nE0178;VS137;abbreviation\\nE0179;VS138;abbreviation\\nE017A;VS139;abbreviation\\nE017B;VS140;abbreviation\\nE017C;VS141;abbreviation\\nE017D;VS142;abbreviation\\nE017E;VS143;abbreviation\\nE017F;VS144;abbreviation\\nE0180;VS145;abbreviation\\nE0181;VS146;abbreviation\\nE0182;VS147;abbreviation\\nE0183;VS148;abbreviation\\nE0184;VS149;abbreviation\\nE0185;VS150;abbreviation\\nE0186;VS151;abbreviation\\nE0187;VS152;abbreviation\\nE0188;VS153;abbreviation\\nE0189;VS154;abbreviation\\nE018A;VS155;abbreviation\\nE018B;VS156;abbreviation\\nE018C;VS157;abbreviation\\nE018D;VS158;abbreviation\\nE018E;VS159;abbreviation\\nE018F;VS160;abbreviation\\nE0190;VS161;abbreviation\\nE0191;VS162;abbreviation\\nE0192;VS163;abbreviation\\nE0193;VS164;abbreviation\\nE0194;VS165;abbreviation\\nE0195;VS166;abbreviation\\nE0196;VS167;abbreviation\\nE0197;VS168;abbreviation\\nE0198;VS169;abbreviation\\nE0199;VS170;abbreviation\\nE019A;VS171;abbreviation\\nE019B;VS172;abbreviation\\nE019C;VS173;abbreviation\\nE019D;VS174;abbreviation\\nE019E;VS175;abbreviation\\nE019F;VS176;abbreviation\\nE01A0;VS177;abbreviation\\nE01A1;VS178;abbreviation\\nE01A2;VS179;abbreviation\\nE01A3;VS180;abbreviation\\nE01A4;VS181;abbreviation\\nE01A5;VS182;abbreviation\\nE01A6;VS183;abbreviation\\nE01A7;VS184;abbreviation\\nE01A8;VS185;abbreviation\\nE01A9;VS186;abbreviation\\nE01AA;VS187;abbreviation\\nE01AB;VS188;abbreviation\\nE01AC;VS189;abbreviation\\nE01AD;VS190;abbreviation\\nE01AE;VS191;abbreviation\\nE01AF;VS192;abbreviation\\nE01B0;VS193;abbreviation\\nE01B1;VS194;abbreviation\\nE01B2;VS195;abbreviation\\nE01B3;VS196;abbreviation\\nE01B4;VS197;abbreviation\\nE01B5;VS198;abbreviation\\nE01B6;VS199;abbreviation\\nE01B7;VS200;abbreviation\\nE01B8;VS201;abbreviation\\nE01B9;VS202;abbreviation\\nE01BA;VS203;abbreviation\\nE01BB;VS204;abbreviation\\nE01BC;VS205;abbreviation\\nE01BD;VS206;abbreviation\\nE01BE;VS207;abbreviation\\nE01BF;VS208;abbreviation\\nE01C0;VS209;abbreviation\\nE01C1;VS210;abbreviation\\nE01C2;VS211;abbreviation\\nE01C3;VS212;abbreviation\\nE01C4;VS213;abbreviation\\nE01C5;VS214;abbreviation\\nE01C6;VS215;abbreviation\\nE01C7;VS216;abbreviation\\nE01C8;VS217;abbreviation\\nE01C9;VS218;abbreviation\\nE01CA;VS219;abbreviation\\nE01CB;VS220;abbreviation\\nE01CC;VS221;abbreviation\\nE01CD;VS222;abbreviation\\nE01CE;VS223;abbreviation\\nE01CF;VS224;abbreviation\\nE01D0;VS225;abbreviation\\nE01D1;VS226;abbreviation\\nE01D2;VS227;abbreviation\\nE01D3;VS228;abbreviation\\nE01D4;VS229;abbreviation\\nE01D5;VS230;abbreviation\\nE01D6;VS231;abbreviation\\nE01D7;VS232;abbreviation\\nE01D8;VS233;abbreviation\\nE01D9;VS234;abbreviation\\nE01DA;VS235;abbreviation\\nE01DB;VS236;abbreviation\\nE01DC;VS237;abbreviation\\nE01DD;VS238;abbreviation\\nE01DE;VS239;abbreviation\\nE01DF;VS240;abbreviation\\nE01E0;VS241;abbreviation\\nE01E1;VS242;abbreviation\\nE01E2;VS243;abbreviation\\nE01E3;VS244;abbreviation\\nE01E4;VS245;abbreviation\\nE01E5;VS246;abbreviation\\nE01E6;VS247;abbreviation\\nE01E7;VS248;abbreviation\\nE01E8;VS249;abbreviation\\nE01E9;VS250;abbreviation\\nE01EA;VS251;abbreviation\\nE01EB;VS252;abbreviation\\nE01EC;VS253;abbreviation\\nE01ED;VS254;abbreviation\\nE01EE;VS255;abbreviation\\nE01EF;VS256;abbreviation\\n\\n# EOF\\n\";\n        ALIAS_MAP = function() {\n            var ans, line, parts, code_point;\n            ans = {};\n            var _$rapyd$_Iter10 = _$rapyd$_Iterable(DB.split(\"\\n\"));\n            for (var _$rapyd$_Index10 = 0; _$rapyd$_Index10 < _$rapyd$_Iter10.length; _$rapyd$_Index10++) {\n                line = _$rapyd$_Iter10[_$rapyd$_Index10];\n                line = line.trim();\n                if (!line || line[0] === \"#\") {\n                    continue;\n                }\n                parts = line.split(\";\");\n                if (parts.length >= 2) {\n                    code_point = parseInt(parts[0], 16);\n                    if (code_point !== undefined && parts[1]) {\n                        ans[parts[1].toLowerCase()] = code_point;\n                    }\n                }\n            }\n            return ans;\n        }();\n        _$rapyd$_modules[\"unicode_aliases\"][\"DB\"] = DB;\n\n        _$rapyd$_modules[\"unicode_aliases\"][\"ALIAS_MAP\"] = ALIAS_MAP;\n    })();\n\n    (function(){\n        var __name__ = \"ast\";\n        var AST_Token, AST_Node, AST_Statement, AST_Debugger, AST_Directive, AST_SimpleStatement, AST_Block, AST_BlockStatement, AST_EmptyStatement, AST_StatementWithBody, AST_DWLoop, AST_Do, AST_While, AST_ForIn, AST_ForJS, AST_ListComprehension, AST_SetComprehension, AST_DictComprehension, AST_GeneratorComprehension, AST_With, AST_WithClause, AST_Scope, AST_Toplevel, AST_Import, AST_Imports, AST_Decorator, AST_Lambda, AST_Accessor, AST_Function, AST_Class, AST_Method, AST_Jump, AST_Exit, AST_Return, AST_Yield, AST_Throw, AST_LoopControl, AST_Break, AST_Continue, AST_If, AST_Try, AST_Catch, AST_Except, AST_Finally, AST_Definitions, AST_Var, AST_Const, AST_VarDef, AST_BaseCall, AST_Call, AST_ClassCall, AST_New, AST_Seq, AST_PropAccess, AST_Dot, AST_Sub, AST_ItemAccess, AST_Splice, AST_Unary, AST_UnaryPrefix, AST_UnaryPostfix, AST_Binary, AST_Conditional, AST_Assign, AST_Array, AST_Object, AST_ExpressiveObject, AST_ObjectProperty, AST_ObjectKeyVal, AST_Set, AST_SetItem, AST_Symbol, AST_SymbolAlias, AST_SymbolAccessor, AST_SymbolDeclaration, AST_SymbolVar, AST_ImportedVar, AST_SymbolConst, AST_SymbolNonlocal, AST_SymbolFunarg, AST_SymbolDefun, AST_SymbolLambda, AST_SymbolCatch, AST_SymbolRef, AST_This, AST_Constant, AST_String, AST_Verbatim, AST_Number, AST_RegExp, AST_Atom, AST_Null, AST_NaN, AST_Undefined, AST_Hole, AST_Infinity, AST_Boolean, AST_False, AST_True;\n        var noop = _$rapyd$_modules[\"utils\"].noop;\n        var string_template = _$rapyd$_modules[\"utils\"].string_template;\n        \n        function DEFNODE(type, props, methods, base) {\n            var self_props, code, i, proto, ctor, _$rapyd$_chain_assign_temp;\n            if (arguments.length < 4) {\n                base = AST_Node;\n            }\n            if (!props) {\n                props = _$rapyd$_list_decorate([]);\n            } else {\n                props = props.split(/\\s+/);\n            }\n            self_props = props;\n            if (base && base.PROPS) {\n                props = props.concat(base.PROPS);\n            }\n            code = \"return function AST_\" + type + \"(props){ if (props) { \";\n            for (var _$rapyd$_Index11 = props.length - 1; _$rapyd$_Index11 > -1; _$rapyd$_Index11-=1) {\n                i = _$rapyd$_Index11;\n                code += \"this.\" + props[i] + \" = props.\" + props[i] + \";\";\n            }\n            proto = base && new base();\n            if (proto && proto.initialize || methods && methods.initialize) {\n                code += \"this.initialize();\";\n            }\n            code += \"}}\";\n            ctor = new Function(code)();\n            if (proto) {\n                ctor.prototype = proto;\n                ctor.BASE = base;\n            }\n            if (base) {\n                base.SUBCLASSES.push(ctor);\n            }\n            ctor.prototype.CTOR = ctor;\n            ctor.PROPS = props || null;\n            ctor.SELF_PROPS = self_props;\n            ctor.SUBCLASSES = _$rapyd$_list_decorate([]);\n            if (type) {\n                _$rapyd$_chain_assign_temp = type;\n                ctor.prototype.TYPE = _$rapyd$_chain_assign_temp;\n                ctor.TYPE = _$rapyd$_chain_assign_temp;\n;\n            }\n            if (methods) {\n                var _$rapyd$_Iter12 = _$rapyd$_Iterable(methods);\n                for (var _$rapyd$_Index12 = 0; _$rapyd$_Index12 < _$rapyd$_Iter12.length; _$rapyd$_Index12++) {\n                    i = _$rapyd$_Iter12[_$rapyd$_Index12];\n                    if (/^\\$/.test(i)) {\n                        ctor[i.substr(1)] = methods[i];\n                    } else {\n                        ctor.prototype[i] = methods[i];\n                    }\n                }\n            }\n            ctor.DEFMETHOD = function(name, method) {\n                this.prototype[name] = method;\n            };\n            return ctor;\n        }\n        AST_Token = DEFNODE(\"Token\", \"type value line col pos endpos nlb comments_before file\", {}, null);\n        AST_Node = DEFNODE(\"Node\", \"start end\", {\n            \"clone\": function() {\n                return new this.CTOR(this);\n            },\n            \"$documentation\": \"Base class of all AST nodes\",\n            \"$propdoc\": {\n                \"start\": \"[AST_Token] The first token of this node\",\n                \"end\": \"[AST_Token] The last token of this node\"\n            },\n            \"_walk\": function(visitor) {\n                return visitor._visit(this);\n            },\n            \"walk\": function(visitor) {\n                return this._walk(visitor);\n            },\n            \"_dump\": function() {\n                var depth = (arguments[0] === undefined || ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? (100) : arguments[0];\n                var omit = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? ((function(){\n                    var s = _$rapyd$_set();\n                    s.jsset.add(\"start\");\n                    s.jsset.add(\"end\");\n                    return s;\n                })()) : arguments[1];\n                var offset = (arguments[2] === undefined || ( 2 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? (0) : arguments[2];\n                var include_name = (arguments[3] === undefined || ( 3 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? (true) : arguments[3];\n                var _$rapyd$_kwargs_obj = arguments[arguments.length-1];\n                if (_$rapyd$_kwargs_obj === null || typeof _$rapyd$_kwargs_obj !== \"object\" || _$rapyd$_kwargs_obj [_$rapyd$_kwargs_symbol] !== true) _$rapyd$_kwargs_obj = {};\n                if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"depth\")){\n                    depth = _$rapyd$_kwargs_obj.depth;\n                }\n                if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"omit\")){\n                    omit = _$rapyd$_kwargs_obj.omit;\n                }\n                if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"offset\")){\n                    offset = _$rapyd$_kwargs_obj.offset;\n                }\n                if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"include_name\")){\n                    include_name = _$rapyd$_kwargs_obj.include_name;\n                }\n                var p, reset, yellow, blue, green, red, magenta, pad, element, property, key;\n                p = console.log;\n                reset = \"\\u001b[0m\";\n                yellow = \"\\u001b[33m\";\n                blue = \"\\u001b[34m\";\n                green = \"\\u001b[32m\";\n                red = \"\\u001b[31m\";\n                magenta = \"\\u001b[35m\";\n                pad = new Array(offset + 1).join(\"  \");\n                if (include_name) {\n                    p(pad + yellow + this.TYPE + reset);\n                }\n                var _$rapyd$_Iter13 = _$rapyd$_Iterable(this);\n                for (var _$rapyd$_Index13 = 0; _$rapyd$_Index13 < _$rapyd$_Iter13.length; _$rapyd$_Index13++) {\n                    key = _$rapyd$_Iter13[_$rapyd$_Index13];\n                    if (_$rapyd$_in(key, omit)) {\n                        continue;\n                    }\n                    if (Array.isArray(this[key])) {\n                        if (this[key].length) {\n                            p(pad + \" \" + blue + key + \": \" + reset + \"[\");\n                            if (depth > 1) {\n                                var _$rapyd$_Iter14 = _$rapyd$_Iterable(this[key]);\n                                for (var _$rapyd$_Index14 = 0; _$rapyd$_Index14 < _$rapyd$_Iter14.length; _$rapyd$_Index14++) {\n                                    element = _$rapyd$_Iter14[_$rapyd$_Index14];\n                                    element._dump(depth - 1, omit, offset + 1, true);\n                                }\n                            } else {\n                                var _$rapyd$_Iter15 = _$rapyd$_Iterable(this[key]);\n                                for (var _$rapyd$_Index15 = 0; _$rapyd$_Index15 < _$rapyd$_Iter15.length; _$rapyd$_Index15++) {\n                                    element = _$rapyd$_Iter15[_$rapyd$_Index15];\n                                    p(pad + \"   \" + yellow + element.TYPE + reset);\n                                }\n                            }\n                            p(pad + \" ]\");\n                        } else {\n                            p(pad + \" \" + blue + key + \": \" + reset + \"[]\");\n                        }\n                    } else if (this[key]) {\n                        if (this[key].TYPE) {\n                            if (this[key].TYPE === \"Token\") {\n                                p(pad + \" \" + blue + key + \": \" + magenta + this[key].TYPE + reset);\n                                var _$rapyd$_Iter16 = _$rapyd$_Iterable(this[key]);\n                                for (var _$rapyd$_Index16 = 0; _$rapyd$_Index16 < _$rapyd$_Iter16.length; _$rapyd$_Index16++) {\n                                    property = _$rapyd$_Iter16[_$rapyd$_Index16];\n                                    p(pad + \"   \" + blue + property + \": \" + reset + this[key][property]);\n                                }\n                            } else {\n                                p(pad + \" \" + blue + key + \": \" + yellow + this[key].TYPE + reset);\n                                if (depth > 1) {\n                                    this[key]._dump(depth - 1, omit, offset + 1, false);\n                                }\n                            }\n                        } else if (typeof this[key] === \"string\") {\n                            p(pad + \" \" + blue + key + \": \" + green + \"\\\"\" + this[key] + \"\\\"\" + reset);\n                        } else if (typeof this[key] === \"number\") {\n                            p(pad + \" \" + blue + key + \": \" + green + this[key] + reset);\n                        } else {\n                            p(pad + \" \" + blue + key + \": \" + red + this[key] + reset);\n                        }\n                    } else {\n                        p(pad + \" \" + blue + key + \": \" + reset + this[key]);\n                    }\n                }\n            },\n            \"dump\": function() {\n                var depth = (arguments[0] === undefined || ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? (2) : arguments[0];\n                var omit = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? (_$rapyd$_list_decorate([])) : arguments[1];\n                var _$rapyd$_kwargs_obj = arguments[arguments.length-1];\n                if (_$rapyd$_kwargs_obj === null || typeof _$rapyd$_kwargs_obj !== \"object\" || _$rapyd$_kwargs_obj [_$rapyd$_kwargs_symbol] !== true) _$rapyd$_kwargs_obj = {};\n                if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"depth\")){\n                    depth = _$rapyd$_kwargs_obj.depth;\n                }\n                if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"omit\")){\n                    omit = _$rapyd$_kwargs_obj.omit;\n                }\n                return this._dump(depth, omit, 0, true);\n            }\n        }, null);\n        AST_Node.warn_function = null;\n        AST_Node.warn = function(txt, props) {\n            if (AST_Node.warn_function) {\n                AST_Node.warn_function(string_template(txt, props));\n            }\n        };\n        AST_Statement = DEFNODE(\"Statement\", null, {\n            \"$documentation\": \"Base class of all statements\"\n        });\n        AST_Debugger = DEFNODE(\"Debugger\", null, {\n            \"$documentation\": \"Represents a debugger statement\"\n        }, AST_Statement);\n        AST_Directive = DEFNODE(\"Directive\", \"value scope\", {\n            \"$documentation\": \"Represents a directive, like \\\"use strict\\\";\",\n            \"$propdoc\": {\n                \"value\": \"[string] The value of this directive as a plain string (it's not an AST_String!)\",\n                \"scope\": \"[AST_Scope/S] The scope that this directive affects\"\n            }\n        }, AST_Statement);\n        AST_SimpleStatement = DEFNODE(\"SimpleStatement\", \"body\", {\n            \"$documentation\": \"A statement consisting of an expression, i.e. a = 1 + 2\",\n            \"$propdoc\": {\n                \"body\": \"[AST_Node] an expression node (should not be instanceof AST_Statement)\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.body._walk(visitor);\n                });\n            }\n        }, AST_Statement);\n        function walk_body(node, visitor) {\n            if (node.body instanceof AST_Statement) {\n                node.body._walk(visitor);\n            } else if (node.body) {\n                node.body.forEach(function(stat) {\n                    stat._walk(visitor);\n                });\n            }\n        }\n        AST_Block = DEFNODE(\"Block\", \"body\", {\n            \"$documentation\": \"A body of statements (usually bracketed)\",\n            \"$propdoc\": {\n                \"body\": \"[AST_Statement*] an array of statements\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(this, function() {\n                    walk_body(node, visitor);\n                });\n            }\n        }, AST_Statement);\n        AST_BlockStatement = DEFNODE(\"BlockStatement\", null, {\n            \"$documentation\": \"A block statement\"\n        }, AST_Block);\n        AST_EmptyStatement = DEFNODE(\"EmptyStatement\", \"stype\", {\n            \"$documentation\": \"The empty statement (empty block or simply a semicolon)\",\n            \"$propdoc\": {\n                \"stype\": \"[string] the type of empty statement. Is ; for semicolons\"\n            },\n            \"_walk\": function(visitor) {\n                return visitor._visit(this);\n            }\n        }, AST_Statement);\n        AST_StatementWithBody = DEFNODE(\"StatementWithBody\", \"body\", {\n            \"$documentation\": \"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`\",\n            \"$propdoc\": {\n                \"body\": \"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.body._walk(visitor);\n                });\n            }\n        }, AST_Statement);\n        AST_DWLoop = DEFNODE(\"DWLoop\", \"condition\", {\n            \"$documentation\": \"Base class for do/while statements\",\n            \"$propdoc\": {\n                \"condition\": \"[AST_Node] the loop condition.  Should not be instanceof AST_Statement\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.condition._walk(visitor);\n                    node.body._walk(visitor);\n                });\n            }\n        }, AST_StatementWithBody);\n        AST_Do = DEFNODE(\"Do\", null, {\n            \"$documentation\": \"A `do` statement\"\n        }, AST_DWLoop);\n        AST_While = DEFNODE(\"While\", null, {\n            \"$documentation\": \"A `while` statement\"\n        }, AST_DWLoop);\n        AST_ForIn = DEFNODE(\"ForIn\", \"init name object\", {\n            \"$documentation\": \"A `for ... in` statement\",\n            \"$propdoc\": {\n                \"init\": \"[AST_Node] the `for/in` initialization code\",\n                \"name\": \"[AST_SymbolRef?] the loop variable, only if `init` is AST_Var\",\n                \"object\": \"[AST_Node] the object that we're looping through\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.init._walk(visitor);\n                    if (node.name) node.name._walk(visitor);\n                    node.object._walk(visitor);\n                    if (node.body) {\n                        node.body._walk(visitor);\n                    }\n                });\n            }\n        }, AST_StatementWithBody);\n        AST_ForJS = DEFNODE(\"ForJS\", \"condition\", {\n            \"$documentation\": \"A `for ... in` statement\",\n            \"$propdoc\": {\n                \"condition\": \"[AST_Verbatim] raw JavaScript conditional\"\n            }\n        }, AST_StatementWithBody);\n        AST_ListComprehension = DEFNODE(\"ListComprehension\", \"condition statement\", {\n            \"$documentation\": \"A list comprehension expression\",\n            \"$propdoc\": {\n                \"condition\": \"[AST_Node] the `if` condition\",\n                \"statement\": \"[AST_Node] statement to perform on each element before returning it\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.init._walk(visitor);\n                    node.object._walk(visitor);\n                    node.statement._walk(visitor);\n                    if (node.condition) node.condition._walk(visitor);\n                });\n            }\n        }, AST_ForIn);\n        AST_SetComprehension = DEFNODE(\"SetComprehension\", null, {\n            \"$documentation\": \"A set comprehension\"\n        }, AST_ListComprehension);\n        AST_DictComprehension = DEFNODE(\"DictComprehension\", \"value_statement is_pydict\", {\n            \"$documentation\": \"A set comprehension\",\n            \"$propdoc\": {\n                \"value_statement\": \"[AST_Node] statement to perform on each value before returning it\",\n                \"is_pydict\": \"[bool] True if this comprehension is for a python dict\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.init._walk(visitor);\n                    node.object._walk(visitor);\n                    node.statement._walk(visitor);\n                    node.value_statement._walk(visitor);\n                    if (node.condition) node.condition._walk(visitor);\n                });\n            }\n        }, AST_ListComprehension);\n        AST_GeneratorComprehension = DEFNODE(\"GeneratorComprehension\", null, {\n            \"$documentation\": \"A generator comprehension\"\n        }, AST_ListComprehension);\n        AST_With = DEFNODE(\"With\", \"clauses\", {\n            \"$documentation\": \"A `with` statement\",\n            \"$propdoc\": {\n                \"clauses\": \"[AST_WithClause*] the `with` clauses (comma separated)\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.clauses.forEach(function(exp) {\n                        exp._walk(visitor);\n                    });\n                    node.body._walk(visitor);\n                });\n            }\n        }, AST_StatementWithBody);\n        AST_WithClause = DEFNODE(\"WithClause\", \"expression alias\", {\n            \"$documentation\": \"A clause in a with statement\",\n            \"$propdoc\": {\n                \"expression\": \"[AST_Node] the expression\",\n                \"alias\": \"[AST_SymbolAlias?] optional alias for this expression\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.expression._walk(visitor);\n                    if (node.alias) {\n                        node.alias._walk(visitor);\n                    }\n                });\n            }\n        }, AST_Node);\n        AST_Scope = DEFNODE(\"Scope\", \"directives variables localvars functions uses_with uses_eval parent_scope enclosed cname\", {\n            \"$documentation\": \"Base class for all statements introducing a lexical scope\",\n            \"$propdoc\": {\n                \"directives\": \"[string*/S] an array of directives declared in this scope\",\n                \"variables\": \"[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope\",\n                \"localvars\": \"[SymbolDef*] list of variables local to this scope\",\n                \"functions\": \"[Object/S] like `variables`, but only lists function declarations\",\n                \"uses_with\": \"[boolean/S] tells whether this scope uses the `with` statement\",\n                \"uses_eval\": \"[boolean/S] tells whether this scope contains a direct call to the global `eval`\",\n                \"parent_scope\": \"[AST_Scope?/S] link to the parent scope\",\n                \"enclosed\": \"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes\",\n                \"cname\": \"[integer/S] current index for mangling variables (used internally by the mangler)\"\n            }\n        }, AST_Block);\n        AST_Toplevel = DEFNODE(\"Toplevel\", \"globals baselib imports imported_module_ids shebang import_order module_id exports submodules classes filename srchash\", {\n            \"$documentation\": \"The toplevel scope\",\n            \"$propdoc\": {\n                \"globals\": \"[Object/S] a map of name -> SymbolDef for all undeclared names\",\n                \"baselib\": \"[Object/s] a collection of used parts of baselib\",\n                \"imports\": \"[Object/S] a map of module_id->AST_Toplevel for all imported modules (this represents all imported modules across all source files)\",\n                \"imported_module_ids\": \"[string*] a list of module ids that were imported by this module, specifically\",\n                \"nonlocalvars\": \"[String*] a list of all non-local variable names (names that come from the global scope)\",\n                \"shebang\": \"[string] If #! line is present, it will be stored here\",\n                \"import_order\": \"[number] The global order in which this scope was imported\",\n                \"module_id\": \"[string] The id of this module\",\n                \"exports\": \"[SymbolDef*] list of names exported from this module\",\n                \"submodules\": \"[string*] list of names exported from this module\",\n                \"classes\": \"[Object/S] a map of class names to AST_Class for classes defined in this module\",\n                \"filename\": \"[string] The absolute path to the file from which this module was read\",\n                \"srchash\": \"[string] SHA1 hash of source code, used for caching\"\n            }\n        }, AST_Scope);\n        AST_Import = DEFNODE(\"Import\", \"module key alias argnames body\", {\n            \"$documentation\": \"Container for a single import\",\n            \"$propdoc\": {\n                \"module\": \"[AST_SymbolVar] name of the module we're importing\",\n                \"key\": \"[string] The key by which this module is stored in the global modules mapping\",\n                \"alias\": \"[AST_SymbolAlias] The name this module is imported as, can be None. For import x as y statements.\",\n                \"argnames\": \"[AST_ImportedVar*] names of objects to be imported\",\n                \"body\": \"[AST_TopLevel] parsed contents of the imported file\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    if (node.alias) {\n                        node.alias._walk(visitor);\n                    }\n                    if (node.argnames) {\n                        node.argnames.forEach(function(arg) {\n                            arg._walk(visitor);\n                        });\n                    }\n                });\n            }\n        }, AST_Statement);\n        AST_Imports = DEFNODE(\"Imports\", \"imports\", {\n            \"$documentation\": \"Container for a single import\",\n            \"$propdoc\": {\n                \"imports\": \"[AST_Import+] array of imports\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.imports.forEach(function(imp) {\n                        imp._walk(visitor);\n                    });\n                });\n            }\n        }, AST_Statement);\n        AST_Decorator = DEFNODE(\"Decorator\", \"expression\", {\n            \"$documentation\": \"Class for function decorators\",\n            \"$propdoc\": {\n                \"expression\": \"[AST_Node] the decorator expression\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    if (node.expression) {\n                        node.expression.walk(visitor);\n                    }\n                });\n            }\n        });\n        AST_Lambda = DEFNODE(\"Lambda\", \"name argnames uses_arguments decorators is_generator\", {\n            \"$documentation\": \"Base class for functions\",\n            \"$propdoc\": {\n                \"name\": \"[AST_SymbolDeclaration?] the name of this function\",\n                \"argnames\": \"[AST_SymbolFunarg*] array of function arguments\",\n                \"uses_arguments\": \"[boolean/S] tells whether this function accesses the arguments array\",\n                \"decorators\": \"[AST_Decorator*] function decorators, if any\",\n                \"is_generator\": \"[bool*] True iff this function is a generator\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    var d;\n                    if (node.decorators) {\n                        var _$rapyd$_Iter17 = _$rapyd$_Iterable(node.decorators);\n                        for (var _$rapyd$_Index17 = 0; _$rapyd$_Index17 < _$rapyd$_Iter17.length; _$rapyd$_Index17++) {\n                            d = _$rapyd$_Iter17[_$rapyd$_Index17];\n                            d.walk(visitor);\n                        }\n                    }\n                    if (node.name) {\n                        node.name._walk(visitor);\n                    }\n                    node.argnames.forEach(function(arg) {\n                        arg._walk(visitor);\n                    });\n                    if (node.argnames.starargs) {\n                        node.argnames.starargs._walk(visitor);\n                    }\n                    if (node.argnames.kwargs) {\n                        node.argnames.kwargs._walk(visitor);\n                    }\n                    walk_body(node, visitor);\n                });\n            }\n        }, AST_Scope);\n        AST_Accessor = DEFNODE(\"Accessor\", null, {\n            \"$documentation\": \"A setter/getter function\"\n        }, AST_Lambda);\n        AST_Function = DEFNODE(\"Function\", null, {\n            \"$documentation\": \"A function expression\"\n        }, AST_Lambda);\n        AST_Class = DEFNODE(\"Class\", \"init name parent static external bound decorators module_id statements dynamic_properties\", {\n            \"$documentation\": \"A class declaration\",\n            \"$propdoc\": {\n                \"name\": \"[AST_SymbolDeclaration?] the name of this class\",\n                \"init\": \"[AST_Function] constructor for the class\",\n                \"parent\": \"[AST_Symbol?] parent class this class inherits from\",\n                \"static\": \"[string*] list of static methods\",\n                \"external\": \"[boolean] true if class is declared elsewhere, but will be within current scope at runtime\",\n                \"bound\": \"[string*] list of methods that need to be bound to behave correctly (function pointers)\",\n                \"decorators\": \"[AST_Decorator*] function decorators, if any\",\n                \"module_id\": \"[string] The id of the module this class is defined in\",\n                \"statements\": \"[AST_Node*] list of statements in the class scope (excluding method definitions)\",\n                \"dynamic_properties\": \"[dict] map of dynamic property names to property descriptors of the form {getter:AST_Method, setter:AST_Method\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    var d;\n                    if (node.decorators) {\n                        var _$rapyd$_Iter18 = _$rapyd$_Iterable(node.decorators);\n                        for (var _$rapyd$_Index18 = 0; _$rapyd$_Index18 < _$rapyd$_Iter18.length; _$rapyd$_Index18++) {\n                            d = _$rapyd$_Iter18[_$rapyd$_Index18];\n                            d.walk(visitor);\n                        }\n                    }\n                    node.name._walk(visitor);\n                    walk_body(node, visitor);\n                    if (node.parent) node.parent._walk(visitor);\n                });\n            }\n        }, AST_Scope);\n        AST_Method = DEFNODE(\"Method\", \"static is_getter is_setter\", {\n            \"$documentation\": \"A class method definition\",\n            \"$propdoc\": {\n                \"static\": \"[boolean] true if method is static\",\n                \"is_getter\": \"[boolean] true if method is a property getter\",\n                \"is_setter\": \"[boolean] true if method is a property setter\"\n            }\n        }, AST_Lambda);\n        AST_Jump = DEFNODE(\"Jump\", null, {\n            \"$documentation\": \"Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)\"\n        }, AST_Statement);\n        AST_Exit = DEFNODE(\"Exit\", \"value\", {\n            \"$documentation\": \"Base class for “exits” (`return` and `throw`)\",\n            \"$propdoc\": {\n                \"value\": \"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    if (node.value) {\n                        node.value._walk(visitor);\n                    }\n                });\n            }\n        }, AST_Jump);\n        AST_Return = DEFNODE(\"Return\", null, {\n            \"$documentation\": \"A `return` statement\"\n        }, AST_Exit);\n        AST_Yield = DEFNODE(\"Yield\", \"is_yield_from\", {\n            \"$documentation\": \"A `yield` statement\",\n            \"$propdoc\": {\n                \"is_yield_from\": \"[bool] True iff this is a yield from, False otherwise\"\n            }\n        }, AST_Return);\n        AST_Throw = DEFNODE(\"Throw\", null, {\n            \"$documentation\": \"A `throw` statement\"\n        }, AST_Exit);\n        AST_LoopControl = DEFNODE(\"LoopControl\", null, {\n            \"$documentation\": \"Base class for loop control statements (`break` and `continue`)\"\n        }, AST_Jump);\n        AST_Break = DEFNODE(\"Break\", null, {\n            \"$documentation\": \"A `break` statement\"\n        }, AST_LoopControl);\n        AST_Continue = DEFNODE(\"Continue\", null, {\n            \"$documentation\": \"A `continue` statement\"\n        }, AST_LoopControl);\n        AST_If = DEFNODE(\"If\", \"condition alternative\", {\n            \"$documentation\": \"A `if` statement\",\n            \"$propdoc\": {\n                \"condition\": \"[AST_Node] the `if` condition\",\n                \"alternative\": \"[AST_Statement?] the `else` part, or null if not present\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.condition._walk(visitor);\n                    node.body._walk(visitor);\n                    if (node.alternative) {\n                        node.alternative._walk(visitor);\n                    }\n                });\n            }\n        }, AST_StatementWithBody);\n        AST_Try = DEFNODE(\"Try\", \"bcatch bfinally\", {\n            \"$documentation\": \"A `try` statement\",\n            \"$propdoc\": {\n                \"bcatch\": \"[AST_Catch?] the catch block, or null if not present\",\n                \"bfinally\": \"[AST_Finally?] the finally block, or null if not present\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    walk_body(node, visitor);\n                    if (node.bcatch) {\n                        node.bcatch._walk(visitor);\n                    }\n                    if (node.bfinally) {\n                        node.bfinally._walk(visitor);\n                    }\n                });\n            }\n        }, AST_Block);\n        AST_Catch = DEFNODE(\"Catch\", null, {\n            \"$documentation\": \"A `catch` node; only makes sense as part of a `try` statement\",\n            \"$propdoc\": {}\n        }, AST_Block);\n        AST_Except = DEFNODE(\"Except\", \"argname errors\", {\n            \"$documentation\": \"An `except` node for RapydScript, which resides inside the catch block\",\n            \"$propdoc\": {\n                \"argname\": \"[AST_SymbolCatch] symbol for the exception\",\n                \"errors\": \"[AST_SymbolVar*] error classes to catch in this block\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(this, function() {\n                    var e;\n                    if (node.argname) {\n                        node.argname.walk(visitor);\n                    }\n                    if (node.errors) {\n                        var _$rapyd$_Iter19 = _$rapyd$_Iterable(node.errors);\n                        for (var _$rapyd$_Index19 = 0; _$rapyd$_Index19 < _$rapyd$_Iter19.length; _$rapyd$_Index19++) {\n                            e = _$rapyd$_Iter19[_$rapyd$_Index19];\n                            e.walk(visitor);\n                        }\n                    }\n                    walk_body(node, visitor);\n                });\n            }\n        }, AST_Block);\n        AST_Finally = DEFNODE(\"Finally\", null, {\n            \"$documentation\": \"A `finally` node; only makes sense as part of a `try` statement\"\n        }, AST_Block);\n        AST_Definitions = DEFNODE(\"Definitions\", \"definitions\", {\n            \"$documentation\": \"Base class for `var` or `const` nodes (variable declarations/initializations)\",\n            \"$propdoc\": {\n                \"definitions\": \"[AST_VarDef*] array of variable definitions\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.definitions.forEach(function(def_) {\n                        def_._walk(visitor);\n                    });\n                });\n            }\n        }, AST_Statement);\n        AST_Var = DEFNODE(\"Var\", null, {\n            \"$documentation\": \"A `var` statement\"\n        }, AST_Definitions);\n        AST_Const = DEFNODE(\"Const\", null, {\n            \"$documentation\": \"A `const` statement\"\n        }, AST_Definitions);\n        AST_VarDef = DEFNODE(\"VarDef\", \"name value\", {\n            \"$documentation\": \"A variable declaration; only appears in a AST_Definitions node\",\n            \"$propdoc\": {\n                \"name\": \"[AST_SymbolVar|AST_SymbolConst|AST_SymbolNonlocal] name of the variable\",\n                \"value\": \"[AST_Node?] initializer, or null if there's no initializer\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.name._walk(visitor);\n                    if (node.value) {\n                        node.value._walk(visitor);\n                    }\n                });\n            }\n        });\n        AST_BaseCall = DEFNODE(\"BaseCall\", \"args\", {\n            \"$documentation\": \"A base class for function calls\",\n            \"$propdoc\": {\n                \"args\": \"[AST_Node*] array of arguments\"\n            }\n        });\n        AST_Call = DEFNODE(\"Call\", \"expression\", {\n            \"$documentation\": \"A function call expression\",\n            \"$propdoc\": {\n                \"expression\": \"[AST_Node] expression to invoke as function\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.expression._walk(visitor);\n                    node.args.forEach(function(arg) {\n                        arg._walk(visitor);\n                    });\n                    if (node.args.kwargs) node.args.kwargs.forEach(function(arg) {\n                        arg[0]._walk(visitor);\n                        arg[1]._walk(visitor);\n                    });\n                    if (node.args.kwarg_items) node.args.kwarg_items.forEach(function(arg) {\n                        arg._walk(visitor);\n                    });\n                });\n            }\n        }, AST_BaseCall);\n        AST_ClassCall = DEFNODE(\"ClassCall\", \"class method static\", {\n            \"$documentation\": \"A function call expression\",\n            \"$propdoc\": {\n                \"class\": \"[string] name of the class method belongs to\",\n                \"method\": \"[string] class method being called\",\n                \"static\": \"[boolean] defines whether the method is static\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    if (node.expression) node.expression._walk(visitor);\n                    node.args.forEach(function(arg) {\n                        arg._walk(visitor);\n                    });\n                    node.args.kwargs.forEach(function(arg) {\n                        arg[0]._walk(visitor);\n                        arg[1]._walk(visitor);\n                    });\n                    node.args.kwarg_items.forEach(function(arg) {\n                        arg._walk(visitor);\n                    });\n                });\n            }\n        }, AST_BaseCall);\n        AST_New = DEFNODE(\"New\", null, {\n            \"$documentation\": \"An object instantiation. Derives from a function call since it has exactly the same properties\"\n        }, AST_Call);\n        AST_Seq = DEFNODE(\"Seq\", \"car cdr\", {\n            \"$documentation\": \"A sequence expression (two comma-separated expressions)\",\n            \"$propdoc\": {\n                \"car\": \"[AST_Node] first element in sequence\",\n                \"cdr\": \"[AST_Node] second element in sequence\"\n            },\n            \"$cons\": function(x, y) {\n                var seq;\n                seq = new AST_Seq(x);\n                seq.car = x;\n                seq.cdr = y;\n                return seq;\n            },\n            \"$from_array\": function(array) {\n                var list, i, p;\n                if (array.length === 0) {\n                    return null;\n                }\n                if (array.length === 1) {\n                    return array[0].clone();\n                }\n                list = null;\n                for (var _$rapyd$_Index20 = array.length - 1; _$rapyd$_Index20 > -1; _$rapyd$_Index20-=1) {\n                    i = _$rapyd$_Index20;\n                    list = AST_Seq.cons(array[i], list);\n                }\n                p = list;\n                while (p) {\n                    if (p.cdr && !p.cdr.cdr) {\n                        p.cdr = p.cdr.car;\n                        break;\n                    }\n                    p = p.cdr;\n                }\n                return list;\n            },\n            \"to_array\": function() {\n                var p, a;\n                p = this;\n                a = _$rapyd$_list_decorate([]);\n                while (p) {\n                    a.push(p.car);\n                    if (p.cdr && !(p.cdr instanceof AST_Seq)) {\n                        a.push(p.cdr);\n                        break;\n                    }\n                    p = p.cdr;\n                }\n                return a;\n            },\n            \"add\": function(node) {\n                var p, cell;\n                p = this;\n                while (p) {\n                    if (!(p.cdr instanceof AST_Seq)) {\n                        cell = AST_Seq.cons(p.cdr, node);\n                        return p.cdr = cell;\n                    }\n                    p = p.cdr;\n                }\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.car._walk(visitor);\n                    if (node.cdr) {\n                        node.cdr._walk(visitor);\n                    }\n                });\n            }\n        });\n        AST_PropAccess = DEFNODE(\"PropAccess\", \"expression property\", {\n            \"$documentation\": \"Base class for property access expressions, i.e. `a.foo` or `a[\\\"foo\\\"]`\",\n            \"$propdoc\": {\n                \"expression\": \"[AST_Node] the “container” expression\",\n                \"property\": \"[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node\"\n            }\n        });\n        AST_Dot = DEFNODE(\"Dot\", null, {\n            \"$documentation\": \"A dotted property access expression\",\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.expression._walk(visitor);\n                });\n            }\n        }, AST_PropAccess);\n        AST_Sub = DEFNODE(\"Sub\", null, {\n            \"$documentation\": \"Index-style property access, i.e. `a[\\\"foo\\\"]`\",\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.expression._walk(visitor);\n                    node.property._walk(visitor);\n                });\n            }\n        }, AST_PropAccess);\n        AST_ItemAccess = DEFNODE(\"ItemAccess\", \"assignment\", {\n            \"$documentation\": \"Python index-style property access, i.e. `a.__getitem__(\\\"foo\\\")`\",\n            \"$propdoc\": {\n                \"assignment\": \"[AST_Node or None] Not None if this is an assignment (a[x] = y) rather than a simple access\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.expression._walk(visitor);\n                    node.property._walk(visitor);\n                    if (node.assignment) {\n                        node.assignment._walk(visitor);\n                    }\n                });\n            }\n        }, AST_PropAccess);\n        AST_Splice = DEFNODE(\"Slice\", \"property2 assignment\", {\n            \"$documentation\": \"Index-style property access, i.e. `a[3:5]`\",\n            \"$propdoc\": {\n                \"property2\": \"[AST_Node] the 2nd property to access - typically ending index for the array.\",\n                \"assignment\": \"[AST_Node] The data being spliced in.\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.expression._walk(visitor);\n                    node.property._walk(visitor);\n                    node.property2._walk(visitor);\n                });\n            }\n        }, AST_PropAccess);\n        AST_Unary = DEFNODE(\"Unary\", \"operator expression\", {\n            \"$documentation\": \"Base class for unary expressions\",\n            \"$propdoc\": {\n                \"operator\": \"[string] the operator\",\n                \"expression\": \"[AST_Node] expression that this unary operator applies to\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.expression._walk(visitor);\n                });\n            }\n        });\n        AST_UnaryPrefix = DEFNODE(\"UnaryPrefix\", null, {\n            \"$documentation\": \"Unary prefix expression, i.e. `typeof i` or `++i`\"\n        }, AST_Unary);\n        AST_UnaryPostfix = DEFNODE(\"UnaryPostfix\", null, {\n            \"$documentation\": \"Unary postfix expression, i.e. `i++`\"\n        }, AST_Unary);\n        AST_Binary = DEFNODE(\"Binary\", \"left operator right\", {\n            \"$documentation\": \"Binary expression, i.e. `a + b`\",\n            \"$propdoc\": {\n                \"left\": \"[AST_Node] left-hand side expression\",\n                \"operator\": \"[string] the operator\",\n                \"right\": \"[AST_Node] right-hand side expression\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.left._walk(visitor);\n                    node.right._walk(visitor);\n                });\n            }\n        });\n        AST_Conditional = DEFNODE(\"Conditional\", \"condition consequent alternative\", {\n            \"$documentation\": \"Conditional expression using the ternary operator, i.e. `a ? b : c`\",\n            \"$propdoc\": {\n                \"condition\": \"[AST_Node]\",\n                \"consequent\": \"[AST_Node]\",\n                \"alternative\": \"[AST_Node]\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.condition._walk(visitor);\n                    node.consequent._walk(visitor);\n                    node.alternative._walk(visitor);\n                });\n            }\n        });\n        AST_Assign = DEFNODE(\"Assign\", null, {\n            \"$documentation\": \"An assignment expression — `a = b + 5`\",\n            \"is_chained\": function() {\n                return this.right instanceof AST_Assign || this.right instanceof AST_Seq && (this.right.car instanceof AST_Assign || this.right.cdr instanceof AST_Assign);\n            },\n            \"traverse_chain\": function() {\n                var right, left_hand_sides, next, assign;\n                right = this.right;\n                while (true) {\n                    if (right instanceof AST_Assign) {\n                        right = right.right;\n                        continue;\n                    }\n                    if (right instanceof AST_Seq) {\n                        if (right.car instanceof AST_Assign) {\n                            right = new AST_Seq({\n                                \"car\": right.car.right,\n                                \"cdr\": right.cdr\n                            });\n                            continue;\n                        }\n                        if (right.cdr instanceof AST_Assign) {\n                            right = right.cdr.right;\n                            continue;\n                        }\n                    }\n                    break;\n                }\n                left_hand_sides = [this.left];\n                next = this.right;\n                while (true) {\n                    if (next instanceof AST_Assign) {\n                        left_hand_sides.push(next.left);\n                        next = next.right;\n                        continue;\n                    }\n                    if (next instanceof AST_Seq) {\n                        if (next.cdr instanceof AST_Assign) {\n                            assign = next.cdr;\n                            left_hand_sides.push(new AST_Seq({\n                                \"car\": next.car,\n                                \"cdr\": assign.left\n                            }));\n                            next = assign.right;\n                            continue;\n                        }\n                    }\n                    break;\n                }\n                return [left_hand_sides, right];\n            }\n        }, AST_Binary);\n        AST_Array = DEFNODE(\"Array\", \"elements\", {\n            \"$documentation\": \"An array literal\",\n            \"$propdoc\": {\n                \"elements\": \"[AST_Node*] array of elements\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.elements.forEach(function(el) {\n                        el._walk(visitor);\n                    });\n                });\n            },\n            \"flatten\": function() {\n                function flatten(arr) {\n                    var ans, value;\n                    ans = _$rapyd$_list_decorate([]);\n                    var _$rapyd$_Iter21 = _$rapyd$_Iterable(arr);\n                    for (var _$rapyd$_Index21 = 0; _$rapyd$_Index21 < _$rapyd$_Iter21.length; _$rapyd$_Index21++) {\n                        value = _$rapyd$_Iter21[_$rapyd$_Index21];\n                        if (value instanceof AST_Seq) {\n                            value = value.to_array();\n                        } else if (value instanceof AST_Array) {\n                            value = value.elements;\n                        }\n                        if (Array.isArray(value)) {\n                            ans = ans.concat(flatten(value));\n                        } else {\n                            ans.push(value);\n                        }\n                    }\n                    return ans;\n                }\n                return flatten(this.elements);\n            }\n        });\n        AST_Object = DEFNODE(\"Object\", \"properties is_pydict\", {\n            \"$documentation\": \"An object literal\",\n            \"$propdoc\": {\n                \"properties\": \"[AST_ObjectProperty*] array of properties\",\n                \"is_pydict\": \"[bool] True if this object is a python dict literal\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.properties.forEach(function(prop) {\n                        prop._walk(visitor);\n                    });\n                });\n            }\n        });\n        AST_ExpressiveObject = DEFNODE(\"ExpressiveObject\", null, {\n            \"$documentation\": \"An object literal with expressions for some keys\"\n        }, AST_Object);\n        AST_ObjectProperty = DEFNODE(\"ObjectProperty\", \"key value quoted\", {\n            \"$documentation\": \"Base class for literal object properties\",\n            \"$propdoc\": {\n                \"key\": \"[AST_Node] the property expression\",\n                \"value\": \"[AST_Node] property value.  For setters and getters this is an AST_Function.\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.key._walk(visitor);\n                    node.value._walk(visitor);\n                });\n            }\n        });\n        AST_ObjectKeyVal = DEFNODE(\"ObjectKeyVal\", null, {\n            \"$documentation\": \"A key: value object property\"\n        }, AST_ObjectProperty);\n        AST_Set = DEFNODE(\"Set\", \"items\", {\n            \"$documentation\": \"A set literal\",\n            \"$propdoc\": {\n                \"items\": \"[AST_SetItem*] array of items\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.items.forEach(function(prop) {\n                        prop._walk(visitor);\n                    });\n                });\n            }\n        });\n        AST_SetItem = DEFNODE(\"SetItem\", \"value\", {\n            \"$documentation\": \"An item in a set literal\",\n            \"$propdoc\": {\n                \"value\": \"[AST_Node] The value of this item\"\n            },\n            \"_walk\": function(visitor) {\n                var node;\n                node = this;\n                return visitor._visit(node, function() {\n                    node.value._walk(visitor);\n                });\n            }\n        });\n        AST_Symbol = DEFNODE(\"Symbol\", \"scope name thedef\", {\n            \"$propdoc\": {\n                \"name\": \"[string] name of this symbol\",\n                \"scope\": \"[AST_Scope/S] the current scope (not necessarily the definition scope)\",\n                \"thedef\": \"[SymbolDef/S] the definition of this symbol\"\n            },\n            \"$documentation\": \"Base class for all symbols\"\n        });\n        AST_SymbolAlias = DEFNODE(\"SymbolAlias\", null, {\n            \"$documentation\": \"An alias used in an import statement or with statement\"\n        }, AST_Symbol);\n        AST_SymbolAccessor = DEFNODE(\"SymbolAccessor\", null, {\n            \"$documentation\": \"The name of a property accessor (setter/getter function)\"\n        }, AST_Symbol);\n        AST_SymbolDeclaration = DEFNODE(\"SymbolDeclaration\", \"init\", {\n            \"$documentation\": \"A declaration symbol (symbol in var/const, function name or argument, symbol in catch)\",\n            \"$propdoc\": {\n                \"init\": \"[AST_Node*/S] array of initializers for this declaration.\"\n            }\n        }, AST_Symbol);\n        AST_SymbolVar = DEFNODE(\"SymbolVar\", null, {\n            \"$documentation\": \"Symbol defining a variable\"\n        }, AST_SymbolDeclaration);\n        AST_ImportedVar = DEFNODE(\"ImportedVar\", \"alias\", {\n            \"$documentation\": \"Symbol defining an imported symbol\",\n            \"$propdoc\": {\n                \"alias\": \"AST_SymbolAlias the alias for this imported symbol\"\n            }\n        }, AST_SymbolVar);\n        AST_SymbolConst = DEFNODE(\"SymbolConst\", null, {\n            \"$documentation\": \"A constant declaration\"\n        }, AST_SymbolDeclaration);\n        AST_SymbolNonlocal = DEFNODE(\"SymbolNonlocal\", null, {\n            \"$documentation\": \"A nonlocal declaration\"\n        }, AST_SymbolDeclaration);\n        AST_SymbolFunarg = DEFNODE(\"SymbolFunarg\", null, {\n            \"$documentation\": \"Symbol naming a function argument\"\n        }, AST_SymbolVar);\n        AST_SymbolDefun = DEFNODE(\"SymbolDefun\", null, {\n            \"$documentation\": \"Symbol defining a function\"\n        }, AST_SymbolDeclaration);\n        AST_SymbolLambda = DEFNODE(\"SymbolLambda\", null, {\n            \"$documentation\": \"Symbol naming a function expression\"\n        }, AST_SymbolDeclaration);\n        AST_SymbolCatch = DEFNODE(\"SymbolCatch\", null, {\n            \"$documentation\": \"Symbol naming the exception in catch\"\n        }, AST_SymbolDeclaration);\n        AST_SymbolRef = DEFNODE(\"SymbolRef\", \"parens\", {\n            \"$documentation\": \"Reference to some symbol (not definition/declaration)\",\n            \"$propdoc\": {\n                \"parens\": \"[boolean/S] if true, this variable is wrapped in parentheses\"\n            }\n        }, AST_Symbol);\n        AST_This = DEFNODE(\"This\", null, {\n            \"$documentation\": \"The `this` symbol\"\n        }, AST_Symbol);\n        AST_Constant = DEFNODE(\"Constant\", null, {\n            \"$documentation\": \"Base class for all constants\",\n            \"getValue\": function() {\n                return this.value;\n            }\n        });\n        AST_String = DEFNODE(\"String\", \"value\", {\n            \"$documentation\": \"A string literal\",\n            \"$propdoc\": {\n                \"value\": \"[string] the contents of this string\"\n            }\n        }, AST_Constant);\n        AST_Verbatim = DEFNODE(\"Verbatim\", \"value\", {\n            \"$documentation\": \"Raw JavaScript code\",\n            \"$propdoc\": {\n                \"value\": \"[string] A string of raw JS code\"\n            }\n        }, AST_Constant);\n        AST_Number = DEFNODE(\"Number\", \"value\", {\n            \"$documentation\": \"A number literal\",\n            \"$propdoc\": {\n                \"value\": \"[number] the numeric value\"\n            }\n        }, AST_Constant);\n        AST_RegExp = DEFNODE(\"RegExp\", \"value\", {\n            \"$documentation\": \"A regexp literal\",\n            \"$propdoc\": {\n                \"value\": \"[RegExp] the actual regexp\"\n            }\n        }, AST_Constant);\n        AST_Atom = DEFNODE(\"Atom\", null, {\n            \"$documentation\": \"Base class for atoms\"\n        }, AST_Constant);\n        AST_Null = DEFNODE(\"Null\", null, {\n            \"$documentation\": \"The `null` atom\",\n            \"value\": null\n        }, AST_Atom);\n        AST_NaN = DEFNODE(\"NaN\", null, {\n            \"$documentation\": \"The impossible value\",\n            \"value\": 0 / 0\n        }, AST_Atom);\n        AST_Undefined = DEFNODE(\"Undefined\", null, {\n            \"$documentation\": \"The `undefined` value\",\n            \"value\": function() {\n            }.call(this)\n        }, AST_Atom);\n        AST_Hole = DEFNODE(\"Hole\", null, {\n            \"$documentation\": \"A hole in an array\",\n            \"value\": function() {\n            }.call(this)\n        }, AST_Atom);\n        AST_Infinity = DEFNODE(\"Infinity\", null, {\n            \"$documentation\": \"The `Infinity` value\",\n            \"value\": 1 / 0\n        }, AST_Atom);\n        AST_Boolean = DEFNODE(\"Boolean\", null, {\n            \"$documentation\": \"Base class for booleans\"\n        }, AST_Atom);\n        AST_False = DEFNODE(\"False\", null, {\n            \"$documentation\": \"The `false` atom\",\n            \"value\": false\n        }, AST_Boolean);\n        AST_True = DEFNODE(\"True\", null, {\n            \"$documentation\": \"The `true` atom\",\n            \"value\": true\n        }, AST_Boolean);\n        function TreeWalker(callback) {\n            this.visit = callback;\n            this.stack = _$rapyd$_list_decorate([]);\n        }\n        TreeWalker.prototype = {\n            \"_visit\": function(node, descend) {\n                var ret;\n                this.stack.push(node);\n                ret = this.visit(node, (descend) ? function() {\n                    descend.call(node);\n                } : noop);\n                if (!ret && descend) {\n                    descend.call(node);\n                }\n                this.stack.pop();\n                return ret;\n            },\n            \"parent\": function(n) {\n                return this.stack[this.stack.length - 2 - (n || 0)];\n            },\n            \"push\": function(node) {\n                this.stack.push(node);\n            },\n            \"pop\": function() {\n                return this.stack.pop();\n            },\n            \"self\": function() {\n                return this.stack[this.stack.length - 1];\n            },\n            \"find_parent\": function(type) {\n                var stack, x, i;\n                stack = this.stack;\n                for (var _$rapyd$_Index22 = stack.length - 1; _$rapyd$_Index22 > -1; _$rapyd$_Index22-=1) {\n                    i = _$rapyd$_Index22;\n                    x = stack[i];\n                    if (x instanceof type) {\n                        return x;\n                    }\n                }\n            },\n            \"in_boolean_context\": function() {\n                var stack, i, self, p;\n                stack = this.stack;\n                i = stack.length;\n                self = stack[i -= 1];\n                while (i > 0) {\n                    p = stack[i -= 1];\n                    if (p instanceof AST_If && p.condition === self || p instanceof AST_Conditional && p.condition === self || p instanceof AST_DWLoop && p.condition === self || p instanceof AST_UnaryPrefix && p.operator === \"!\" && p.expression === self) {\n                        return true;\n                    }\n                    if (!(p instanceof AST_Binary && (p.operator === \"&&\" || p.operator === \"||\"))) {\n                        return false;\n                    }\n                    self = p;\n                }\n            }\n        };\n        _$rapyd$_modules[\"ast\"][\"AST_Token\"] = AST_Token;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Node\"] = AST_Node;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Statement\"] = AST_Statement;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Debugger\"] = AST_Debugger;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Directive\"] = AST_Directive;\n\n        _$rapyd$_modules[\"ast\"][\"AST_SimpleStatement\"] = AST_SimpleStatement;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Block\"] = AST_Block;\n\n        _$rapyd$_modules[\"ast\"][\"AST_BlockStatement\"] = AST_BlockStatement;\n\n        _$rapyd$_modules[\"ast\"][\"AST_EmptyStatement\"] = AST_EmptyStatement;\n\n        _$rapyd$_modules[\"ast\"][\"AST_StatementWithBody\"] = AST_StatementWithBody;\n\n        _$rapyd$_modules[\"ast\"][\"AST_DWLoop\"] = AST_DWLoop;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Do\"] = AST_Do;\n\n        _$rapyd$_modules[\"ast\"][\"AST_While\"] = AST_While;\n\n        _$rapyd$_modules[\"ast\"][\"AST_ForIn\"] = AST_ForIn;\n\n        _$rapyd$_modules[\"ast\"][\"AST_ForJS\"] = AST_ForJS;\n\n        _$rapyd$_modules[\"ast\"][\"AST_ListComprehension\"] = AST_ListComprehension;\n\n        _$rapyd$_modules[\"ast\"][\"AST_SetComprehension\"] = AST_SetComprehension;\n\n        _$rapyd$_modules[\"ast\"][\"AST_DictComprehension\"] = AST_DictComprehension;\n\n        _$rapyd$_modules[\"ast\"][\"AST_GeneratorComprehension\"] = AST_GeneratorComprehension;\n\n        _$rapyd$_modules[\"ast\"][\"AST_With\"] = AST_With;\n\n        _$rapyd$_modules[\"ast\"][\"AST_WithClause\"] = AST_WithClause;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Scope\"] = AST_Scope;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Toplevel\"] = AST_Toplevel;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Import\"] = AST_Import;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Imports\"] = AST_Imports;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Decorator\"] = AST_Decorator;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Lambda\"] = AST_Lambda;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Accessor\"] = AST_Accessor;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Function\"] = AST_Function;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Class\"] = AST_Class;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Method\"] = AST_Method;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Jump\"] = AST_Jump;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Exit\"] = AST_Exit;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Return\"] = AST_Return;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Yield\"] = AST_Yield;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Throw\"] = AST_Throw;\n\n        _$rapyd$_modules[\"ast\"][\"AST_LoopControl\"] = AST_LoopControl;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Break\"] = AST_Break;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Continue\"] = AST_Continue;\n\n        _$rapyd$_modules[\"ast\"][\"AST_If\"] = AST_If;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Try\"] = AST_Try;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Catch\"] = AST_Catch;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Except\"] = AST_Except;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Finally\"] = AST_Finally;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Definitions\"] = AST_Definitions;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Var\"] = AST_Var;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Const\"] = AST_Const;\n\n        _$rapyd$_modules[\"ast\"][\"AST_VarDef\"] = AST_VarDef;\n\n        _$rapyd$_modules[\"ast\"][\"AST_BaseCall\"] = AST_BaseCall;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Call\"] = AST_Call;\n\n        _$rapyd$_modules[\"ast\"][\"AST_ClassCall\"] = AST_ClassCall;\n\n        _$rapyd$_modules[\"ast\"][\"AST_New\"] = AST_New;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Seq\"] = AST_Seq;\n\n        _$rapyd$_modules[\"ast\"][\"AST_PropAccess\"] = AST_PropAccess;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Dot\"] = AST_Dot;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Sub\"] = AST_Sub;\n\n        _$rapyd$_modules[\"ast\"][\"AST_ItemAccess\"] = AST_ItemAccess;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Splice\"] = AST_Splice;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Unary\"] = AST_Unary;\n\n        _$rapyd$_modules[\"ast\"][\"AST_UnaryPrefix\"] = AST_UnaryPrefix;\n\n        _$rapyd$_modules[\"ast\"][\"AST_UnaryPostfix\"] = AST_UnaryPostfix;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Binary\"] = AST_Binary;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Conditional\"] = AST_Conditional;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Assign\"] = AST_Assign;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Array\"] = AST_Array;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Object\"] = AST_Object;\n\n        _$rapyd$_modules[\"ast\"][\"AST_ExpressiveObject\"] = AST_ExpressiveObject;\n\n        _$rapyd$_modules[\"ast\"][\"AST_ObjectProperty\"] = AST_ObjectProperty;\n\n        _$rapyd$_modules[\"ast\"][\"AST_ObjectKeyVal\"] = AST_ObjectKeyVal;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Set\"] = AST_Set;\n\n        _$rapyd$_modules[\"ast\"][\"AST_SetItem\"] = AST_SetItem;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Symbol\"] = AST_Symbol;\n\n        _$rapyd$_modules[\"ast\"][\"AST_SymbolAlias\"] = AST_SymbolAlias;\n\n        _$rapyd$_modules[\"ast\"][\"AST_SymbolAccessor\"] = AST_SymbolAccessor;\n\n        _$rapyd$_modules[\"ast\"][\"AST_SymbolDeclaration\"] = AST_SymbolDeclaration;\n\n        _$rapyd$_modules[\"ast\"][\"AST_SymbolVar\"] = AST_SymbolVar;\n\n        _$rapyd$_modules[\"ast\"][\"AST_ImportedVar\"] = AST_ImportedVar;\n\n        _$rapyd$_modules[\"ast\"][\"AST_SymbolConst\"] = AST_SymbolConst;\n\n        _$rapyd$_modules[\"ast\"][\"AST_SymbolNonlocal\"] = AST_SymbolNonlocal;\n\n        _$rapyd$_modules[\"ast\"][\"AST_SymbolFunarg\"] = AST_SymbolFunarg;\n\n        _$rapyd$_modules[\"ast\"][\"AST_SymbolDefun\"] = AST_SymbolDefun;\n\n        _$rapyd$_modules[\"ast\"][\"AST_SymbolLambda\"] = AST_SymbolLambda;\n\n        _$rapyd$_modules[\"ast\"][\"AST_SymbolCatch\"] = AST_SymbolCatch;\n\n        _$rapyd$_modules[\"ast\"][\"AST_SymbolRef\"] = AST_SymbolRef;\n\n        _$rapyd$_modules[\"ast\"][\"AST_This\"] = AST_This;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Constant\"] = AST_Constant;\n\n        _$rapyd$_modules[\"ast\"][\"AST_String\"] = AST_String;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Verbatim\"] = AST_Verbatim;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Number\"] = AST_Number;\n\n        _$rapyd$_modules[\"ast\"][\"AST_RegExp\"] = AST_RegExp;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Atom\"] = AST_Atom;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Null\"] = AST_Null;\n\n        _$rapyd$_modules[\"ast\"][\"AST_NaN\"] = AST_NaN;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Undefined\"] = AST_Undefined;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Hole\"] = AST_Hole;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Infinity\"] = AST_Infinity;\n\n        _$rapyd$_modules[\"ast\"][\"AST_Boolean\"] = AST_Boolean;\n\n        _$rapyd$_modules[\"ast\"][\"AST_False\"] = AST_False;\n\n        _$rapyd$_modules[\"ast\"][\"AST_True\"] = AST_True;\n\n        _$rapyd$_modules[\"ast\"][\"DEFNODE\"] = DEFNODE;\n\n        _$rapyd$_modules[\"ast\"][\"walk_body\"] = walk_body;\n\n        _$rapyd$_modules[\"ast\"][\"TreeWalker\"] = TreeWalker;\n    })();\n\n    (function(){\n        var __name__ = \"tokenizer\";\n        var RE_HEX_NUMBER, RE_OCT_NUMBER, RE_DEC_NUMBER, UNARY_POSTFIX, OPERATOR_CHARS, INVALID_OPERATORS, ASCII_CONTROL_CHARS, HEX_PAT, NAME_PAT, OPERATORS, OP_MAP, WHITESPACE_CHARS, PUNC_BEFORE_EXPRESSION, PUNC_CHARS, REGEXP_MODIFIERS, KEYWORDS, KEYWORDS_ATOM, RESERVED_WORDS, KEYWORDS_BEFORE_EXPRESSION, ALL_KEYWORDS, IDENTIFIER_PAT, UNICODE, EX_EOF;\n        var ALIAS_MAP = _$rapyd$_modules[\"unicode_aliases\"].ALIAS_MAP;\n        \n        var make_predicate = _$rapyd$_modules[\"utils\"].make_predicate;\n        var characters = _$rapyd$_modules[\"utils\"].characters;\n        \n        var AST_Token = _$rapyd$_modules[\"ast\"].AST_Token;\n        \n        var SyntaxError = _$rapyd$_modules[\"errors\"].SyntaxError;\n        \n        RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;\n        RE_OCT_NUMBER = /^0[0-7]+$/;\n        RE_DEC_NUMBER = /^\\d*\\.?\\d*(?:e[+-]?\\d*(?:\\d\\.?|\\.?\\d)\\d*)?$/i;\n        UNARY_POSTFIX = make_predicate(_$rapyd$_list_decorate([ \"--\", \"++\" ]));\n        OPERATOR_CHARS = make_predicate(characters(\"+-*&%=<>!?|~^@\"));\n        INVALID_OPERATORS = (function(){\n            var s = _$rapyd$_set();\n            s.jsset.add(\"++\");\n            s.jsset.add(\"--\");\n            s.jsset.add(\"===\");\n            s.jsset.add(\"!==\");\n            return s;\n        })();\n        ASCII_CONTROL_CHARS = {\n            \"a\": 7,\n            \"b\": 8,\n            \"f\": 12,\n            \"n\": 10,\n            \"r\": 13,\n            \"t\": 9,\n            \"v\": 11\n        };\n        HEX_PAT = /[a-fA-F0-9]/;\n        NAME_PAT = /[a-zA-Z ]/;\n        OPERATORS = make_predicate(_$rapyd$_list_decorate([ \"in\", \"instanceof\", \"typeof\", \"new\", \"void\", \"del\", \"++\", \"--\", \"+\", \"-\", \"not\", \"~\", \"&\", \"|\", \"^\", \"**\", \"*\", \"//\", \"/\", \"%\", \">>\", \"<<\", \">>>\", \"<\", \">\", \"<=\", \">=\", \"==\", \"===\", \"is\", \"!=\", \"!==\", \"?\", \"=\", \"+=\", \"-=\", \"//=\", \"/=\", \"*=\", \"%=\", \">>=\", \"<<=\", \">>>=\", \"|=\", \"^=\", \"&=\", \"and\", \"or\", \"@\" ]));\n        OP_MAP = {\n            \"or\": \"||\",\n            \"and\": \"&&\",\n            \"not\": \"!\",\n            \"del\": \"delete\",\n            \"None\": \"null\",\n            \"is\": \"===\"\n        };\n        WHITESPACE_CHARS = make_predicate(characters(\"  \\n\\r\\t\\f\\u000b​᠎           \\u202f 　\"));\n        PUNC_BEFORE_EXPRESSION = make_predicate(characters(\"[{(,.;:\"));\n        PUNC_CHARS = make_predicate(characters(\"[]{}(),;:\"));\n        REGEXP_MODIFIERS = make_predicate(characters(\"gmsiy\"));\n        KEYWORDS = \"as break case class const continue debugger def del do elif else except finally for from if import in instanceof is new nonlocal pass raise return yield switch try typeof var void while with or and not delete default\";\n        KEYWORDS_ATOM = \"False None True\";\n        RESERVED_WORDS = \"abstract await boolean byte char delete default double enum export extends final float goto implements int interface long native package private protected public short static super synchronized this throws transient volatile\" + \" \" + KEYWORDS_ATOM + \" \" + KEYWORDS;\n        KEYWORDS_BEFORE_EXPRESSION = \"return yield new del raise elif else if\";\n        ALL_KEYWORDS = RESERVED_WORDS + \" \" + KEYWORDS_BEFORE_EXPRESSION;\n        KEYWORDS = make_predicate(KEYWORDS);\n        RESERVED_WORDS = make_predicate(RESERVED_WORDS);\n        KEYWORDS_BEFORE_EXPRESSION = make_predicate(KEYWORDS_BEFORE_EXPRESSION);\n        KEYWORDS_ATOM = make_predicate(KEYWORDS_ATOM);\n        IDENTIFIER_PAT = /^[a-z_$][_a-z0-9$]*$/i;\n        function is_string_modifier(val) {\n            var ch;\n            var _$rapyd$_Iter23 = _$rapyd$_Iterable(val);\n            for (var _$rapyd$_Index23 = 0; _$rapyd$_Index23 < _$rapyd$_Iter23.length; _$rapyd$_Index23++) {\n                ch = _$rapyd$_Iter23[_$rapyd$_Index23];\n                if (\"vruVRU\".indexOf(ch) === -1) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        function is_letter(code) {\n            return code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 170 && UNICODE.letter.test(String.fromCharCode(code));\n        }\n        function is_digit(code) {\n            return code >= 48 && code <= 57;\n        }\n        function is_alphanumeric_char(code) {\n            return is_digit(code) || is_letter(code);\n        }\n        function is_unicode_combining_mark(ch) {\n            return UNICODE.non_spacing_mark.test(ch) || UNICODE.space_combining_mark.test(ch);\n        }\n        function is_unicode_connector_punctuation(ch) {\n            return UNICODE.connector_punctuation.test(ch);\n        }\n        function is_identifier(name) {\n            return !RESERVED_WORDS(name) && IDENTIFIER_PAT.test(name);\n        }\n        function is_identifier_start(code) {\n            return code === 36 || code === 95 || is_letter(code);\n        }\n        function is_identifier_char(ch) {\n            var code;\n            code = ch.charCodeAt(0);\n            return is_identifier_start(code) || is_digit(code) || code === 8204 || code === 8205 || is_unicode_combining_mark(ch) || is_unicode_connector_punctuation(ch);\n        }\n        function parse_js_number(num) {\n            if (RE_HEX_NUMBER.test(num)) {\n                return parseInt(num.substr(2), 16);\n            } else if (RE_OCT_NUMBER.test(num)) {\n                return parseInt(num.substr(1), 8);\n            } else if (RE_DEC_NUMBER.test(num)) {\n                return parseFloat(num);\n            }\n        }\n        UNICODE = {\n            \"letter\": new RegExp(\"[\\\\u0041-\\\\u005A\\\\u0061-\\\\u007A\\\\u00AA\\\\u00B5\\\\u00BA\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02C1\\\\u02C6-\\\\u02D1\\\\u02E0-\\\\u02E4\\\\u02EC\\\\u02EE\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037A-\\\\u037D\\\\u0386\\\\u0388-\\\\u038A\\\\u038C\\\\u038E-\\\\u03A1\\\\u03A3-\\\\u03F5\\\\u03F7-\\\\u0481\\\\u048A-\\\\u0523\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05D0-\\\\u05EA\\\\u05F0-\\\\u05F2\\\\u0621-\\\\u064A\\\\u066E\\\\u066F\\\\u0671-\\\\u06D3\\\\u06D5\\\\u06E5\\\\u06E6\\\\u06EE\\\\u06EF\\\\u06FA-\\\\u06FC\\\\u06FF\\\\u0710\\\\u0712-\\\\u072F\\\\u074D-\\\\u07A5\\\\u07B1\\\\u07CA-\\\\u07EA\\\\u07F4\\\\u07F5\\\\u07FA\\\\u0904-\\\\u0939\\\\u093D\\\\u0950\\\\u0958-\\\\u0961\\\\u0971\\\\u0972\\\\u097B-\\\\u097F\\\\u0985-\\\\u098C\\\\u098F\\\\u0990\\\\u0993-\\\\u09A8\\\\u09AA-\\\\u09B0\\\\u09B2\\\\u09B6-\\\\u09B9\\\\u09BD\\\\u09CE\\\\u09DC\\\\u09DD\\\\u09DF-\\\\u09E1\\\\u09F0\\\\u09F1\\\\u0A05-\\\\u0A0A\\\\u0A0F\\\\u0A10\\\\u0A13-\\\\u0A28\\\\u0A2A-\\\\u0A30\\\\u0A32\\\\u0A33\\\\u0A35\\\\u0A36\\\\u0A38\\\\u0A39\\\\u0A59-\\\\u0A5C\\\\u0A5E\\\\u0A72-\\\\u0A74\\\\u0A85-\\\\u0A8D\\\\u0A8F-\\\\u0A91\\\\u0A93-\\\\u0AA8\\\\u0AAA-\\\\u0AB0\\\\u0AB2\\\\u0AB3\\\\u0AB5-\\\\u0AB9\\\\u0ABD\\\\u0AD0\\\\u0AE0\\\\u0AE1\\\\u0B05-\\\\u0B0C\\\\u0B0F\\\\u0B10\\\\u0B13-\\\\u0B28\\\\u0B2A-\\\\u0B30\\\\u0B32\\\\u0B33\\\\u0B35-\\\\u0B39\\\\u0B3D\\\\u0B5C\\\\u0B5D\\\\u0B5F-\\\\u0B61\\\\u0B71\\\\u0B83\\\\u0B85-\\\\u0B8A\\\\u0B8E-\\\\u0B90\\\\u0B92-\\\\u0B95\\\\u0B99\\\\u0B9A\\\\u0B9C\\\\u0B9E\\\\u0B9F\\\\u0BA3\\\\u0BA4\\\\u0BA8-\\\\u0BAA\\\\u0BAE-\\\\u0BB9\\\\u0BD0\\\\u0C05-\\\\u0C0C\\\\u0C0E-\\\\u0C10\\\\u0C12-\\\\u0C28\\\\u0C2A-\\\\u0C33\\\\u0C35-\\\\u0C39\\\\u0C3D\\\\u0C58\\\\u0C59\\\\u0C60\\\\u0C61\\\\u0C85-\\\\u0C8C\\\\u0C8E-\\\\u0C90\\\\u0C92-\\\\u0CA8\\\\u0CAA-\\\\u0CB3\\\\u0CB5-\\\\u0CB9\\\\u0CBD\\\\u0CDE\\\\u0CE0\\\\u0CE1\\\\u0D05-\\\\u0D0C\\\\u0D0E-\\\\u0D10\\\\u0D12-\\\\u0D28\\\\u0D2A-\\\\u0D39\\\\u0D3D\\\\u0D60\\\\u0D61\\\\u0D7A-\\\\u0D7F\\\\u0D85-\\\\u0D96\\\\u0D9A-\\\\u0DB1\\\\u0DB3-\\\\u0DBB\\\\u0DBD\\\\u0DC0-\\\\u0DC6\\\\u0E01-\\\\u0E30\\\\u0E32\\\\u0E33\\\\u0E40-\\\\u0E46\\\\u0E81\\\\u0E82\\\\u0E84\\\\u0E87\\\\u0E88\\\\u0E8A\\\\u0E8D\\\\u0E94-\\\\u0E97\\\\u0E99-\\\\u0E9F\\\\u0EA1-\\\\u0EA3\\\\u0EA5\\\\u0EA7\\\\u0EAA\\\\u0EAB\\\\u0EAD-\\\\u0EB0\\\\u0EB2\\\\u0EB3\\\\u0EBD\\\\u0EC0-\\\\u0EC4\\\\u0EC6\\\\u0EDC\\\\u0EDD\\\\u0F00\\\\u0F40-\\\\u0F47\\\\u0F49-\\\\u0F6C\\\\u0F88-\\\\u0F8B\\\\u1000-\\\\u102A\\\\u103F\\\\u1050-\\\\u1055\\\\u105A-\\\\u105D\\\\u1061\\\\u1065\\\\u1066\\\\u106E-\\\\u1070\\\\u1075-\\\\u1081\\\\u108E\\\\u10A0-\\\\u10C5\\\\u10D0-\\\\u10FA\\\\u10FC\\\\u1100-\\\\u1159\\\\u115F-\\\\u11A2\\\\u11A8-\\\\u11F9\\\\u1200-\\\\u1248\\\\u124A-\\\\u124D\\\\u1250-\\\\u1256\\\\u1258\\\\u125A-\\\\u125D\\\\u1260-\\\\u1288\\\\u128A-\\\\u128D\\\\u1290-\\\\u12B0\\\\u12B2-\\\\u12B5\\\\u12B8-\\\\u12BE\\\\u12C0\\\\u12C2-\\\\u12C5\\\\u12C8-\\\\u12D6\\\\u12D8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135A\\\\u1380-\\\\u138F\\\\u13A0-\\\\u13F4\\\\u1401-\\\\u166C\\\\u166F-\\\\u1676\\\\u1681-\\\\u169A\\\\u16A0-\\\\u16EA\\\\u1700-\\\\u170C\\\\u170E-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176C\\\\u176E-\\\\u1770\\\\u1780-\\\\u17B3\\\\u17D7\\\\u17DC\\\\u1820-\\\\u1877\\\\u1880-\\\\u18A8\\\\u18AA\\\\u1900-\\\\u191C\\\\u1950-\\\\u196D\\\\u1970-\\\\u1974\\\\u1980-\\\\u19A9\\\\u19C1-\\\\u19C7\\\\u1A00-\\\\u1A16\\\\u1B05-\\\\u1B33\\\\u1B45-\\\\u1B4B\\\\u1B83-\\\\u1BA0\\\\u1BAE\\\\u1BAF\\\\u1C00-\\\\u1C23\\\\u1C4D-\\\\u1C4F\\\\u1C5A-\\\\u1C7D\\\\u1D00-\\\\u1DBF\\\\u1E00-\\\\u1F15\\\\u1F18-\\\\u1F1D\\\\u1F20-\\\\u1F45\\\\u1F48-\\\\u1F4D\\\\u1F50-\\\\u1F57\\\\u1F59\\\\u1F5B\\\\u1F5D\\\\u1F5F-\\\\u1F7D\\\\u1F80-\\\\u1FB4\\\\u1FB6-\\\\u1FBC\\\\u1FBE\\\\u1FC2-\\\\u1FC4\\\\u1FC6-\\\\u1FCC\\\\u1FD0-\\\\u1FD3\\\\u1FD6-\\\\u1FDB\\\\u1FE0-\\\\u1FEC\\\\u1FF2-\\\\u1FF4\\\\u1FF6-\\\\u1FFC\\\\u2071\\\\u207F\\\\u2090-\\\\u2094\\\\u2102\\\\u2107\\\\u210A-\\\\u2113\\\\u2115\\\\u2119-\\\\u211D\\\\u2124\\\\u2126\\\\u2128\\\\u212A-\\\\u212D\\\\u212F-\\\\u2139\\\\u213C-\\\\u213F\\\\u2145-\\\\u2149\\\\u214E\\\\u2183\\\\u2184\\\\u2C00-\\\\u2C2E\\\\u2C30-\\\\u2C5E\\\\u2C60-\\\\u2C6F\\\\u2C71-\\\\u2C7D\\\\u2C80-\\\\u2CE4\\\\u2D00-\\\\u2D25\\\\u2D30-\\\\u2D65\\\\u2D6F\\\\u2D80-\\\\u2D96\\\\u2DA0-\\\\u2DA6\\\\u2DA8-\\\\u2DAE\\\\u2DB0-\\\\u2DB6\\\\u2DB8-\\\\u2DBE\\\\u2DC0-\\\\u2DC6\\\\u2DC8-\\\\u2DCE\\\\u2DD0-\\\\u2DD6\\\\u2DD8-\\\\u2DDE\\\\u2E2F\\\\u3005\\\\u3006\\\\u3031-\\\\u3035\\\\u303B\\\\u303C\\\\u3041-\\\\u3096\\\\u309D-\\\\u309F\\\\u30A1-\\\\u30FA\\\\u30FC-\\\\u30FF\\\\u3105-\\\\u312D\\\\u3131-\\\\u318E\\\\u31A0-\\\\u31B7\\\\u31F0-\\\\u31FF\\\\u3400\\\\u4DB5\\\\u4E00\\\\u9FC3\\\\uA000-\\\\uA48C\\\\uA500-\\\\uA60C\\\\uA610-\\\\uA61F\\\\uA62A\\\\uA62B\\\\uA640-\\\\uA65F\\\\uA662-\\\\uA66E\\\\uA67F-\\\\uA697\\\\uA717-\\\\uA71F\\\\uA722-\\\\uA788\\\\uA78B\\\\uA78C\\\\uA7FB-\\\\uA801\\\\uA803-\\\\uA805\\\\uA807-\\\\uA80A\\\\uA80C-\\\\uA822\\\\uA840-\\\\uA873\\\\uA882-\\\\uA8B3\\\\uA90A-\\\\uA925\\\\uA930-\\\\uA946\\\\uAA00-\\\\uAA28\\\\uAA40-\\\\uAA42\\\\uAA44-\\\\uAA4B\\\\uAC00\\\\uD7A3\\\\uF900-\\\\uFA2D\\\\uFA30-\\\\uFA6A\\\\uFA70-\\\\uFAD9\\\\uFB00-\\\\uFB06\\\\uFB13-\\\\uFB17\\\\uFB1D\\\\uFB1F-\\\\uFB28\\\\uFB2A-\\\\uFB36\\\\uFB38-\\\\uFB3C\\\\uFB3E\\\\uFB40\\\\uFB41\\\\uFB43\\\\uFB44\\\\uFB46-\\\\uFBB1\\\\uFBD3-\\\\uFD3D\\\\uFD50-\\\\uFD8F\\\\uFD92-\\\\uFDC7\\\\uFDF0-\\\\uFDFB\\\\uFE70-\\\\uFE74\\\\uFE76-\\\\uFEFC\\\\uFF21-\\\\uFF3A\\\\uFF41-\\\\uFF5A\\\\uFF66-\\\\uFFBE\\\\uFFC2-\\\\uFFC7\\\\uFFCA-\\\\uFFCF\\\\uFFD2-\\\\uFFD7\\\\uFFDA-\\\\uFFDC]\"),\n            \"non_spacing_mark\": new RegExp(\"[\\\\u0300-\\\\u036F\\\\u0483-\\\\u0487\\\\u0591-\\\\u05BD\\\\u05BF\\\\u05C1\\\\u05C2\\\\u05C4\\\\u05C5\\\\u05C7\\\\u0610-\\\\u061A\\\\u064B-\\\\u065E\\\\u0670\\\\u06D6-\\\\u06DC\\\\u06DF-\\\\u06E4\\\\u06E7\\\\u06E8\\\\u06EA-\\\\u06ED\\\\u0711\\\\u0730-\\\\u074A\\\\u07A6-\\\\u07B0\\\\u07EB-\\\\u07F3\\\\u0816-\\\\u0819\\\\u081B-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082D\\\\u0900-\\\\u0902\\\\u093C\\\\u0941-\\\\u0948\\\\u094D\\\\u0951-\\\\u0955\\\\u0962\\\\u0963\\\\u0981\\\\u09BC\\\\u09C1-\\\\u09C4\\\\u09CD\\\\u09E2\\\\u09E3\\\\u0A01\\\\u0A02\\\\u0A3C\\\\u0A41\\\\u0A42\\\\u0A47\\\\u0A48\\\\u0A4B-\\\\u0A4D\\\\u0A51\\\\u0A70\\\\u0A71\\\\u0A75\\\\u0A81\\\\u0A82\\\\u0ABC\\\\u0AC1-\\\\u0AC5\\\\u0AC7\\\\u0AC8\\\\u0ACD\\\\u0AE2\\\\u0AE3\\\\u0B01\\\\u0B3C\\\\u0B3F\\\\u0B41-\\\\u0B44\\\\u0B4D\\\\u0B56\\\\u0B62\\\\u0B63\\\\u0B82\\\\u0BC0\\\\u0BCD\\\\u0C3E-\\\\u0C40\\\\u0C46-\\\\u0C48\\\\u0C4A-\\\\u0C4D\\\\u0C55\\\\u0C56\\\\u0C62\\\\u0C63\\\\u0CBC\\\\u0CBF\\\\u0CC6\\\\u0CCC\\\\u0CCD\\\\u0CE2\\\\u0CE3\\\\u0D41-\\\\u0D44\\\\u0D4D\\\\u0D62\\\\u0D63\\\\u0DCA\\\\u0DD2-\\\\u0DD4\\\\u0DD6\\\\u0E31\\\\u0E34-\\\\u0E3A\\\\u0E47-\\\\u0E4E\\\\u0EB1\\\\u0EB4-\\\\u0EB9\\\\u0EBB\\\\u0EBC\\\\u0EC8-\\\\u0ECD\\\\u0F18\\\\u0F19\\\\u0F35\\\\u0F37\\\\u0F39\\\\u0F71-\\\\u0F7E\\\\u0F80-\\\\u0F84\\\\u0F86\\\\u0F87\\\\u0F90-\\\\u0F97\\\\u0F99-\\\\u0FBC\\\\u0FC6\\\\u102D-\\\\u1030\\\\u1032-\\\\u1037\\\\u1039\\\\u103A\\\\u103D\\\\u103E\\\\u1058\\\\u1059\\\\u105E-\\\\u1060\\\\u1071-\\\\u1074\\\\u1082\\\\u1085\\\\u1086\\\\u108D\\\\u109D\\\\u135F\\\\u1712-\\\\u1714\\\\u1732-\\\\u1734\\\\u1752\\\\u1753\\\\u1772\\\\u1773\\\\u17B7-\\\\u17BD\\\\u17C6\\\\u17C9-\\\\u17D3\\\\u17DD\\\\u180B-\\\\u180D\\\\u18A9\\\\u1920-\\\\u1922\\\\u1927\\\\u1928\\\\u1932\\\\u1939-\\\\u193B\\\\u1A17\\\\u1A18\\\\u1A56\\\\u1A58-\\\\u1A5E\\\\u1A60\\\\u1A62\\\\u1A65-\\\\u1A6C\\\\u1A73-\\\\u1A7C\\\\u1A7F\\\\u1B00-\\\\u1B03\\\\u1B34\\\\u1B36-\\\\u1B3A\\\\u1B3C\\\\u1B42\\\\u1B6B-\\\\u1B73\\\\u1B80\\\\u1B81\\\\u1BA2-\\\\u1BA5\\\\u1BA8\\\\u1BA9\\\\u1C2C-\\\\u1C33\\\\u1C36\\\\u1C37\\\\u1CD0-\\\\u1CD2\\\\u1CD4-\\\\u1CE0\\\\u1CE2-\\\\u1CE8\\\\u1CED\\\\u1DC0-\\\\u1DE6\\\\u1DFD-\\\\u1DFF\\\\u20D0-\\\\u20DC\\\\u20E1\\\\u20E5-\\\\u20F0\\\\u2CEF-\\\\u2CF1\\\\u2DE0-\\\\u2DFF\\\\u302A-\\\\u302F\\\\u3099\\\\u309A\\\\uA66F\\\\uA67C\\\\uA67D\\\\uA6F0\\\\uA6F1\\\\uA802\\\\uA806\\\\uA80B\\\\uA825\\\\uA826\\\\uA8C4\\\\uA8E0-\\\\uA8F1\\\\uA926-\\\\uA92D\\\\uA947-\\\\uA951\\\\uA980-\\\\uA982\\\\uA9B3\\\\uA9B6-\\\\uA9B9\\\\uA9BC\\\\uAA29-\\\\uAA2E\\\\uAA31\\\\uAA32\\\\uAA35\\\\uAA36\\\\uAA43\\\\uAA4C\\\\uAAB0\\\\uAAB2-\\\\uAAB4\\\\uAAB7\\\\uAAB8\\\\uAABE\\\\uAABF\\\\uAAC1\\\\uABE5\\\\uABE8\\\\uABED\\\\uFB1E\\\\uFE00-\\\\uFE0F\\\\uFE20-\\\\uFE26]\"),\n            \"space_combining_mark\": new RegExp(\"[\\\\u0903\\\\u093E-\\\\u0940\\\\u0949-\\\\u094C\\\\u094E\\\\u0982\\\\u0983\\\\u09BE-\\\\u09C0\\\\u09C7\\\\u09C8\\\\u09CB\\\\u09CC\\\\u09D7\\\\u0A03\\\\u0A3E-\\\\u0A40\\\\u0A83\\\\u0ABE-\\\\u0AC0\\\\u0AC9\\\\u0ACB\\\\u0ACC\\\\u0B02\\\\u0B03\\\\u0B3E\\\\u0B40\\\\u0B47\\\\u0B48\\\\u0B4B\\\\u0B4C\\\\u0B57\\\\u0BBE\\\\u0BBF\\\\u0BC1\\\\u0BC2\\\\u0BC6-\\\\u0BC8\\\\u0BCA-\\\\u0BCC\\\\u0BD7\\\\u0C01-\\\\u0C03\\\\u0C41-\\\\u0C44\\\\u0C82\\\\u0C83\\\\u0CBE\\\\u0CC0-\\\\u0CC4\\\\u0CC7\\\\u0CC8\\\\u0CCA\\\\u0CCB\\\\u0CD5\\\\u0CD6\\\\u0D02\\\\u0D03\\\\u0D3E-\\\\u0D40\\\\u0D46-\\\\u0D48\\\\u0D4A-\\\\u0D4C\\\\u0D57\\\\u0D82\\\\u0D83\\\\u0DCF-\\\\u0DD1\\\\u0DD8-\\\\u0DDF\\\\u0DF2\\\\u0DF3\\\\u0F3E\\\\u0F3F\\\\u0F7F\\\\u102B\\\\u102C\\\\u1031\\\\u1038\\\\u103B\\\\u103C\\\\u1056\\\\u1057\\\\u1062-\\\\u1064\\\\u1067-\\\\u106D\\\\u1083\\\\u1084\\\\u1087-\\\\u108C\\\\u108F\\\\u109A-\\\\u109C\\\\u17B6\\\\u17BE-\\\\u17C5\\\\u17C7\\\\u17C8\\\\u1923-\\\\u1926\\\\u1929-\\\\u192B\\\\u1930\\\\u1931\\\\u1933-\\\\u1938\\\\u19B0-\\\\u19C0\\\\u19C8\\\\u19C9\\\\u1A19-\\\\u1A1B\\\\u1A55\\\\u1A57\\\\u1A61\\\\u1A63\\\\u1A64\\\\u1A6D-\\\\u1A72\\\\u1B04\\\\u1B35\\\\u1B3B\\\\u1B3D-\\\\u1B41\\\\u1B43\\\\u1B44\\\\u1B82\\\\u1BA1\\\\u1BA6\\\\u1BA7\\\\u1BAA\\\\u1C24-\\\\u1C2B\\\\u1C34\\\\u1C35\\\\u1CE1\\\\u1CF2\\\\uA823\\\\uA824\\\\uA827\\\\uA880\\\\uA881\\\\uA8B4-\\\\uA8C3\\\\uA952\\\\uA953\\\\uA983\\\\uA9B4\\\\uA9B5\\\\uA9BA\\\\uA9BB\\\\uA9BD-\\\\uA9C0\\\\uAA2F\\\\uAA30\\\\uAA33\\\\uAA34\\\\uAA4D\\\\uAA7B\\\\uABE3\\\\uABE4\\\\uABE6\\\\uABE7\\\\uABE9\\\\uABEA\\\\uABEC]\"),\n            \"connector_punctuation\": new RegExp(\"[\\\\u005F\\\\u203F\\\\u2040\\\\u2054\\\\uFE33\\\\uFE34\\\\uFE4D-\\\\uFE4F\\\\uFF3F]\")\n        };\n        function is_token(token, type, val) {\n            return token.type === type && (val === null || val === undefined || token.value === val);\n        }\n        EX_EOF = {};\n        function tokenizer($TEXT, filename) {\n            var S, read_string, read_regexp;\n            S = {\n                \"text\": $TEXT.replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, \"\\n\").replace(/\\uFEFF/g, \"\"),\n                \"filename\": filename,\n                \"pos\": 0,\n                \"tokpos\": 0,\n                \"line\": 1,\n                \"tokline\": 0,\n                \"col\": 0,\n                \"tokcol\": 0,\n                \"newline_before\": false,\n                \"regex_allowed\": false,\n                \"comments_before\": [],\n                \"whitespace_before\": [],\n                \"newblock\": false,\n                \"endblock\": false,\n                \"indentation_matters\": [ true ],\n                \"cached_whitespace\": \"\",\n                \"prev\": undefined,\n                \"index_or_slice\": [ false ],\n                \"expecting_object_literal_key\": false\n            };\n            function peek() {\n                return S.text.charAt(S.pos);\n            }\n            function prevChar() {\n                return S.text.charAt(S.tokpos - 1);\n            }\n            function next(signal_eof, in_string) {\n                var ch;\n                ch = S.text.charAt(S.pos);\n                S.pos += 1;\n                if (signal_eof && !ch) {\n                    throw EX_EOF;\n                }\n                if (ch === \"\\n\") {\n                    S.newline_before = S.newline_before || !in_string;\n                    S.line += 1;\n                    S.col = 0;\n                } else {\n                    S.col += 1;\n                }\n                return ch;\n            }\n            function find(what, signal_eof) {\n                var pos;\n                pos = S.text.indexOf(what, S.pos);\n                if (signal_eof && pos === -1) {\n                    throw EX_EOF;\n                }\n                return pos;\n            }\n            function start_token() {\n                S.tokline = S.line;\n                S.tokcol = S.col;\n                S.tokpos = S.pos;\n            }\n            function token(type, value, is_comment, keep_newline) {\n                var ret, i;\n                S.regex_allowed = type === \"operator\" && !UNARY_POSTFIX[value] || type === \"keyword\" && KEYWORDS_BEFORE_EXPRESSION(value) || type === \"punc\" && PUNC_BEFORE_EXPRESSION(value);\n                if (type === \"operator\" && value === \"is\" && S.text.substr(S.pos).trimLeft().substr(0, 4).trimRight() === \"not\") {\n                    next_token();\n                    value = \"!==\";\n                }\n                if (type === \"operator\" && OP_MAP[value]) {\n                    value = OP_MAP[value];\n                }\n                ret = {\n                    \"type\": type,\n                    \"value\": value,\n                    \"line\": S.tokline,\n                    \"col\": S.tokcol,\n                    \"pos\": S.tokpos,\n                    \"endpos\": S.pos,\n                    \"nlb\": S.newline_before,\n                    \"file\": filename\n                };\n                if (!is_comment) {\n                    ret.comments_before = S.comments_before;\n                    S.comments_before = [];\n                    for (var _$rapyd$_Index24 = 0; _$rapyd$_Index24 < ret.comments_before.length; _$rapyd$_Index24++) {\n                        i = _$rapyd$_Index24;\n                        ret.nlb = ret.nlb || ret.comments_before[i].nlb;\n                    }\n                }\n                if (!keep_newline) {\n                    S.newline_before = false;\n                }\n                if (type === \"punc\") {\n                    if (value === \":\" && !S.index_or_slice[S.index_or_slice.length-1] && !S.expecting_object_literal_key && (!S.text.substring(S.pos + 1, find(\"\\n\")).trim() || !S.text.substring(S.pos + 1, find(\"#\")).trim())) {\n                        S.newblock = true;\n                        S.indentation_matters.push(true);\n                    }\n                    if (value === \"[\") {\n                        if (S.prev && (S.prev.type === \"name\" || S.prev.type === \"punc\" && \")]\".indexOf(S.prev.value) !== -1)) {\n                            S.index_or_slice.push(true);\n                        } else {\n                            S.index_or_slice.push(false);\n                        }\n                        S.indentation_matters.push(false);\n                    } else if (value === \"{\" || value === \"(\") {\n                        S.indentation_matters.push(false);\n                    } else if (value === \"]\") {\n                        S.index_or_slice.pop();\n                        S.indentation_matters.pop();\n                    } else if (value === \"}\" || value === \")\") {\n                        S.indentation_matters.pop();\n                    }\n                }\n                S.prev = new AST_Token(ret);\n                return S.prev;\n            }\n            function parse_whitespace() {\n                var leading_whitespace, whitespace_exists, ch;\n                leading_whitespace = \"\";\n                whitespace_exists = false;\n                while (WHITESPACE_CHARS(peek())) {\n                    whitespace_exists = true;\n                    ch = next();\n                    if (ch === \"\\n\") {\n                        leading_whitespace = \"\";\n                    } else {\n                        leading_whitespace += ch;\n                    }\n                }\n                if (peek() !== \"#\") {\n                    if (!whitespace_exists) {\n                        leading_whitespace = S.cached_whitespace;\n                    } else {\n                        S.cached_whitespace = leading_whitespace;\n                    }\n                    if (S.newline_before || S.endblock) {\n                        return test_indent_token(leading_whitespace);\n                    }\n                }\n            }\n            function test_indent_token(leading_whitespace) {\n                var most_recent;\n                most_recent = S.whitespace_before[S.whitespace_before.length-1] || \"\";\n                S.endblock = false;\n                if (S.indentation_matters[S.indentation_matters.length-1] && leading_whitespace !== most_recent) {\n                    if (S.newblock && leading_whitespace && leading_whitespace.indexOf(most_recent) === 0) {\n                        S.newblock = false;\n                        S.whitespace_before.push(leading_whitespace);\n                        return 1;\n                    } else if (most_recent && most_recent.indexOf(leading_whitespace) === 0) {\n                        S.endblock = true;\n                        S.whitespace_before.pop();\n                        return -1;\n                    } else {\n                        parse_error(\"Inconsistent indentation\");\n                    }\n                } else {\n                    return 0;\n                }\n            }\n            function read_while(pred) {\n                var ret, i, ch;\n                ret = \"\";\n                i = 0;\n                ch = \"\";\n                while ((ch = peek()) && pred(ch, i)) {\n                    i += 1;\n                    ret += next();\n                }\n                return ret;\n            }\n            function parse_error(err, is_eof) {\n                throw new SyntaxError(err, filename, S.tokline, S.tokcol, S.tokpos, is_eof);\n            }\n            function read_num(prefix) {\n                var has_e, has_x, has_dot, num, valid, seen;\n                has_e = false;\n                has_x = false;\n                has_dot = prefix === \".\";\n                if (!prefix && peek() === \"0\" && S.text.charAt(S.pos + 1) === \"b\") {\n                    [next(), next()];\n                    num = read_while(function(ch) {\n                        return ch === \"0\" || ch === \"1\";\n                    });\n                    valid = parseInt(num, 2);\n                    if (isNaN(valid)) {\n                        parse_error(\"Invalid syntax for a binary number\");\n                    }\n                    return token(\"num\", valid);\n                }\n                seen = [];\n                num = read_while(function(ch, i) {\n                    seen.push(ch);\n                    if (ch === \"x\" || ch === \"X\") {\n                        if (has_x || seen.length !== 2 || seen[0] !== \"0\") {\n                            return false;\n                        }\n                        has_x = true;\n                        return true;\n                    } else if (ch === \"e\" || ch === \"E\") {\n                        if (has_x) {\n                            return true;\n                        }\n                        if (has_e || (i === 0 || typeof i === \"object\" && _$rapyd$_equals(i, 0))) {\n                            return false;\n                        }\n                        has_e = true;\n                        return true;\n                    } else if (ch === \"-\") {\n                        if (i === 0 && !prefix) {\n                            return true;\n                        }\n                        if (has_e && seen[i - 1].toLowerCase() === \"e\") {\n                            return true;\n                        }\n                        return false;\n                    } else if (ch === \"+\") {\n                        if (has_e && seen[i - 1].toLowerCase() === \"e\") {\n                            return true;\n                        }\n                        return false;\n                    } else if (ch === \".\") {\n                        return (!has_dot && !has_x && !has_e) ? has_dot = true : false;\n                    }\n                    return is_alphanumeric_char(ch.charCodeAt(0));\n                });\n                if (prefix) {\n                    num = prefix + num;\n                }\n                valid = parse_js_number(num);\n                if (!isNaN(valid)) {\n                    return token(\"num\", valid);\n                } else {\n                    parse_error(\"Invalid syntax: \" + num);\n                }\n            }\n            function read_hex_digits(count) {\n                var ans, nval;\n                ans = \"\";\n                while (count > 0) {\n                    count -= 1;\n                    if (!HEX_PAT.test(peek())) {\n                        return ans;\n                    }\n                    ans += next();\n                }\n                nval = parseInt(ans, 16);\n                if (nval > 1114111) {\n                    return ans;\n                }\n                return nval;\n            }\n            function read_escape_sequence() {\n                var q, octal, code, name, key;\n                q = next(true);\n                if (q === \"\\n\") {\n                    return \"\";\n                }\n                if (q === \"\\\\\") {\n                    return q;\n                }\n                if (\"\\\"'\".indexOf(q) !== -1) {\n                    return q;\n                }\n                if (ASCII_CONTROL_CHARS.hasOwnProperty(q)) {\n                    return String.fromCharCode(ASCII_CONTROL_CHARS[q]);\n                }\n                if (\"0\" <= q && q <= \"7\") {\n                    octal = q;\n                    if (\"0\" <= (_$rapyd$_cond_temp = peek()) && _$rapyd$_cond_temp <= \"7\") {\n                        octal += next();\n                    }\n                    if (\"0\" <= (_$rapyd$_cond_temp = peek()) && _$rapyd$_cond_temp <= \"7\") {\n                        octal += next();\n                    }\n                    code = parseInt(octal, 8);\n                    if (isNaN(code)) {\n                        return \"\\\\\" + octal;\n                    }\n                    return String.fromCharCode(code);\n                }\n                if (q === \"x\") {\n                    code = read_hex_digits(2);\n                    if (typeof code === \"number\") {\n                        return String.fromCharCode(code);\n                    }\n                    return \"\\\\x\" + code;\n                }\n                if (q === \"u\") {\n                    code = read_hex_digits(4);\n                    if (typeof code === \"number\") {\n                        return String.fromCharCode(code);\n                    }\n                    return \"\\\\u\" + code;\n                }\n                if (q === \"U\") {\n                    code = read_hex_digits(8);\n                    if (typeof code === \"number\") {\n                        if (code <= 65535) {\n                            return String.fromCharCode(code);\n                        }\n                        code -= 65536;\n                        return String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n                    }\n                    return \"\\\\U\" + code;\n                }\n                if (q === \"N\" && peek() === \"{\") {\n                    next();\n                    name = read_while(function(ch) {\n                        return NAME_PAT.test(ch);\n                    });\n                    if (peek() !== \"}\") {\n                        return \"\\\\N{\" + name;\n                    }\n                    next();\n                    key = (name || \"\").toLowerCase();\n                    if (!name || !Object.prototype.hasOwnProperty.call(ALIAS_MAP, key)) {\n                        return \"\\\\N{\" + name + \"}\";\n                    }\n                    code = ALIAS_MAP[key];\n                    if (code <= 65535) {\n                        return String.fromCharCode(code);\n                    }\n                    code -= 65536;\n                    return String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n                }\n                return \"\\\\\" + q;\n            }\n            function with_eof_error(eof_error, cont) {\n                return function() {\n                    try {\n                        return cont.apply(null, arguments);\n                    } catch (_$rapyd$_Exception) {\n                        var ex = _$rapyd$_Exception;\n                        if (ex === EX_EOF) {\n                            parse_error(eof_error, true);\n                        } else {\n                            throw _$rapyd$_Exception;\n                        }\n                    }\n                };\n            }\n            read_string = with_eof_error(\"Unterminated string constant\", function(is_raw_literal, is_js_literal) {\n                var quote, tok_type, ret, is_multiline, ch;\n                quote = next();\n                tok_type = (is_js_literal) ? \"js\" : \"string\";\n                ret = \"\";\n                is_multiline = false;\n                if (peek() === quote) {\n                    next(true);\n                    if (peek() === quote) {\n                        next(true);\n                        is_multiline = true;\n                    } else {\n                        return token(tok_type, \"\");\n                    }\n                }\n                while (ch = next(true)) {\n                    if (ch === \"\\n\" && !is_multiline) {\n                        parse_error(\"End of line while scanning string literal\");\n                    }\n                    if (ch === \"\\\\\") {\n                        ret += (is_raw_literal) ? \"\\\\\" + next(true) : read_escape_sequence();\n                        continue;\n                    }\n                    if (ch === quote) {\n                        if (!is_multiline) {\n                            break;\n                        }\n                        if (peek() === quote) {\n                            next();\n                            if (peek() === quote) {\n                                next();\n                                break;\n                            } else {\n                                ch += quote;\n                            }\n                        }\n                    }\n                    ret += ch;\n                }\n                return token(tok_type, ret);\n            });\n            function read_line_comment() {\n                var shebang = (arguments[0] === undefined || ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? (false) : arguments[0];\n                var _$rapyd$_kwargs_obj = arguments[arguments.length-1];\n                if (_$rapyd$_kwargs_obj === null || typeof _$rapyd$_kwargs_obj !== \"object\" || _$rapyd$_kwargs_obj [_$rapyd$_kwargs_symbol] !== true) _$rapyd$_kwargs_obj = {};\n                if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"shebang\")){\n                    shebang = _$rapyd$_kwargs_obj.shebang;\n                }\n                var i, ret;\n                if (!shebang) {\n                    next();\n                }\n                i = find(\"\\n\");\n                if (i === -1) {\n                    ret = S.text.substr(S.pos);\n                    S.pos = S.text.length;\n                } else {\n                    ret = S.text.substring(S.pos, i);\n                    S.pos = i;\n                }\n                return token((shebang) ? \"shebang\" : \"comment1\", ret, true);\n            }\n            function read_name() {\n                var name, ch, _$rapyd$_chain_assign_temp;\n                _$rapyd$_chain_assign_temp = \"\";\n                name = _$rapyd$_chain_assign_temp;\n                ch = _$rapyd$_chain_assign_temp;\n;\n                while ((ch = peek()) !== null) {\n                    if (ch === \"\\\\\") {\n                        if (S.text.charAt(S.pos + 1) === \"\\n\") {\n                            S.pos += 2;\n                            continue;\n                        }\n                        break;\n                    } else if (is_identifier_char(ch)) {\n                        name += next();\n                    } else {\n                        break;\n                    }\n                }\n                return name;\n            }\n            read_regexp = with_eof_error(\"Unterminated regular expression\", function() {\n                var prev_backslash, regexp, ch, _$rapyd$_chain_assign_temp, in_class, verbose_regexp, in_comment, mods;\n                prev_backslash = false;\n                _$rapyd$_chain_assign_temp = \"\";\n                regexp = _$rapyd$_chain_assign_temp;\n                ch = _$rapyd$_chain_assign_temp;\n;\n                in_class = false;\n                verbose_regexp = false;\n                in_comment = false;\n                if (peek() === \"/\") {\n                    next(true);\n                    if (peek() === \"/\") {\n                        verbose_regexp = true;\n                        next(true);\n                    } else {\n                        mods = read_name();\n                        return token(\"regexp\", new RegExp(regexp, mods));\n                    }\n                }\n                while (ch = next(true)) {\n                    if (in_comment) {\n                        if (ch === \"\\n\") {\n                            in_comment = false;\n                        }\n                        continue;\n                    }\n                    if (prev_backslash) {\n                        regexp += \"\\\\\" + ch;\n                        prev_backslash = false;\n                    } else if (ch === \"[\") {\n                        in_class = true;\n                        regexp += ch;\n                    } else if (ch === \"]\" && in_class) {\n                        in_class = false;\n                        regexp += ch;\n                    } else if (ch === \"/\" && !in_class) {\n                        if (verbose_regexp) {\n                            if (peek() !== \"/\") {\n                                regexp += \"\\\\/\";\n                                continue;\n                            }\n                            next(true);\n                            if (peek() !== \"/\") {\n                                regexp += \"\\\\/\\\\/\";\n                                continue;\n                            }\n                            next(true);\n                        }\n                        break;\n                    } else if (ch === \"\\\\\") {\n                        prev_backslash = true;\n                    } else if (verbose_regexp && !in_class && \" \\n\\r\\t\".indexOf(ch) !== -1) {\n                    } else if (verbose_regexp && !in_class && ch === \"#\") {\n                        in_comment = true;\n                    } else {\n                        regexp += ch;\n                    }\n                }\n                mods = read_name();\n                return token(\"regexp\", new RegExp(regexp, mods));\n            });\n            function read_operator(prefix) {\n                var op;\n                function grow(op) {\n                    var bigger;\n                    if (!peek()) {\n                        return op;\n                    }\n                    bigger = op + peek();\n                    if (OPERATORS(bigger)) {\n                        next();\n                        return grow(bigger);\n                    } else {\n                        return op;\n                    }\n                }\n                op = grow(prefix || next());\n                if (INVALID_OPERATORS.has(op)) {\n                    parse_error(\"Invalid operator «\" + op + \"»\");\n                }\n                if (op === \"!\") {\n                    return token(\"punc\", op);\n                }\n                return token(\"operator\", op);\n            }\n            function handle_slash() {\n                next();\n                return (S.regex_allowed) ? read_regexp(\"\") : read_operator(\"/\");\n            }\n            function handle_dot() {\n                next();\n                return (is_digit(peek().charCodeAt(0))) ? read_num(\".\") : token(\"punc\", \".\");\n            }\n            function read_word() {\n                var word;\n                word = read_name();\n                return (KEYWORDS_ATOM(word)) ? token(\"atom\", word) : (!KEYWORDS(word)) ? token(\"name\", word) : (OPERATORS(word) && prevChar() !== \".\") ? token(\"operator\", word) : token(\"keyword\", word);\n            }\n            function next_token() {\n                var indent, ch, code, tmp_, regex_allowed, tok, mods, stok;\n                indent = parse_whitespace();\n                if (indent === -1) {\n                    return token(\"punc\", \"}\", false, true);\n                }\n                start_token();\n                ch = peek();\n                if (!ch) {\n                    return token(\"eof\");\n                }\n                code = ch.charCodeAt(0);\n                tmp_ = code;\n                if (tmp_ === 34 || tmp_ === 39) {\n                    return read_string(false);\n                } else if (tmp_ === 35) {\n                    if (S.pos === 0 && S.text.charAt(1) === \"!\") {\n                        return read_line_comment(true);\n                    }\n                    regex_allowed = S.regex_allowed;\n                    S.comments_before.push(read_line_comment());\n                    S.regex_allowed = regex_allowed;\n                    return next_token();\n                } else if (tmp_ === 46) {\n                    return handle_dot();\n                } else if (tmp_ === 47) {\n                    return handle_slash();\n                }\n                if (is_digit(code)) {\n                    return read_num();\n                }\n                if (PUNC_CHARS(ch)) {\n                    return token(\"punc\", next());\n                }\n                if (OPERATOR_CHARS(ch)) {\n                    return read_operator();\n                }\n                if (code === 92 && S.text.charAt(S.pos + 1) === \"\\n\") {\n                    next();\n                    next();\n                    S.newline_before = false;\n                    return next_token();\n                }\n                if (is_identifier_start(code)) {\n                    tok = read_word();\n                    if (\"'\\\"\".indexOf(peek()) !== -1 && is_string_modifier(tok.value)) {\n                        mods = tok.value.toLowerCase();\n                        stok = read_string(mods.indexOf(\"r\") !== -1, mods.indexOf(\"v\") !== -1);\n                        tok.endpos = stok.endpos;\n                        tok.value = stok.value;\n                        tok.type = stok.type;\n                    }\n                    return tok;\n                }\n                parse_error(\"Unexpected character «\" + ch + \"»\");\n            }\n            next_token.context = function(nc) {\n                if (nc) {\n                    S = nc;\n                }\n                return S;\n            };\n            return next_token;\n        }\n        _$rapyd$_modules[\"tokenizer\"][\"RE_HEX_NUMBER\"] = RE_HEX_NUMBER;\n\n        _$rapyd$_modules[\"tokenizer\"][\"RE_OCT_NUMBER\"] = RE_OCT_NUMBER;\n\n        _$rapyd$_modules[\"tokenizer\"][\"RE_DEC_NUMBER\"] = RE_DEC_NUMBER;\n\n        _$rapyd$_modules[\"tokenizer\"][\"UNARY_POSTFIX\"] = UNARY_POSTFIX;\n\n        _$rapyd$_modules[\"tokenizer\"][\"OPERATOR_CHARS\"] = OPERATOR_CHARS;\n\n        _$rapyd$_modules[\"tokenizer\"][\"INVALID_OPERATORS\"] = INVALID_OPERATORS;\n\n        _$rapyd$_modules[\"tokenizer\"][\"ASCII_CONTROL_CHARS\"] = ASCII_CONTROL_CHARS;\n\n        _$rapyd$_modules[\"tokenizer\"][\"HEX_PAT\"] = HEX_PAT;\n\n        _$rapyd$_modules[\"tokenizer\"][\"NAME_PAT\"] = NAME_PAT;\n\n        _$rapyd$_modules[\"tokenizer\"][\"OPERATORS\"] = OPERATORS;\n\n        _$rapyd$_modules[\"tokenizer\"][\"OP_MAP\"] = OP_MAP;\n\n        _$rapyd$_modules[\"tokenizer\"][\"WHITESPACE_CHARS\"] = WHITESPACE_CHARS;\n\n        _$rapyd$_modules[\"tokenizer\"][\"PUNC_BEFORE_EXPRESSION\"] = PUNC_BEFORE_EXPRESSION;\n\n        _$rapyd$_modules[\"tokenizer\"][\"PUNC_CHARS\"] = PUNC_CHARS;\n\n        _$rapyd$_modules[\"tokenizer\"][\"REGEXP_MODIFIERS\"] = REGEXP_MODIFIERS;\n\n        _$rapyd$_modules[\"tokenizer\"][\"KEYWORDS\"] = KEYWORDS;\n\n        _$rapyd$_modules[\"tokenizer\"][\"KEYWORDS_ATOM\"] = KEYWORDS_ATOM;\n\n        _$rapyd$_modules[\"tokenizer\"][\"RESERVED_WORDS\"] = RESERVED_WORDS;\n\n        _$rapyd$_modules[\"tokenizer\"][\"KEYWORDS_BEFORE_EXPRESSION\"] = KEYWORDS_BEFORE_EXPRESSION;\n\n        _$rapyd$_modules[\"tokenizer\"][\"ALL_KEYWORDS\"] = ALL_KEYWORDS;\n\n        _$rapyd$_modules[\"tokenizer\"][\"IDENTIFIER_PAT\"] = IDENTIFIER_PAT;\n\n        _$rapyd$_modules[\"tokenizer\"][\"UNICODE\"] = UNICODE;\n\n        _$rapyd$_modules[\"tokenizer\"][\"EX_EOF\"] = EX_EOF;\n\n        _$rapyd$_modules[\"tokenizer\"][\"is_string_modifier\"] = is_string_modifier;\n\n        _$rapyd$_modules[\"tokenizer\"][\"is_letter\"] = is_letter;\n\n        _$rapyd$_modules[\"tokenizer\"][\"is_digit\"] = is_digit;\n\n        _$rapyd$_modules[\"tokenizer\"][\"is_alphanumeric_char\"] = is_alphanumeric_char;\n\n        _$rapyd$_modules[\"tokenizer\"][\"is_unicode_combining_mark\"] = is_unicode_combining_mark;\n\n        _$rapyd$_modules[\"tokenizer\"][\"is_unicode_connector_punctuation\"] = is_unicode_connector_punctuation;\n\n        _$rapyd$_modules[\"tokenizer\"][\"is_identifier\"] = is_identifier;\n\n        _$rapyd$_modules[\"tokenizer\"][\"is_identifier_start\"] = is_identifier_start;\n\n        _$rapyd$_modules[\"tokenizer\"][\"is_identifier_char\"] = is_identifier_char;\n\n        _$rapyd$_modules[\"tokenizer\"][\"parse_js_number\"] = parse_js_number;\n\n        _$rapyd$_modules[\"tokenizer\"][\"is_token\"] = is_token;\n\n        _$rapyd$_modules[\"tokenizer\"][\"tokenizer\"] = tokenizer;\n    })();\n\n    (function(){\n        var __name__ = \"parse\";\n        var COMPILER_VERSION, BASELIB_ITEMS, BASELIB_FUNCS, BASELIB_ITERTOOLS, NATIVE_CLASSES, ERROR_CLASSES, COMMON_STATIC, UNARY_PREFIX, ASSIGNMENT, PRECEDENCE, STATEMENTS_WITH_LABELS, ATOMIC_START_TOKEN, compile_time_decorators;\n        var make_predicate = _$rapyd$_modules[\"utils\"].make_predicate;\n        var array_to_hash = _$rapyd$_modules[\"utils\"].array_to_hash;\n        var defaults = _$rapyd$_modules[\"utils\"].defaults;\n        \n        var SyntaxError = _$rapyd$_modules[\"errors\"].SyntaxError;\n        var ImportError = _$rapyd$_modules[\"errors\"].ImportError;\n        \n        var AST_Accessor = _$rapyd$_modules[\"ast\"].AST_Accessor;\n        var AST_Array = _$rapyd$_modules[\"ast\"].AST_Array;\n        var AST_Assign = _$rapyd$_modules[\"ast\"].AST_Assign;\n        var AST_Binary = _$rapyd$_modules[\"ast\"].AST_Binary;\n        var AST_BlockStatement = _$rapyd$_modules[\"ast\"].AST_BlockStatement;\n        var AST_Break = _$rapyd$_modules[\"ast\"].AST_Break;\n        var AST_Call = _$rapyd$_modules[\"ast\"].AST_Call;\n        var AST_Catch = _$rapyd$_modules[\"ast\"].AST_Catch;\n        var AST_Class = _$rapyd$_modules[\"ast\"].AST_Class;\n        var AST_ClassCall = _$rapyd$_modules[\"ast\"].AST_ClassCall;\n        var AST_Conditional = _$rapyd$_modules[\"ast\"].AST_Conditional;\n        var AST_Const = _$rapyd$_modules[\"ast\"].AST_Const;\n        var AST_Constant = _$rapyd$_modules[\"ast\"].AST_Constant;\n        var AST_Continue = _$rapyd$_modules[\"ast\"].AST_Continue;\n        var AST_DWLoop = _$rapyd$_modules[\"ast\"].AST_DWLoop;\n        var AST_Debugger = _$rapyd$_modules[\"ast\"].AST_Debugger;\n        var AST_Decorator = _$rapyd$_modules[\"ast\"].AST_Decorator;\n        var AST_Definitions = _$rapyd$_modules[\"ast\"].AST_Definitions;\n        var AST_DictComprehension = _$rapyd$_modules[\"ast\"].AST_DictComprehension;\n        var AST_Directive = _$rapyd$_modules[\"ast\"].AST_Directive;\n        var AST_Do = _$rapyd$_modules[\"ast\"].AST_Do;\n        var AST_Dot = _$rapyd$_modules[\"ast\"].AST_Dot;\n        var AST_EmptyStatement = _$rapyd$_modules[\"ast\"].AST_EmptyStatement;\n        var AST_Except = _$rapyd$_modules[\"ast\"].AST_Except;\n        var AST_ExpressiveObject = _$rapyd$_modules[\"ast\"].AST_ExpressiveObject;\n        var AST_False = _$rapyd$_modules[\"ast\"].AST_False;\n        var AST_Finally = _$rapyd$_modules[\"ast\"].AST_Finally;\n        var AST_ForIn = _$rapyd$_modules[\"ast\"].AST_ForIn;\n        var AST_ForJS = _$rapyd$_modules[\"ast\"].AST_ForJS;\n        var AST_Function = _$rapyd$_modules[\"ast\"].AST_Function;\n        var AST_GeneratorComprehension = _$rapyd$_modules[\"ast\"].AST_GeneratorComprehension;\n        var AST_Hole = _$rapyd$_modules[\"ast\"].AST_Hole;\n        var AST_If = _$rapyd$_modules[\"ast\"].AST_If;\n        var AST_Import = _$rapyd$_modules[\"ast\"].AST_Import;\n        var AST_ImportedVar = _$rapyd$_modules[\"ast\"].AST_ImportedVar;\n        var AST_Imports = _$rapyd$_modules[\"ast\"].AST_Imports;\n        var AST_ListComprehension = _$rapyd$_modules[\"ast\"].AST_ListComprehension;\n        var AST_Method = _$rapyd$_modules[\"ast\"].AST_Method;\n        var AST_New = _$rapyd$_modules[\"ast\"].AST_New;\n        var AST_Null = _$rapyd$_modules[\"ast\"].AST_Null;\n        var AST_Number = _$rapyd$_modules[\"ast\"].AST_Number;\n        var AST_Object = _$rapyd$_modules[\"ast\"].AST_Object;\n        var AST_ObjectKeyVal = _$rapyd$_modules[\"ast\"].AST_ObjectKeyVal;\n        var AST_PropAccess = _$rapyd$_modules[\"ast\"].AST_PropAccess;\n        var AST_RegExp = _$rapyd$_modules[\"ast\"].AST_RegExp;\n        var AST_Return = _$rapyd$_modules[\"ast\"].AST_Return;\n        var AST_Scope = _$rapyd$_modules[\"ast\"].AST_Scope;\n        var AST_Set = _$rapyd$_modules[\"ast\"].AST_Set;\n        var AST_SetComprehension = _$rapyd$_modules[\"ast\"].AST_SetComprehension;\n        var AST_SetItem = _$rapyd$_modules[\"ast\"].AST_SetItem;\n        var AST_Seq = _$rapyd$_modules[\"ast\"].AST_Seq;\n        var AST_SimpleStatement = _$rapyd$_modules[\"ast\"].AST_SimpleStatement;\n        var AST_Splice = _$rapyd$_modules[\"ast\"].AST_Splice;\n        var AST_String = _$rapyd$_modules[\"ast\"].AST_String;\n        var AST_Sub = _$rapyd$_modules[\"ast\"].AST_Sub;\n        var AST_ItemAccess = _$rapyd$_modules[\"ast\"].AST_ItemAccess;\n        var AST_SymbolAccessor = _$rapyd$_modules[\"ast\"].AST_SymbolAccessor;\n        var AST_SymbolAlias = _$rapyd$_modules[\"ast\"].AST_SymbolAlias;\n        var AST_SymbolCatch = _$rapyd$_modules[\"ast\"].AST_SymbolCatch;\n        var AST_SymbolConst = _$rapyd$_modules[\"ast\"].AST_SymbolConst;\n        var AST_SymbolDefun = _$rapyd$_modules[\"ast\"].AST_SymbolDefun;\n        var AST_SymbolFunarg = _$rapyd$_modules[\"ast\"].AST_SymbolFunarg;\n        var AST_SymbolLambda = _$rapyd$_modules[\"ast\"].AST_SymbolLambda;\n        var AST_SymbolNonlocal = _$rapyd$_modules[\"ast\"].AST_SymbolNonlocal;\n        var AST_SymbolRef = _$rapyd$_modules[\"ast\"].AST_SymbolRef;\n        var AST_SymbolVar = _$rapyd$_modules[\"ast\"].AST_SymbolVar;\n        var AST_This = _$rapyd$_modules[\"ast\"].AST_This;\n        var AST_Throw = _$rapyd$_modules[\"ast\"].AST_Throw;\n        var AST_Toplevel = _$rapyd$_modules[\"ast\"].AST_Toplevel;\n        var AST_True = _$rapyd$_modules[\"ast\"].AST_True;\n        var AST_Try = _$rapyd$_modules[\"ast\"].AST_Try;\n        var AST_UnaryPostfix = _$rapyd$_modules[\"ast\"].AST_UnaryPostfix;\n        var AST_UnaryPrefix = _$rapyd$_modules[\"ast\"].AST_UnaryPrefix;\n        var AST_Undefined = _$rapyd$_modules[\"ast\"].AST_Undefined;\n        var AST_Var = _$rapyd$_modules[\"ast\"].AST_Var;\n        var AST_VarDef = _$rapyd$_modules[\"ast\"].AST_VarDef;\n        var AST_Verbatim = _$rapyd$_modules[\"ast\"].AST_Verbatim;\n        var AST_While = _$rapyd$_modules[\"ast\"].AST_While;\n        var AST_With = _$rapyd$_modules[\"ast\"].AST_With;\n        var AST_WithClause = _$rapyd$_modules[\"ast\"].AST_WithClause;\n        var AST_Yield = _$rapyd$_modules[\"ast\"].AST_Yield;\n        \n        var tokenizer = _$rapyd$_modules[\"tokenizer\"].tokenizer;\n        var is_token = _$rapyd$_modules[\"tokenizer\"].is_token;\n        var UNARY_POSTFIX = _$rapyd$_modules[\"tokenizer\"].UNARY_POSTFIX;\n        \n        COMPILER_VERSION = \"c9bd1ffade6268bbe51fc3af99b60ec0f6cd3826\";\n        BASELIB_ITEMS = (function(){\n            var s = _$rapyd$_set();\n            s.jsset.add(\"dir\");\n            s.jsset.add(\"enumerate\");\n            s.jsset.add(\"range\");\n            s.jsset.add(\"reversed\");\n            s.jsset.add(\"getattr\");\n            s.jsset.add(\"setattr\");\n            s.jsset.add(\"hasattr\");\n            s.jsset.add(\"iter\");\n            s.jsset.add(\"len\");\n            s.jsset.add(\"abs\");\n            s.jsset.add(\"max\");\n            s.jsset.add(\"min\");\n            s.jsset.add(\"sum\");\n            s.jsset.add(\"map\");\n            s.jsset.add(\"zip\");\n            s.jsset.add(\"filter\");\n            s.jsset.add(\"ord\");\n            s.jsset.add(\"chr\");\n            s.jsset.add(\"callable\");\n            s.jsset.add(\"bin\");\n            s.jsset.add(\"hex\");\n            return s;\n        })();\n        BASELIB_FUNCS = (function(){\n            var s = _$rapyd$_set();\n            s.jsset.add(\"len\");\n            s.jsset.add(\"abs\");\n            s.jsset.add(\"max\");\n            s.jsset.add(\"min\");\n            return s;\n        })();\n        BASELIB_ITERTOOLS = (function(){\n            var s = _$rapyd$_set();\n            s.jsset.add(\"sum\");\n            s.jsset.add(\"map\");\n            s.jsset.add(\"zip\");\n            s.jsset.add(\"filter\");\n            return s;\n        })();\n        NATIVE_CLASSES = {\n            \"Image\": {},\n            \"RegExp\": {},\n            \"Error\": {},\n            \"EvalError\": {},\n            \"InternalError\": {},\n            \"RangeError\": {},\n            \"ReferenceError\": {},\n            \"SyntaxError\": {},\n            \"TypeError\": {},\n            \"URIError\": {},\n            \"Object\": {\n                \"static\": _$rapyd$_list_decorate([ \"getOwnPropertyNames\", \"keys\", \"create\", \"defineProperty\", \"defineProperties\", \"getPrototypeOf\", \"setPrototypeOf\", \"assign\" ])\n            },\n            \"String\": {\n                \"static\": _$rapyd$_list_decorate([ \"fromCharCode\" ])\n            },\n            \"Array\": {\n                \"static\": _$rapyd$_list_decorate([ \"isArray\", \"from\", \"of\" ])\n            },\n            \"Function\": {},\n            \"Date\": {\n                \"static\": _$rapyd$_list_decorate([ \"UTC\", \"now\", \"parse\" ])\n            },\n            \"ArrayBuffer\": {},\n            \"DataView\": {},\n            \"Float32Array\": {},\n            \"Float64Array\": {},\n            \"Int16Array\": {},\n            \"Int32Array\": {},\n            \"Int8Array\": {},\n            \"Uint16Array\": {},\n            \"Uint32Array\": {},\n            \"Uint8Array\": {},\n            \"Uint8ClampedArray\": {},\n            \"Map\": {},\n            \"WeakMap\": {},\n            \"Set\": {},\n            \"WeakSet\": {},\n            \"XMLHttpRequest\": {},\n            \"TextEncoder\": {},\n            \"TextDecoder\": {},\n            \"MouseEvent\": {},\n            \"Event\": {},\n            \"CustomEvent\": {},\n            \"Blob\": {}\n        };\n        ERROR_CLASSES = {\n            \"Exception\": {},\n            \"AttributeError\": {},\n            \"IndexError\": {},\n            \"KeyError\": {},\n            \"ValueError\": {}\n        };\n        COMMON_STATIC = _$rapyd$_list_decorate([ \"call\", \"apply\", \"bind\", \"toString\" ]);\n        UNARY_PREFIX = make_predicate(_$rapyd$_list_decorate([ \"typeof\", \"void\", \"delete\", \"--\", \"++\", \"!\", \"~\", \"-\", \"+\", \"@\" ]));\n        ASSIGNMENT = make_predicate(_$rapyd$_list_decorate([ \"=\", \"+=\", \"-=\", \"/=\", \"//=\", \"*=\", \"%=\", \">>=\", \"<<=\", \">>>=\", \"|=\", \"^=\", \"&=\" ]));\n        PRECEDENCE = function(a, ret) {\n            var b, j, i;\n            for (var _$rapyd$_Index25 = 0; _$rapyd$_Index25 < a.length; _$rapyd$_Index25++) {\n                i = _$rapyd$_Index25;\n                b = a[i];\n                for (var _$rapyd$_Index26 = 0; _$rapyd$_Index26 < b.length; _$rapyd$_Index26++) {\n                    j = _$rapyd$_Index26;\n                    ret[b[j]] = i + 1;\n                }\n            }\n            return ret;\n        }(_$rapyd$_list_decorate([ _$rapyd$_list_decorate([ \"||\" ]), _$rapyd$_list_decorate([ \"&&\" ]), _$rapyd$_list_decorate([ \"|\" ]), _$rapyd$_list_decorate([ \"^\" ]), _$rapyd$_list_decorate([ \"&\" ]), _$rapyd$_list_decorate([ \"==\", \"===\", \"!=\", \"!==\" ]), _$rapyd$_list_decorate([ \"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\" ]), _$rapyd$_list_decorate([ \">>\", \"<<\", \">>>\" ]), _$rapyd$_list_decorate([ \"+\", \"-\" ]), _$rapyd$_list_decorate([ \"*\", \"/\", \"//\", \"%\" ]), _$rapyd$_list_decorate([ \"**\" ]) ]), {});\n        STATEMENTS_WITH_LABELS = array_to_hash(_$rapyd$_list_decorate([ \"for\", \"do\", \"while\", \"switch\" ]));\n        ATOMIC_START_TOKEN = array_to_hash(_$rapyd$_list_decorate([ \"atom\", \"num\", \"string\", \"regexp\", \"name\", \"js\" ]));\n        compile_time_decorators = _$rapyd$_list_decorate([ \"staticmethod\", \"external\", \"property\" ]);\n        function has_simple_decorator(decorators, name) {\n            var remove, s;\n            remove = [];\n            for (var i = 0; i < decorators.length; i++) {\n                s = decorators[i];\n                if (s instanceof AST_SymbolRef && !s.parens && s.name === name) {\n                    remove.push(i);\n                }\n            }\n            if (remove.length) {\n                remove.reverse();\n                for (var i = 0; i < remove.length; i++) {\n                    decorators.splice(remove[i], 1);\n                }\n                return true;\n            }\n            return false;\n        }\n        function has_setter_decorator(decorators, name) {\n            var remove, s;\n            remove = [];\n            for (var i = 0; i < decorators.length; i++) {\n                s = decorators[i];\n                if (s instanceof AST_Dot && s.expression instanceof AST_SymbolRef && s.expression.name === name && s.property === \"setter\") {\n                    remove.push(i);\n                }\n            }\n            if (remove.length) {\n                remove.reverse();\n                for (var i = 0; i < remove.length; i++) {\n                    decorators.splice(remove[i], 1);\n                }\n                return true;\n            }\n            return false;\n        }\n        function parse($TEXT, options) {\n            var import_dirs, x, location, module_id, baselib_items, imported_module_ids, IMPORTED, IMPORTING, S, obj, cname, statement, import_, class_, function_, nonlocal_, const_, new_, expr_atom, array_, object_, subscripts, maybe_unary, expr_op, maybe_conditional, maybe_assign, expression;\n            options = defaults(options, {\n                \"filename\": null,\n                \"auto_bind\": false,\n                \"module_id\": \"__main__\",\n                \"toplevel\": null,\n                \"for_linting\": false,\n                \"import_dirs\": [],\n                \"classes\": undefined\n            });\n            import_dirs = (function() {\n                var _$rapyd$_Iter = _$rapyd$_Iterable(options.import_dirs), _$rapyd$_Result = [], x;\n                for (var _$rapyd$_Index = 0; _$rapyd$_Index < _$rapyd$_Iter.length; _$rapyd$_Index++) {\n                    x = _$rapyd$_Iter[_$rapyd$_Index];\n                    _$rapyd$_Result.push(x);\n                }\n                _$rapyd$_Result = _$rapyd$_list_constructor(_$rapyd$_Result);\n                return _$rapyd$_Result;\n            })();\n            var _$rapyd$_Iter27 = _$rapyd$_Iterable([options.libdir, options.basedir]);\n            for (var _$rapyd$_Index27 = 0; _$rapyd$_Index27 < _$rapyd$_Iter27.length; _$rapyd$_Index27++) {\n                location = _$rapyd$_Iter27[_$rapyd$_Index27];\n                if (location) {\n                    import_dirs.push(location);\n                }\n            }\n            module_id = options.module_id;\n            baselib_items = {};\n            imported_module_ids = _$rapyd$_list_decorate([]);\n            IMPORTED = options.IMPORTED || {};\n            IMPORTING = options.IMPORTING || {};\n            IMPORTING[module_id] = true;\n            S = {\n                \"input\": (typeof $TEXT === \"string\") ? tokenizer($TEXT, options.filename) : $TEXT,\n                \"token\": null,\n                \"prev\": null,\n                \"peeked\": _$rapyd$_list_decorate([]),\n                \"in_function\": 0,\n                \"in_directives\": true,\n                \"statement_starting_token\": null,\n                \"in_comprehension\": false,\n                \"in_parenthesized_expr\": false,\n                \"in_loop\": 0,\n                \"in_class\": _$rapyd$_list_decorate([ false ]),\n                \"classes\": _$rapyd$_list_decorate([ {} ]),\n                \"functions\": _$rapyd$_list_decorate([ {} ]),\n                \"labels\": _$rapyd$_list_decorate([]),\n                \"decorators\": [],\n                \"parsing_decorator\": false\n            };\n            if (options.classes) {\n                var _$rapyd$_Iter28 = _$rapyd$_Iterable(options.classes);\n                for (var _$rapyd$_Index28 = 0; _$rapyd$_Index28 < _$rapyd$_Iter28.length; _$rapyd$_Index28++) {\n                    cname = _$rapyd$_Iter28[_$rapyd$_Index28];\n                    obj = options.classes[cname];\n                    S.classes[0][cname] = {\n                        \"static\": obj.static,\n                        \"bound\": obj.bound\n                    };\n                }\n            }\n            function next() {\n                S.prev = S.token;\n                if (S.peeked.length) {\n                    S.token = S.peeked.shift();\n                } else {\n                    S.token = S.input();\n                }\n                S.in_directives = S.in_directives && (S.token.type === \"string\" || is_(\"punc\", \";\"));\n                return S.token;\n            }\n            S.token = next();\n            function is_(type, value) {\n                return is_token(S.token, type, value);\n            }\n            function peek() {\n                if (!S.peeked.length) {\n                    S.peeked.push(S.input());\n                }\n                return S.peeked[0];\n            }\n            function prev() {\n                return S.prev;\n            }\n            function croak(msg, line, col, pos, is_eof) {\n                var ctx;\n                ctx = S.input.context();\n                throw new SyntaxError(msg, ctx.filename, (line !== undefined) ? line : ctx.tokline, (col !== undefined) ? col : ctx.tokcol, (pos !== undefined) ? pos : ctx.tokpos, is_eof);\n            }\n            function token_error(token, msg) {\n                var is_eof;\n                is_eof = (token.type === \"eof\") ? true : false;\n                croak(msg, token.line, token.col, undefined, is_eof);\n            }\n            function unexpected(token) {\n                if (token === undefined) {\n                    token = S.token;\n                }\n                token_error(token, \"Unexpected token: \" + token.type + \" «\" + token.value + \"»\");\n            }\n            function expect_token(type, val) {\n                if (is_(type, val)) {\n                    return next();\n                }\n                token_error(S.token, \"Unexpected token \" + S.token.type + \" «\" + S.token.value + \"»\" + \", expected \" + type + \" «\" + val + \"»\");\n            }\n            function expect(punc) {\n                return expect_token(\"punc\", punc);\n            }\n            function can_insert_semicolon() {\n                return S.token.nlb || is_(\"eof\") || is_(\"punc\", \"}\");\n            }\n            function semicolon() {\n                if (is_(\"punc\", \";\")) {\n                    next();\n                    S.token.nlb = true;\n                }\n            }\n            function embed_tokens(parser) {\n                return function() {\n                    var start, expr, end;\n                    start = S.token;\n                    expr = parser();\n                    if (expr === undefined) {\n                        unexpected();\n                    }\n                    end = prev();\n                    expr.start = start;\n                    expr.end = end;\n                    return expr;\n                };\n            }\n            function scan_for_top_level_callables(body) {\n                var ans, opt, x, obj;\n                ans = [];\n                if (Array.isArray(body)) {\n                    var _$rapyd$_Iter29 = _$rapyd$_Iterable(body);\n                    for (var _$rapyd$_Index29 = 0; _$rapyd$_Index29 < _$rapyd$_Iter29.length; _$rapyd$_Index29++) {\n                        obj = _$rapyd$_Iter29[_$rapyd$_Index29];\n                        if (obj instanceof AST_Function || obj instanceof AST_Class) {\n                            if (obj.name) {\n                                ans.push(obj.name.name);\n                            } else {\n                                token_error(obj.start, \"Top-level functions must have names\");\n                            }\n                        } else {\n                            if (obj instanceof AST_Scope) {\n                                continue;\n                            }\n                            var _$rapyd$_Iter30 = _$rapyd$_Iterable(_$rapyd$_list_decorate([ \"body\", \"alternative\" ]));\n                            for (var _$rapyd$_Index30 = 0; _$rapyd$_Index30 < _$rapyd$_Iter30.length; _$rapyd$_Index30++) {\n                                x = _$rapyd$_Iter30[_$rapyd$_Index30];\n                                opt = obj[x];\n                                if (opt) {\n                                    ans = ans.concat(scan_for_top_level_callables(opt));\n                                }\n                                if (opt instanceof AST_Assign && !(opt.right instanceof AST_Scope)) {\n                                    ans = ans.concat(scan_for_top_level_callables(opt.right));\n                                }\n                            }\n                        }\n                    }\n                } else if (body.body) {\n                    ans = ans.concat(scan_for_top_level_callables(body.body));\n                    if (body.alternative) {\n                        ans = ans.concat(scan_for_top_level_callables(body.alternative));\n                    }\n                }\n                return ans;\n            }\n            function scan_for_classes(body) {\n                var ans, obj;\n                ans = {};\n                var _$rapyd$_Iter31 = _$rapyd$_Iterable(body);\n                for (var _$rapyd$_Index31 = 0; _$rapyd$_Index31 < _$rapyd$_Iter31.length; _$rapyd$_Index31++) {\n                    obj = _$rapyd$_Iter31[_$rapyd$_Index31];\n                    if (obj instanceof AST_Class) {\n                        ans[obj.name.name] = obj;\n                    }\n                }\n                return ans;\n            }\n            function scan_for_local_vars(body) {\n                var localvars, seen, clause, stmt, lhs;\n                \"\\n        Pick out all variables being assigned to from within this scope, we'll mark them as local\\n\\n        body        body to be scanned\\n        \";\n                localvars = [];\n                seen = {};\n                function push(x) {\n                    if (Object.prototype.hasOwnProperty.call(seen, x)) {\n                        return;\n                    }\n                    seen[x] = true;\n                    localvars.push(x);\n                }\n                function extend(arr) {\n                    var x;\n                    var _$rapyd$_Iter32 = _$rapyd$_Iterable(arr);\n                    for (var _$rapyd$_Index32 = 0; _$rapyd$_Index32 < _$rapyd$_Iter32.length; _$rapyd$_Index32++) {\n                        x = _$rapyd$_Iter32[_$rapyd$_Index32];\n                        push(x);\n                    }\n                }\n                function scan_in_array(arr) {\n                    var x;\n                    var _$rapyd$_Iter33 = _$rapyd$_Iterable(arr);\n                    for (var _$rapyd$_Index33 = 0; _$rapyd$_Index33 < _$rapyd$_Iter33.length; _$rapyd$_Index33++) {\n                        x = _$rapyd$_Iter33[_$rapyd$_Index33];\n                        if (x instanceof AST_Seq) {\n                            x = x.to_array();\n                            baselib_items[\"_$rapyd$_flatten\"] = true;\n                        } else if (x instanceof AST_Array) {\n                            x = x.elements;\n                            baselib_items[\"_$rapyd$_flatten\"] = true;\n                        }\n                        if (Array.isArray(x)) {\n                            scan_in_array(x);\n                        } else {\n                            if (!(x instanceof AST_PropAccess)) {\n                                push(x.name);\n                            }\n                        }\n                    }\n                }\n                function add_assign_lhs(lhs) {\n                    if (lhs instanceof AST_Seq) {\n                        lhs = new AST_Array({\n                            \"elements\": lhs.to_array()\n                        });\n                    }\n                    if (lhs instanceof AST_Array) {\n                        push(\"_$rapyd$_unpack\");\n                        scan_in_array(lhs.elements);\n                    } else if (lhs.name) {\n                        push(lhs.name);\n                    }\n                }\n                function add_for_in(stmt) {\n                    if (stmt.init instanceof AST_Array) {\n                        push(\"_$rapyd$_unpack\");\n                        scan_in_array(stmt.init.elements);\n                    } else {\n                        push(stmt.init.name);\n                    }\n                }\n                if (Array.isArray(body)) {\n                    var _$rapyd$_Iter34 = _$rapyd$_Iterable(body);\n                    for (var _$rapyd$_Index34 = 0; _$rapyd$_Index34 < _$rapyd$_Iter34.length; _$rapyd$_Index34++) {\n                        stmt = _$rapyd$_Iter34[_$rapyd$_Index34];\n                        if (stmt instanceof AST_Scope) {\n                            continue;\n                        }\n                        [ \"body\", \"alternative\" ].forEach(function(option) {\n                            var opt;\n                            opt = stmt[option];\n                            if (opt) {\n                                extend(scan_for_local_vars(opt));\n                            }\n                            if (opt instanceof AST_Assign && !(opt.right instanceof AST_Scope)) {\n                                extend(scan_for_local_vars(opt.right));\n                            }\n                        });\n                        if (stmt instanceof AST_ForIn) {\n                            add_for_in(stmt);\n                        } else if (stmt instanceof AST_DWLoop) {\n                            extend(scan_for_local_vars(stmt));\n                        } else if (stmt instanceof AST_With) {\n                            [push(\"_$rapyd$_with_exception\"), push(\"_$rapyd$_with_suppress\")];\n                            var _$rapyd$_Iter35 = _$rapyd$_Iterable(stmt.clauses);\n                            for (var _$rapyd$_Index35 = 0; _$rapyd$_Index35 < _$rapyd$_Iter35.length; _$rapyd$_Index35++) {\n                                clause = _$rapyd$_Iter35[_$rapyd$_Index35];\n                                if (clause.alias) {\n                                    push(clause.alias.name);\n                                }\n                            }\n                        }\n                    }\n                } else if (body.body) {\n                    extend(scan_for_local_vars(body.body));\n                    if (body.alternative) {\n                        extend(scan_for_local_vars(body.alternative));\n                    }\n                } else if (body instanceof AST_Assign) {\n                    if (body.is_chained()) {\n                        var _$rapyd$_Iter36 = _$rapyd$_Iterable(body.traverse_chain()[0]);\n                        for (var _$rapyd$_Index36 = 0; _$rapyd$_Index36 < _$rapyd$_Iter36.length; _$rapyd$_Index36++) {\n                            lhs = _$rapyd$_Iter36[_$rapyd$_Index36];\n                            add_assign_lhs(lhs);\n                        }\n                        push(\"_$rapyd$_chain_assign_temp\");\n                    } else {\n                        add_assign_lhs(body.left);\n                    }\n                    if (!(body.right instanceof AST_Scope)) {\n                        extend(scan_for_local_vars(body.right));\n                    }\n                } else if (body instanceof AST_ForIn) {\n                    add_for_in(body);\n                }\n                return localvars;\n            }\n            function scan_for_nonlocal_defs(body) {\n                var vars, stmt;\n                vars = [];\n                if (Array.isArray(body)) {\n                    var _$rapyd$_Iter37 = _$rapyd$_Iterable(body);\n                    for (var _$rapyd$_Index37 = 0; _$rapyd$_Index37 < _$rapyd$_Iter37.length; _$rapyd$_Index37++) {\n                        stmt = _$rapyd$_Iter37[_$rapyd$_Index37];\n                        if (stmt instanceof AST_Scope) {\n                            continue;\n                        }\n                        if (stmt instanceof AST_Definitions) {\n                            stmt.definitions.forEach(function(vardef) {\n                                vars.push(vardef.name.name);\n                            });\n                        }\n                        [ \"body\", \"alternative\" ].forEach(function(option) {\n                            var opt;\n                            opt = stmt[option];\n                            if (opt) {\n                                vars = vars.concat(scan_for_nonlocal_defs(opt));\n                            }\n                        });\n                    }\n                } else if (body.body) {\n                    vars = vars.concat(scan_for_nonlocal_defs(body.body));\n                    if (body.alternative) {\n                        vars = vars.concat(scan_for_nonlocal_defs(body.alternative));\n                    }\n                }\n                return vars;\n            }\n            statement = embed_tokens(function() {\n                var tmp_, dir, stat, start, func, chain, tmp;\n                if (S.token.type === \"operator\" && S.token.value.substr(0, 1) === \"/\") {\n                    token_error(S.token, \"RapydScript does not support statements starting with regexp literals\");\n                }\n                S.statement_starting_token = S.token;\n                tmp_ = S.token.type;\n                if (tmp_ === \"string\") {\n                    dir = S.in_directives;\n                    stat = simple_statement();\n                    if (dir && stat.body instanceof AST_String && !is_(\"punc\", \",\")) {\n                        return new AST_Directive({\n                            \"value\": stat.body.value\n                        });\n                    }\n                    return stat;\n                } else if (tmp_ === \"shebang\") {\n                    tmp_ = S.token.value;\n                    next();\n                    return new AST_Directive({\n                        \"value\": tmp_\n                    });\n                } else if (tmp_ === \"num\" || tmp_ === \"regexp\" || tmp_ === \"operator\" || tmp_ === \"atom\" || tmp_ === \"js\") {\n                    return simple_statement();\n                } else if (tmp_ === \"punc\") {\n                    tmp_ = S.token.value;\n                    if (tmp_ === \":\") {\n                        return new AST_BlockStatement({\n                            \"start\": S.token,\n                            \"body\": block_(),\n                            \"end\": prev()\n                        });\n                    } else if (tmp_ === \"{\" || tmp_ === \"[\" || tmp_ === \"(\") {\n                        return simple_statement();\n                    } else if (tmp_ === \";\") {\n                        next();\n                        return new AST_EmptyStatement({\n                            \"stype\": \";\",\n                            \"start\": prev(),\n                            \"end\": prev()\n                        });\n                    } else {\n                        unexpected();\n                    }\n                } else if (tmp_ === \"name\") {\n                    if (is_token(peek(), \"punc\", \":\")) token_error(peek(), \"invalid syntax, colon not allowed here\");\n                    return simple_statement();\n                } else if (tmp_ === \"keyword\") {\n                    tmp_ = S.token.value;\n                    next();\n                    if (tmp_ === \"break\") {\n                        return break_cont(AST_Break);\n                    } else if (tmp_ === \"continue\") {\n                        return break_cont(AST_Continue);\n                    } else if (tmp_ === \"debugger\") {\n                        semicolon();\n                        return new AST_Debugger();\n                    } else if (tmp_ === \"do\") {\n                        return new AST_Do({\n                            \"body\": in_loop(statement),\n                            \"condition\": function() {\n                                var tmp;\n                                expect(\".\");\n                                expect_token(\"keyword\", \"while\");\n                                tmp = expression(true);\n                                semicolon();\n                                return tmp;\n                            }()\n                        });\n                    } else if (tmp_ === \"while\") {\n                        return new AST_While({\n                            \"condition\": expression(true),\n                            \"body\": in_loop(statement)\n                        });\n                    } else if (tmp_ === \"for\") {\n                        if (is_(\"js\")) {\n                            return for_js();\n                        }\n                        return for_();\n                    } else if (tmp_ === \"from\") {\n                        return import_(true);\n                    } else if (tmp_ === \"import\") {\n                        return import_(false);\n                    } else if (tmp_ === \"class\") {\n                        baselib_items[\"extends\"] = true;\n                        if (options.auto_bind) {\n                            baselib_items[\"rebind_all\"] = true;\n                        }\n                        return class_();\n                    } else if (tmp_ === \"def\") {\n                        start = prev();\n                        func = function_(S.in_class[S.in_class.length-1]);\n                        func.start = start;\n                        func.end = prev();\n                        chain = subscripts(func, true);\n                        if (chain === func) {\n                            return func;\n                        } else {\n                            return new AST_SimpleStatement({\n                                \"start\": start,\n                                \"body\": chain,\n                                \"end\": prev()\n                            });\n                        }\n                    } else if (tmp_ === \"if\") {\n                        return if_();\n                    } else if (tmp_ === \"pass\") {\n                        semicolon();\n                        return new AST_EmptyStatement({\n                            \"stype\": \"pass\",\n                            \"start\": prev(),\n                            \"end\": prev()\n                        });\n                    } else if (tmp_ === \"return\") {\n                        if (S.in_function === 0) {\n                            croak(\"'return' outside of function\");\n                        }\n                        if (S.functions[S.functions.length-1].is_generator) {\n                            croak(\"'return' not allowed in a function with yield\");\n                        }\n                        S.functions[S.functions.length-1].is_generator = false;\n                        return new AST_Return({\n                            \"value\": (is_(\"punc\", \";\")) ? function() {\n                                semicolon();\n                                return null;\n                            }() : (can_insert_semicolon()) ? null : function() {\n                                var tmp;\n                                tmp = expression(true);\n                                semicolon();\n                                return tmp;\n                            }()\n                        });\n                    } else if (tmp_ === \"yield\") {\n                        return yield_();\n                    } else if (tmp_ === \"raise\") {\n                        if (S.token.nlb) {\n                            return new AST_Throw({\n                                \"value\": new AST_SymbolCatch({\n                                    \"name\": \"_$rapyd$_Exception\"\n                                })\n                            });\n                        }\n                        tmp = expression(true);\n                        semicolon();\n                        return new AST_Throw({\n                            \"value\": tmp\n                        });\n                    } else if (tmp_ === \"try\") {\n                        return try_();\n                    } else if (tmp_ === \"nonlocal\") {\n                        tmp = nonlocal_();\n                        semicolon();\n                        return tmp;\n                    } else if (tmp_ === \"const\") {\n                        tmp = const_();\n                        semicolon();\n                        return tmp;\n                    } else if (tmp_ === \"with\") {\n                        return with_();\n                    } else {\n                        unexpected();\n                    }\n                }\n            });\n            function with_() {\n                var clauses, start, expr, alias, body;\n                clauses = [];\n                start = S.token;\n                while (true) {\n                    if (is_(\"eof\")) {\n                        unexpected();\n                    }\n                    expr = expression();\n                    alias = null;\n                    if (is_(\"keyword\", \"as\")) {\n                        next();\n                        alias = as_symbol(AST_SymbolAlias);\n                    }\n                    clauses.push(new AST_WithClause({\n                        \"expression\": expr,\n                        \"alias\": alias\n                    }));\n                    if (is_(\"punc\", \",\")) {\n                        next();\n                        continue;\n                    }\n                    if (!is_(\"punc\", \":\")) {\n                        unexpected();\n                    }\n                    break;\n                }\n                if (!clauses.length) {\n                    token_error(start, \"with statement must have at least one clause\");\n                }\n                body = statement();\n                return new AST_With({\n                    \"clauses\": clauses,\n                    \"body\": body\n                });\n            }\n            function simple_statement(tmp) {\n                tmp = expression(true);\n                semicolon();\n                return new AST_SimpleStatement({\n                    \"body\": tmp\n                });\n            }\n            function break_cont(type) {\n                if (S.in_loop === 0) {\n                    croak(type.TYPE + \" not inside a loop or switch\");\n                }\n                semicolon();\n                return new type();\n            }\n            function yield_() {\n                var is_yield_from;\n                if (S.in_function === 0) {\n                    croak(\"'yield' outside of function\");\n                }\n                if (S.functions[S.functions.length-1].is_generator === false) {\n                    croak(\"'yield' not allowed in a function with return\");\n                }\n                S.functions[S.functions.length-1].is_generator = true;\n                is_yield_from = is_(\"keyword\", \"from\");\n                if (is_yield_from) {\n                    next();\n                }\n                return new AST_Yield({\n                    \"is_yield_from\": is_yield_from,\n                    \"value\": (is_(\"punc\", \";\")) ? function() {\n                        semicolon();\n                        return null;\n                    }() : (can_insert_semicolon()) ? null : function() {\n                        var tmp;\n                        tmp = expression(true);\n                        semicolon();\n                        return tmp;\n                    }()\n                });\n            }\n            function for_(list_comp) {\n                var init, tmp;\n                init = null;\n                if (!is_(\"punc\", \";\")) {\n                    init = expression(true, true);\n                    if (init instanceof AST_Seq) {\n                        if (init.car instanceof AST_SymbolRef && init.cdr instanceof AST_SymbolRef) {\n                            tmp = init.to_array();\n                        } else {\n                            tmp = _$rapyd$_list_decorate([ init ]);\n                        }\n                        init = new AST_Array({\n                            \"start\": init.start,\n                            \"elements\": tmp,\n                            \"end\": init.end\n                        });\n                    }\n                    if (is_(\"operator\", \"in\")) {\n                        if (init instanceof AST_Var && init.definitions.length > 1) {\n                            croak(\"Only one variable declaration allowed in for..in loop\");\n                        }\n                        next();\n                        return for_in(init, list_comp);\n                    }\n                }\n                unexpected();\n            }\n            function for_in(init, list_comp) {\n                var lhs, obj;\n                lhs = (init instanceof AST_Var) ? init.definitions[0].name : null;\n                obj = expression(true);\n                baselib_items[\"iterable\"] = true;\n                if (list_comp) {\n                    return {\n                        \"init\": init,\n                        \"name\": lhs,\n                        \"object\": obj\n                    };\n                }\n                return new AST_ForIn({\n                    \"init\": init,\n                    \"name\": lhs,\n                    \"object\": obj,\n                    \"body\": in_loop(statement)\n                });\n            }\n            function for_js() {\n                var condition;\n                condition = as_atom_node();\n                return new AST_ForJS({\n                    \"condition\": condition,\n                    \"body\": in_loop(statement)\n                });\n            }\n            function get_class_in_scope(expr) {\n                var s, referenced_path, class_name;\n                if (expr instanceof AST_SymbolRef) {\n                    if (NATIVE_CLASSES.hasOwnProperty(expr.name)) {\n                        return NATIVE_CLASSES[expr.name];\n                    }\n                    if (ERROR_CLASSES.hasOwnProperty(expr.name)) {\n                        return ERROR_CLASSES[expr.name];\n                    }\n                    for (var _$rapyd$_Index38 = S.classes.length - 1; _$rapyd$_Index38 > -1; _$rapyd$_Index38-=1) {\n                        s = _$rapyd$_Index38;\n                        if (S.classes[s].hasOwnProperty(expr.name)) {\n                            return S.classes[s][expr.name];\n                        }\n                    }\n                } else if (expr instanceof AST_Dot) {\n                    referenced_path = _$rapyd$_list_decorate([]);\n                    while (expr instanceof AST_Dot) {\n                        referenced_path.unshift(expr.property);\n                        expr = expr.expression;\n                    }\n                    if (expr instanceof AST_SymbolRef) {\n                        referenced_path.unshift(expr.name);\n                        if (len(referenced_path) > 1) {\n                            class_name = referenced_path.join(\".\");\n                            for (var _$rapyd$_Index39 = S.classes.length - 1; _$rapyd$_Index39 > -1; _$rapyd$_Index39-=1) {\n                                s = _$rapyd$_Index39;\n                                if (S.classes[s].hasOwnProperty(class_name)) {\n                                    return S.classes[s][class_name];\n                                }\n                            }\n                        }\n                    }\n                }\n                return false;\n            }\n            function import_error(message) {\n                var ctx;\n                ctx = S.input.context();\n                throw new ImportError(message, ctx.filename, ctx.tokline, ctx.tokcol, ctx.tokpos);\n            }\n            function do_import(key) {\n                var package_module_id, src_code, filename, _$rapyd$_chain_assign_temp, modpath, _$rapyd$_unpack, data, location, cached, srchash, ikey, bitem;\n                if (IMPORTED.hasOwnProperty(key)) {\n                    return;\n                }\n                if (IMPORTING.hasOwnProperty(key) && IMPORTING[key]) {\n                    import_error(\"Detected a recursive import of: \" + key + \" while importing: \" + module_id);\n                }\n                package_module_id = key.split(\".\").slice(0, -1).join(\".\");\n                if (len(package_module_id) > 0) {\n                    do_import(package_module_id);\n                }\n                if (options.for_linting) {\n                    IMPORTED[key] = {\n                        \"is_cached\": true,\n                        \"classes\": {},\n                        \"module_id\": key,\n                        \"exports\": _$rapyd$_list_decorate([]),\n                        \"submodules\": _$rapyd$_list_decorate([]),\n                        \"nonlocalvars\": _$rapyd$_list_decorate([]),\n                        \"baselib\": {},\n                        \"outputs\": {}\n                    };\n                    if (len(package_module_id) > 0) {\n                        IMPORTED[package_module_id].submodules.push(key);\n                    }\n                    return;\n                }\n                function safe_read(base_path) {\n                    var _$rapyd$_unpack, i, path;\n                    var _$rapyd$_Iter40 = _$rapyd$_Iterable(enumerate(_$rapyd$_list_decorate([ base_path + \".pyj\", base_path + \"/__init__.pyj\" ])));\n                    for (var _$rapyd$_Index40 = 0; _$rapyd$_Index40 < _$rapyd$_Iter40.length; _$rapyd$_Index40++) {\n                        _$rapyd$_unpack = _$rapyd$_Iter40[_$rapyd$_Index40];\n                        i = _$rapyd$_unpack[0];\n                        path = _$rapyd$_unpack[1];\n                        try {\n                            return _$rapyd$_list_decorate([ readfile(path, \"utf-8\"), path ]);\n                        } catch (_$rapyd$_Exception) {\n                            var e = _$rapyd$_Exception;\n                            if (e.code === \"ENOENT\" || e.code === \"EPERM\" || e.code === \"EACCESS\") {\n                                if (i === 1) {\n                                    return [null, null];\n                                }\n                            }\n                            if (i === 1) {\n                                throw _$rapyd$_Exception;\n                            }\n                        }\n                    }\n                }\n                _$rapyd$_chain_assign_temp = null;\n                src_code = _$rapyd$_chain_assign_temp;\n                filename = _$rapyd$_chain_assign_temp;\n;\n                modpath = key.replace(\".\", \"/\");\n                var _$rapyd$_Iter41 = _$rapyd$_Iterable(import_dirs);\n                for (var _$rapyd$_Index41 = 0; _$rapyd$_Index41 < _$rapyd$_Iter41.length; _$rapyd$_Index41++) {\n                    location = _$rapyd$_Iter41[_$rapyd$_Index41];\n                    if (location) {\n                        _$rapyd$_unpack = safe_read(location + \"/\" + modpath);\n                        data = _$rapyd$_unpack[0];\n                        filename = _$rapyd$_unpack[1];\n                        if (data !== null) {\n                            src_code = data;\n                            break;\n                        }\n                    }\n                }\n                if (src_code === null) {\n                    import_error(\"Failed Import: '\" + key + \"' module doesn't exist in any of the import directories: \" + import_dirs.join(\":\"));\n                }\n                try {\n                    cached = JSON.parse(readfile(filename + \"-cached\", \"utf-8\"));\n                } catch (_$rapyd$_Exception) {\n                    cached = null;\n                }\n                srchash = sha1sum(src_code);\n                if (cached && cached[\"version\"] === COMPILER_VERSION && cached[\"signature\"] === srchash) {\n                    var _$rapyd$_Iter42 = _$rapyd$_Iterable(cached.imported_module_ids);\n                    for (var _$rapyd$_Index42 = 0; _$rapyd$_Index42 < _$rapyd$_Iter42.length; _$rapyd$_Index42++) {\n                        ikey = _$rapyd$_Iter42[_$rapyd$_Index42];\n                        do_import(ikey);\n                    }\n                    IMPORTED[key] = {\n                        \"is_cached\": true,\n                        \"classes\": cached[\"classes\"],\n                        \"outputs\": cached[\"outputs\"],\n                        \"module_id\": key,\n                        \"import_order\": Object.keys(IMPORTED).length,\n                        \"submodules\": _$rapyd$_list_decorate([]),\n                        \"nonlocalvars\": cached[\"nonlocalvars\"],\n                        \"baselib\": cached[\"baselib\"],\n                        \"exports\": cached.exports\n                    };\n                } else {\n                    parse(src_code, {\n                        \"filename\": filename,\n                        \"toplevel\": null,\n                        \"basedir\": options.basedir,\n                        \"libdir\": options.libdir,\n                        \"module_id\": key,\n                        \"IMPORTED\": IMPORTED,\n                        \"IMPORTING\": IMPORTING\n                    });\n                }\n                IMPORTED[key].srchash = srchash;\n                if (len(package_module_id) > 0) {\n                    IMPORTED[package_module_id].submodules.push(key);\n                }\n                var _$rapyd$_Iter43 = _$rapyd$_Iterable(Object.keys(IMPORTED[key].baselib));\n                for (var _$rapyd$_Index43 = 0; _$rapyd$_Index43 < _$rapyd$_Iter43.length; _$rapyd$_Index43++) {\n                    bitem = _$rapyd$_Iter43[_$rapyd$_Index43];\n                    baselib_items[bitem] = true;\n                }\n                imported_module_ids.push(key);\n            }\n            import_ = function(from_import) {\n                var ans, tok, tmp, name, last_tok, _$rapyd$_chain_assign_temp, key, alias, aimp, _$rapyd$_unpack, classes, argnames, bracketed, exports, symdef, aname, obj, argvar, cname, imp;\n                ans = new AST_Imports({\n                    \"imports\": _$rapyd$_list_decorate([])\n                });\n                while (true) {\n                    _$rapyd$_chain_assign_temp = expression(false);\n                    tok = _$rapyd$_chain_assign_temp;\n                    tmp = _$rapyd$_chain_assign_temp;\n                    name = _$rapyd$_chain_assign_temp;\n                    last_tok = _$rapyd$_chain_assign_temp;\n;\n                    key = \"\";\n                    while (tmp instanceof AST_Dot) {\n                        key = \".\" + tmp.property + key;\n                        _$rapyd$_chain_assign_temp = tmp.expression;\n                        tmp = _$rapyd$_chain_assign_temp;\n                        last_tok = _$rapyd$_chain_assign_temp;\n;\n                    }\n                    key = tmp.name + key;\n                    alias = null;\n                    if (!from_import && is_(\"keyword\", \"as\")) {\n                        next();\n                        alias = as_symbol(AST_SymbolAlias);\n                    }\n                    aimp = new AST_Import({\n                        \"module\": name,\n                        \"key\": key,\n                        \"alias\": alias,\n                        \"argnames\": null,\n                        \"body\": function() {\n                            return IMPORTED[key];\n                        }\n                    });\n                    _$rapyd$_unpack = [tok.start, last_tok.end];\n                    aimp.start = _$rapyd$_unpack[0];\n                    aimp.end = _$rapyd$_unpack[1];\n                    ans.imports.push(aimp);\n                    if (from_import) {\n                        break;\n                    }\n                    if (is_(\"punc\", \",\")) {\n                        next();\n                    } else {\n                        break;\n                    }\n                }\n                var _$rapyd$_Iter44 = _$rapyd$_Iterable(ans[\"imports\"]);\n                for (var _$rapyd$_Index44 = 0; _$rapyd$_Index44 < _$rapyd$_Iter44.length; _$rapyd$_Index44++) {\n                    imp = _$rapyd$_Iter44[_$rapyd$_Index44];\n                    do_import(imp.key);\n                    classes = IMPORTED[key].classes;\n                    if (from_import) {\n                        expect_token(\"keyword\", \"import\");\n                        _$rapyd$_chain_assign_temp = _$rapyd$_list_decorate([]);\n                        imp.argnames = _$rapyd$_chain_assign_temp;\n                        argnames = _$rapyd$_chain_assign_temp;\n;\n                        bracketed = is_(\"punc\", \"(\");\n                        if (bracketed) {\n                            next();\n                        }\n                        exports = {};\n                        var _$rapyd$_Iter45 = _$rapyd$_Iterable(IMPORTED[key].exports);\n                        for (var _$rapyd$_Index45 = 0; _$rapyd$_Index45 < _$rapyd$_Iter45.length; _$rapyd$_Index45++) {\n                            symdef = _$rapyd$_Iter45[_$rapyd$_Index45];\n                            exports[symdef.name] = true;\n                        }\n                        while (true) {\n                            aname = as_symbol(AST_ImportedVar);\n                            if (!options.for_linting && !exports.hasOwnProperty(aname.name)) {\n                                import_error(\"The symbol \\\"\" + aname.name + \"\\\" is not exported from the module: \" + key);\n                            }\n                            if (is_(\"keyword\", \"as\")) {\n                                next();\n                                aname.alias = as_symbol(AST_SymbolAlias);\n                            }\n                            argnames.push(aname);\n                            if (is_(\"punc\", \",\")) {\n                                next();\n                            } else {\n                                if (bracketed) {\n                                    if (is_(\"punc\", \")\")) {\n                                        next();\n                                    } else {\n                                        continue;\n                                    }\n                                }\n                                break;\n                            }\n                        }\n                        var _$rapyd$_Iter46 = _$rapyd$_Iterable(argnames);\n                        for (var _$rapyd$_Index46 = 0; _$rapyd$_Index46 < _$rapyd$_Iter46.length; _$rapyd$_Index46++) {\n                            argvar = _$rapyd$_Iter46[_$rapyd$_Index46];\n                            obj = classes[argvar.name];\n                            if (obj) {\n                                key = (argvar.alias) ? argvar.alias.name : argvar.name;\n                                S.classes[S.classes.length-1][key] = {\n                                    \"static\": obj.static,\n                                    \"bound\": obj.bound\n                                };\n                            }\n                        }\n                    } else {\n                        var _$rapyd$_Iter47 = _$rapyd$_Iterable(Object.keys(classes));\n                        for (var _$rapyd$_Index47 = 0; _$rapyd$_Index47 < _$rapyd$_Iter47.length; _$rapyd$_Index47++) {\n                            cname = _$rapyd$_Iter47[_$rapyd$_Index47];\n                            obj = classes[cname];\n                            key = (imp.alias) ? imp.alias.name : imp.key;\n                            S.classes[S.classes.length-1][key + \".\" + obj.name.name] = {\n                                \"static\": obj.static,\n                                \"bound\": obj.bound\n                            };\n                        }\n                    }\n                }\n                return ans;\n            };\n            class_ = function() {\n                var name, externaldecorator, class_details, definition, descriptor, _$rapyd$_chain_assign_temp, stmt, class_var_names, visitor;\n                name = as_symbol(AST_SymbolDefun);\n                if (!name) {\n                    unexpected();\n                }\n                externaldecorator = has_simple_decorator(S.decorators, \"external\");\n                class_details = {\n                    \"static\": _$rapyd$_list_decorate([]),\n                    \"bound\": {}\n                };\n                definition = new AST_Class({\n                    \"name\": name,\n                    \"module_id\": module_id,\n                    \"dynamic_properties\": {},\n                    \"parent\": function() {\n                        var a;\n                        if (is_(\"punc\", \"(\")) {\n                            S.in_parenthesized_expr = true;\n                            next();\n                            if (is_(\"punc\", \")\")) {\n                                S.in_parenthesized_expr = false;\n                                next();\n                                return null;\n                            }\n                            a = expr_atom(false);\n                            expect(\")\");\n                            S.in_parenthesized_expr = false;\n                            return a;\n                        } else {\n                            return null;\n                        }\n                    }(),\n                    \"localvars\": _$rapyd$_list_decorate([]),\n                    \"static\": class_details.static,\n                    \"external\": externaldecorator,\n                    \"bound\": class_details.bound,\n                    \"statements\": _$rapyd$_list_decorate([]),\n                    \"decorators\": function() {\n                        var d;\n                        d = _$rapyd$_list_decorate([]);\n                        S.decorators.forEach(function(decorator) {\n                            d.push(new AST_Decorator({\n                                \"expression\": decorator\n                            }));\n                        });\n                        S.decorators = [];\n                        return d;\n                    }(),\n                    \"body\": function(loop, labels) {\n                        var a;\n                        S.in_class.push(name.name);\n                        S.classes[S.classes.length - 1][name.name] = class_details;\n                        S.classes.push({});\n                        S.in_function += 1;\n                        S.in_directives = true;\n                        S.in_loop = 0;\n                        S.labels = _$rapyd$_list_decorate([]);\n                        a = block_();\n                        S.in_function -= 1;\n                        S.classes.pop();\n                        S.in_class.pop();\n                        S.in_loop = loop;\n                        S.labels = labels;\n                        return a;\n                    }(S.in_loop, S.labels)\n                });\n                var _$rapyd$_Iter48 = _$rapyd$_Iterable(definition.body);\n                for (var _$rapyd$_Index48 = 0; _$rapyd$_Index48 < _$rapyd$_Iter48.length; _$rapyd$_Index48++) {\n                    stmt = _$rapyd$_Iter48[_$rapyd$_Index48];\n                    if (stmt instanceof AST_Method) {\n                        if (stmt.is_getter || stmt.is_setter) {\n                            descriptor = definition.dynamic_properties[stmt.name.name];\n                            if (!descriptor) {\n                                _$rapyd$_chain_assign_temp = {};\n                                descriptor = _$rapyd$_chain_assign_temp;\n                                definition.dynamic_properties[stmt.name.name] = _$rapyd$_chain_assign_temp;\n;\n                            }\n                            descriptor[(stmt.is_getter) ? \"getter\" : \"setter\"] = stmt;\n                        } else if (stmt.name.name === \"__init__\") {\n                            definition.init = stmt;\n                        }\n                    }\n                }\n                class_var_names = {};\n                function walker() {\n                    this._visit = function(node, descend) {\n                        if (node instanceof AST_Method) {\n                            class_var_names[node.name.name] = true;\n                            return;\n                        } else if (node instanceof AST_Assign && node.left instanceof AST_SymbolRef) {\n                            class_var_names[node.left.name] = true;\n                        } else if (node instanceof AST_SymbolRef && Object.prototype.hasOwnProperty.call(class_var_names, node.name)) {\n                            node.thedef = new AST_SymbolDefun({\n                                \"name\": name.name + \".prototype.\" + node.name\n                            });\n                        }\n                        if (descend) {\n                            descend.call(node);\n                        }\n                    };\n                }\n                visitor = new walker();\n                var _$rapyd$_Iter49 = _$rapyd$_Iterable(definition.body);\n                for (var _$rapyd$_Index49 = 0; _$rapyd$_Index49 < _$rapyd$_Iter49.length; _$rapyd$_Index49++) {\n                    stmt = _$rapyd$_Iter49[_$rapyd$_Index49];\n                    if (!(stmt instanceof AST_Class)) {\n                        stmt.walk(visitor);\n                        definition.statements.push(stmt);\n                    }\n                }\n                return definition;\n            };\n            function_ = function(in_class, ctor) {\n                var is_accessor, name, staticmethod, property_getter, property_setter, _$rapyd$_chain_assign_temp, staticloc, is_generator, definition, assignments, j, i, nonlocals;\n                is_accessor = ctor === AST_Accessor;\n                name = (is_(\"name\")) ? as_symbol((in_class) ? AST_SymbolDefun : (is_accessor) ? AST_SymbolAccessor : AST_SymbolLambda) : (is_accessor && (is_(\"string\") || is_(\"num\"))) ? as_atom_node() : null;\n                if (in_class && !name) {\n                    unexpected();\n                }\n                _$rapyd$_chain_assign_temp = false;\n                staticmethod = _$rapyd$_chain_assign_temp;\n                property_getter = _$rapyd$_chain_assign_temp;\n                property_setter = _$rapyd$_chain_assign_temp;\n;\n                if (in_class) {\n                    staticloc = has_simple_decorator(S.decorators, \"staticmethod\");\n                    property_getter = has_simple_decorator(S.decorators, \"property\");\n                    property_setter = has_setter_decorator(S.decorators, name.name);\n                    if (staticloc) {\n                        if (property_getter || property_setter) {\n                            croak(\"A method cannot be both static and a property getter/setter\");\n                        }\n                        S.classes[S.classes.length - 2][in_class].static.push(name.name);\n                        staticmethod = true;\n                    } else if (name.name !== \"__init__\" && options.auto_bind) {\n                        baselib_items[\"bind\"] = true;\n                        S.classes[S.classes.length - 2][in_class].bound[name.name] = true;\n                    }\n                }\n                expect(\"(\");\n                S.in_parenthesized_expr = true;\n                if (!ctor) {\n                    ctor = (in_class) ? AST_Method : AST_Function;\n                }\n                is_generator = [];\n                definition = new ctor({\n                    \"name\": name,\n                    \"argnames\": function(a) {\n                        var defaults, first, seen_names, val;\n                        defaults = {};\n                        first = true;\n                        seen_names = {};\n                        function get_arg() {\n                            if (Object.prototype.hasOwnProperty.call(seen_names, S.token.value)) {\n                                token_error(prev(), \"Can't repeat parameter names\");\n                            }\n                            if (S.token.value === \"arguments\") {\n                                token_error(prev(), \"Can't use the name arguments as a parameter name, it is reserved by JavaScript\");\n                            }\n                            seen_names[S.token.value] = true;\n                            return as_symbol(AST_SymbolFunarg);\n                        }\n                        while (!is_(\"punc\", \")\")) {\n                            if (first) {\n                                first = false;\n                            } else {\n                                expect(\",\");\n                                if (is_(\"punc\", \")\")) {\n                                    break;\n                                }\n                            }\n                            if (is_(\"operator\", \"**\")) {\n                                next();\n                                if (a.kwargs) {\n                                    token_error(prev(), \"Can't define multiple **kwargs in function definition\");\n                                }\n                                a.kwargs = get_arg();\n                            } else if (is_(\"operator\", \"*\")) {\n                                next();\n                                if (a.starargs) {\n                                    token_error(prev(), \"Can't define multiple *args in function definition\");\n                                }\n                                if (a.kwargs) {\n                                    token_error(prev(), \"Can't define *args after **kwargs in function definition\");\n                                }\n                                a.starargs = get_arg();\n                            } else {\n                                if (a.starargs || a.kwargs) {\n                                    token_error(prev(), \"Can't define a formal parameter after *args or **kwargs\");\n                                }\n                                a.push(get_arg());\n                                if (is_(\"operator\", \"=\")) {\n                                    if (a.kwargs) {\n                                        token_error(prev(), \"Can't define an optional formal parameter after **kwargs\");\n                                    }\n                                    val = prev().value;\n                                    next();\n                                    defaults[val] = expression(false);\n                                    a.has_defaults = true;\n                                } else {\n                                    if (a.has_defaults) {\n                                        token_error(prev(), \"Can't define required formal parameters after optional formal parameters\");\n                                    }\n                                }\n                            }\n                        }\n                        next();\n                        S.in_parenthesized_expr = false;\n                        a.defaults = defaults;\n                        a.is_simple_func = !a.starargs && !a.kwargs && !a.has_defaults;\n                        return a;\n                    }([]),\n                    \"localvars\": _$rapyd$_list_decorate([]),\n                    \"decorators\": function() {\n                        var d;\n                        d = [];\n                        S.decorators.forEach(function(decorator) {\n                            d.push(new AST_Decorator({\n                                \"expression\": decorator\n                            }));\n                        });\n                        S.decorators = [];\n                        return d;\n                    }(),\n                    \"body\": function(loop, labels) {\n                        var a;\n                        S.in_class.push(false);\n                        S.classes.push({});\n                        S.in_function += 1;\n                        S.functions.push({});\n                        S.in_directives = true;\n                        S.in_loop = 0;\n                        S.labels = _$rapyd$_list_decorate([]);\n                        a = block_();\n                        S.in_function -= 1;\n                        is_generator.push(bool(S.functions.pop().is_generator));\n                        S.classes.pop();\n                        S.in_class.pop();\n                        S.in_loop = loop;\n                        S.labels = labels;\n                        return a;\n                    }(S.in_loop, S.labels)\n                });\n                definition.is_generator = is_generator[0];\n                if (definition instanceof AST_Method) {\n                    definition.static = staticmethod;\n                    definition.is_getter = property_getter;\n                    definition.is_setter = property_setter;\n                    if (definition.argnames.length < 1 && !definition.static) {\n                        croak(\"Methods of a class must have at least one argument, traditionally named self\");\n                    }\n                    if (definition.name && definition.name.name === \"__init__\") {\n                        if (definition.is_generator) {\n                            croak(\"The __init__ method of a class cannot be a generator (yield not allowed)\");\n                        }\n                        if (property_getter || property_setter) {\n                            croak(\"The __init__ method of a class cannot be a property getter/setter\");\n                        }\n                    }\n                }\n                if (definition.is_generator) {\n                    baselib_items[\"yield\"] = true;\n                }\n                assignments = scan_for_local_vars(definition.body);\n                for (var _$rapyd$_Index50 = 0; _$rapyd$_Index50 < assignments.length; _$rapyd$_Index50++) {\n                    i = _$rapyd$_Index50;\n                    for (var _$rapyd$_Index51 = 0; _$rapyd$_Index51 < definition.argnames.length + 1; _$rapyd$_Index51++) {\n                        j = _$rapyd$_Index51;\n                        if (j === definition.argnames.length) {\n                            definition.localvars.push(new_symbol(AST_SymbolVar, assignments[i]));\n                        } else if (j < definition.argnames.length && assignments[i] === definition.argnames[j].name) {\n                            break;\n                        }\n                    }\n                }\n                nonlocals = scan_for_nonlocal_defs(definition.body);\n                nonlocals = (function() {\n                    var _$rapyd$_Iter = _$rapyd$_Iterable(nonlocals), _$rapyd$_Result = _$rapyd$_set(), name;\n                    for (var _$rapyd$_Index = 0; _$rapyd$_Index < _$rapyd$_Iter.length; _$rapyd$_Index++) {\n                        name = _$rapyd$_Iter[_$rapyd$_Index];\n                        _$rapyd$_Result.add(name);\n                    }\n                    return _$rapyd$_Result;\n                })();\n                definition.localvars = definition.localvars.filter(function(v) {\n                    return !nonlocals.has(v.name);\n                });\n                return definition;\n            };\n            function if_() {\n                var cond, body, belse;\n                cond = expression(true);\n                body = statement();\n                belse = null;\n                if (is_(\"keyword\", \"elif\") || is_(\"keyword\", \"else\")) {\n                    if (is_(\"keyword\", \"else\")) {\n                        next();\n                    } else {\n                        S.token.value = \"if\";\n                    }\n                    belse = statement();\n                }\n                return new AST_If({\n                    \"condition\": cond,\n                    \"body\": body,\n                    \"alternative\": belse\n                });\n            }\n            function block_() {\n                var a;\n                expect(\":\");\n                a = [];\n                if (!S.token.nlb) {\n                    while (!S.token.nlb) {\n                        if (is_(\"eof\")) {\n                            unexpected();\n                        }\n                        a.push(statement());\n                    }\n                } else {\n                    while (!is_(\"punc\", \"}\")) {\n                        if (is_(\"eof\")) {\n                            return a;\n                        }\n                        a.push(statement());\n                    }\n                    next();\n                }\n                return a;\n            }\n            function try_() {\n                var body, bcatch, bfinally, start, exceptions, name;\n                body = block_();\n                bcatch = _$rapyd$_list_decorate([]);\n                bfinally = null;\n                while (is_(\"keyword\", \"except\")) {\n                    start = S.token;\n                    next();\n                    exceptions = _$rapyd$_list_decorate([]);\n                    if (!is_(\"punc\", \":\") && !is_(\"keyword\", \"as\")) {\n                        exceptions.push(as_symbol(AST_SymbolVar));\n                        while (is_(\"punc\", \",\")) {\n                            next();\n                            exceptions.push(as_symbol(AST_SymbolVar));\n                        }\n                    }\n                    name = null;\n                    if (is_(\"keyword\", \"as\")) {\n                        next();\n                        name = as_symbol(AST_SymbolCatch);\n                    }\n                    bcatch.push(new AST_Except({\n                        \"start\": start,\n                        \"argname\": name,\n                        \"errors\": exceptions,\n                        \"body\": block_(),\n                        \"end\": prev()\n                    }));\n                }\n                if (is_(\"keyword\", \"finally\")) {\n                    start = S.token;\n                    next();\n                    bfinally = new AST_Finally({\n                        \"start\": start,\n                        \"body\": block_(),\n                        \"end\": prev()\n                    });\n                }\n                if (!bcatch.length && !bfinally) {\n                    croak(\"Missing except/finally blocks\");\n                }\n                return new AST_Try({\n                    \"body\": body,\n                    \"bcatch\": (bcatch.length) ? new AST_Catch({\n                        \"body\": bcatch\n                    }) : null,\n                    \"bfinally\": bfinally\n                });\n            }\n            function vardefs(no_in, in_const, in_nonlocal) {\n                var a;\n                a = _$rapyd$_list_decorate([]);\n                while (true) {\n                    a.push(new AST_VarDef({\n                        \"start\": S.token,\n                        \"name\": as_symbol((in_const) ? AST_SymbolConst : (in_nonlocal) ? AST_SymbolNonlocal : AST_SymbolVar),\n                        \"value\": (is_(\"operator\", \"=\")) ? (next(), expression(false, no_in)) : null,\n                        \"end\": prev()\n                    }));\n                    if (!is_(\"punc\", \",\")) {\n                        break;\n                    }\n                    next();\n                }\n                return a;\n            }\n            nonlocal_ = function(no_in) {\n                return new AST_Var({\n                    \"start\": prev(),\n                    \"definitions\": vardefs(no_in, false, true),\n                    \"end\": prev()\n                });\n            };\n            const_ = function() {\n                return new AST_Const({\n                    \"start\": prev(),\n                    \"definitions\": vardefs(false, true),\n                    \"end\": prev()\n                });\n            };\n            new_ = function() {\n                var start, newexp, args;\n                start = S.token;\n                expect_token(\"operator\", \"new\");\n                newexp = expr_atom(false);\n                if (is_(\"punc\", \"(\")) {\n                    S.in_parenthesized_expr = true;\n                    next();\n                    args = func_call_list();\n                    S.in_parenthesized_expr = false;\n                } else {\n                    args = func_call_list(true);\n                }\n                return subscripts(new AST_New({\n                    \"start\": start,\n                    \"expression\": newexp,\n                    \"args\": args,\n                    \"end\": prev()\n                }), true);\n            };\n            function string_() {\n                var strings, start;\n                strings = [];\n                start = S.token;\n                while (true) {\n                    strings.push(S.token.value);\n                    if (peek().type !== \"string\") {\n                        break;\n                    }\n                    next();\n                }\n                return new AST_String({\n                    \"start\": start,\n                    \"end\": S.token,\n                    \"value\": strings.join(\"\")\n                });\n            }\n            function token_as_atom_node() {\n                var tok, tmp_, tmp__;\n                tok = S.token;\n                tmp_ = tok.type;\n                if (tmp_ === \"name\") {\n                    return token_as_symbol(tok, AST_SymbolRef);\n                } else if (tmp_ === \"num\") {\n                    return new AST_Number({\n                        \"start\": tok,\n                        \"end\": tok,\n                        \"value\": tok.value\n                    });\n                } else if (tmp_ === \"string\") {\n                    return string_();\n                } else if (tmp_ === \"regexp\") {\n                    return new AST_RegExp({\n                        \"start\": tok,\n                        \"end\": tok,\n                        \"value\": tok.value\n                    });\n                } else if (tmp_ === \"atom\") {\n                    tmp__ = tok.value;\n                    if (tmp__ === \"False\") {\n                        return new AST_False({\n                            \"start\": tok,\n                            \"end\": tok\n                        });\n                    } else if (tmp__ === \"True\") {\n                        return new AST_True({\n                            \"start\": tok,\n                            \"end\": tok\n                        });\n                    } else if (tmp__ === \"None\") {\n                        return new AST_Null({\n                            \"start\": tok,\n                            \"end\": tok\n                        });\n                    }\n                } else if (tmp_ === \"js\") {\n                    return new AST_Verbatim({\n                        \"start\": tok,\n                        \"end\": tok,\n                        \"value\": tok.value\n                    });\n                }\n                token_error(tok, \"Expecting an atomic token (number/string/bool/regexp/js/None)\");\n            }\n            function as_atom_node() {\n                var ret;\n                ret = token_as_atom_node();\n                next();\n                return ret;\n            }\n            expr_atom = function(allow_calls) {\n                var start, tmp_, ex, ret, cls, func;\n                if (is_(\"operator\", \"new\")) {\n                    return new_();\n                }\n                start = S.token;\n                if (is_(\"punc\")) {\n                    tmp_ = start.value;\n                    if (tmp_ === \"(\") {\n                        S.in_parenthesized_expr = true;\n                        next();\n                        if (is_(\"punc\", \")\")) {\n                            next();\n                            return new AST_Array({\n                                \"elements\": _$rapyd$_list_decorate([])\n                            });\n                        }\n                        ex = expression(true);\n                        if (is_(\"keyword\", \"for\")) {\n                            ret = read_comprehension(new AST_GeneratorComprehension({\n                                \"statement\": ex\n                            }), \")\");\n                            S.in_parenthesized_expr = false;\n                            return ret;\n                        }\n                        ex.start = start;\n                        ex.end = S.token;\n                        if (ex instanceof AST_SymbolRef) {\n                            ex.parens = true;\n                        }\n                        if (!(ex instanceof AST_GeneratorComprehension)) {\n                            expect(\")\");\n                        }\n                        S.in_parenthesized_expr = false;\n                        return subscripts(ex, allow_calls);\n                    } else if (tmp_ === \"[\") {\n                        return subscripts(array_(), allow_calls);\n                    } else if (tmp_ === \"{\") {\n                        return subscripts(object_(), allow_calls);\n                    }\n                    unexpected();\n                }\n                if (is_(\"keyword\", \"class\")) {\n                    next();\n                    cls = class_();\n                    cls.start = start;\n                    cls.end = prev();\n                    return subscripts(cls, allow_calls);\n                }\n                if (is_(\"keyword\", \"def\")) {\n                    next();\n                    func = function_(false);\n                    func.start = start;\n                    func.end = prev();\n                    return subscripts(func, allow_calls);\n                }\n                if (is_(\"keyword\", \"yield\")) {\n                    next();\n                    return yield_();\n                }\n                if (ATOMIC_START_TOKEN[S.token.type]) {\n                    return subscripts(as_atom_node(), allow_calls);\n                }\n                unexpected();\n            };\n            function expr_list(closing, allow_trailing_comma, allow_empty, func_call) {\n                var first, a, saw_starargs, tmp, arg;\n                first = true;\n                a = _$rapyd$_list_decorate([]);\n                saw_starargs = false;\n                while (!is_(\"punc\", closing)) {\n                    if (saw_starargs) {\n                        token_error(prev(), \"*args must be the last argument in a function call\");\n                    }\n                    if (first) {\n                        first = false;\n                    } else {\n                        expect(\",\");\n                    }\n                    if (allow_trailing_comma && is_(\"punc\", closing)) {\n                        break;\n                    }\n                    if (is_(\"operator\", \"*\") && func_call) {\n                        saw_starargs = true;\n                        next();\n                    }\n                    if (is_(\"punc\", \",\") && allow_empty) {\n                        a.push(new AST_Hole({\n                            \"start\": S.token,\n                            \"end\": S.token\n                        }));\n                    } else {\n                        a.push(expression(false));\n                    }\n                }\n                if (func_call) {\n                    tmp = _$rapyd$_list_decorate([]);\n                    tmp.kwargs = _$rapyd$_list_decorate([]);\n                    var _$rapyd$_Iter52 = _$rapyd$_Iterable(a);\n                    for (var _$rapyd$_Index52 = 0; _$rapyd$_Index52 < _$rapyd$_Iter52.length; _$rapyd$_Index52++) {\n                        arg = _$rapyd$_Iter52[_$rapyd$_Index52];\n                        if (arg instanceof AST_Assign) {\n                            tmp.kwargs.push(_$rapyd$_list_decorate([ arg.left, arg.right ]));\n                        } else {\n                            tmp.push(arg);\n                        }\n                    }\n                    a = tmp;\n                }\n                next();\n                if (saw_starargs) {\n                    a.starargs = true;\n                }\n                return a;\n            }\n            function func_call_list(empty) {\n                var a, first, single_comprehension, arg;\n                a = [];\n                first = true;\n                a.kwargs = [];\n                a.kwarg_items = [];\n                a.starargs = false;\n                if (empty) {\n                    return a;\n                }\n                single_comprehension = false;\n                while (!is_(\"punc\", \")\") && !is_(\"eof\")) {\n                    if (!first) {\n                        expect(\",\");\n                        if (is_(\"punc\", \")\")) {\n                            break;\n                        }\n                    }\n                    if (is_(\"operator\", \"*\")) {\n                        next();\n                        arg = expression(false);\n                        arg.is_array = true;\n                        a.push(arg);\n                        a.starargs = true;\n                    } else if (is_(\"operator\", \"**\")) {\n                        next();\n                        a.kwarg_items.push(as_symbol(AST_SymbolRef, false));\n                        a.starargs = true;\n                    } else {\n                        arg = expression(false);\n                        if (arg instanceof AST_Assign) {\n                            a.kwargs.push(_$rapyd$_list_decorate([ arg.left, arg.right ]));\n                        } else {\n                            if (is_(\"keyword\", \"for\")) {\n                                if (!first) {\n                                    croak(\"Generator expression must be parenthesized if not sole argument\");\n                                }\n                                a.push(read_comprehension(new AST_GeneratorComprehension({\n                                    \"statement\": arg\n                                }), \")\"));\n                                single_comprehension = true;\n                                break;\n                            }\n                            a.push(arg);\n                        }\n                    }\n                    first = false;\n                }\n                if (a.kwargs.length) {\n                    baselib_items[\"_$rapyd$_desugar_kwargs()\"] = true;\n                }\n                if (!single_comprehension) {\n                    next();\n                }\n                return a;\n            }\n            array_ = embed_tokens(function() {\n                var expr;\n                expect(\"[\");\n                expr = _$rapyd$_list_decorate([]);\n                if (!is_(\"punc\", \"]\")) {\n                    expr.push(expression(false));\n                    if (is_(\"keyword\", \"for\")) {\n                        return read_comprehension(new AST_ListComprehension({\n                            \"statement\": expr[0]\n                        }), \"]\");\n                    }\n                    if (!is_(\"punc\", \"]\")) {\n                        expect(\",\");\n                    }\n                }\n                return new AST_Array({\n                    \"elements\": expr.concat(expr_list(\"]\", true, true))\n                });\n            });\n            object_ = embed_tokens(function() {\n                var first, has_non_const_keys, is_pydict, a, start, ctx, orig, left, end;\n                expect(\"{\");\n                first = true;\n                has_non_const_keys = false;\n                is_pydict = false;\n                a = _$rapyd$_list_decorate([]);\n                if (is_(\"punc\", \"!\")) {\n                    next();\n                    is_pydict = true;\n                }\n                while (!is_(\"punc\", \"}\")) {\n                    if (!first) {\n                        expect(\",\");\n                    }\n                    if (is_(\"punc\", \"}\")) {\n                        break;\n                    }\n                    first = false;\n                    start = S.token;\n                    ctx = S.input.context();\n                    orig = ctx.expecting_object_literal_key;\n                    ctx.expecting_object_literal_key = true;\n                    try {\n                        left = expression(false);\n                    } finally {\n                        ctx.expecting_object_literal_key = orig;\n                    }\n                    if (is_(\"keyword\", \"for\")) {\n                        return read_comprehension(new AST_SetComprehension({\n                            \"statement\": left\n                        }), \"}\");\n                    }\n                    if (a.length === 0 && (is_(\"punc\", \",\") || is_(\"punc\", \"}\"))) {\n                        end = prev();\n                        return set_(start, end, left);\n                    }\n                    if (!(left instanceof AST_Constant)) {\n                        has_non_const_keys = true;\n                    }\n                    expect(\":\");\n                    a.push(new AST_ObjectKeyVal({\n                        \"start\": start,\n                        \"key\": left,\n                        \"value\": expression(false),\n                        \"end\": prev()\n                    }));\n                    if (a.length === 1 && is_(\"keyword\", \"for\")) {\n                        return dict_comprehension(a, is_pydict);\n                    }\n                }\n                next();\n                return new ((has_non_const_keys) ? AST_ExpressiveObject : AST_Object)({\n                    \"properties\": a,\n                    \"is_pydict\": is_pydict\n                });\n            });\n            function set_(start, end, expr) {\n                var ostart, a;\n                ostart = start;\n                a = _$rapyd$_list_decorate([ new AST_SetItem({\n                    \"start\": start,\n                    \"end\": end,\n                    \"value\": expr\n                }) ]);\n                while (!is_(\"punc\", \"}\")) {\n                    expect(\",\");\n                    start = S.token;\n                    if (is_(\"punc\", \"}\")) {\n                        break;\n                    }\n                    a.push(new AST_SetItem({\n                        \"start\": start,\n                        \"value\": expression(false),\n                        \"end\": prev()\n                    }));\n                }\n                next();\n                return new AST_Set({\n                    \"items\": a,\n                    \"start\": ostart,\n                    \"end\": prev()\n                });\n            }\n            function read_comprehension(obj, terminator) {\n                var forloop;\n                if (obj instanceof AST_GeneratorComprehension) {\n                    baselib_items[\"yield\"] = true;\n                }\n                S.in_comprehension = true;\n                S.in_parenthesized_expr = false;\n                expect_token(\"keyword\", \"for\");\n                forloop = for_(true);\n                baselib_items[\"iterable\"] = true;\n                obj.init = forloop.init;\n                obj.name = forloop.name;\n                obj.object = forloop.object;\n                obj.condition = (is_(\"punc\", terminator)) ? null : (expect_token(\"keyword\", \"if\"), \n                expression(true));\n                expect(terminator);\n                S.in_comprehension = false;\n                return obj;\n            }\n            function dict_comprehension(a, is_pydict) {\n                var _$rapyd$_unpack, left, right;\n                if (a.length) {\n                    _$rapyd$_unpack = [a[0].key, a[0].value];\n                    left = _$rapyd$_unpack[0];\n                    right = _$rapyd$_unpack[1];\n                } else {\n                    left = expression(false);\n                    if (!is_(\"punc\", \":\")) {\n                        return read_comprehension(new AST_SetComprehension({\n                            \"statement\": left\n                        }), \"}\");\n                    }\n                    expect(\":\");\n                    right = expression(false);\n                }\n                return read_comprehension(new AST_DictComprehension({\n                    \"statement\": left,\n                    \"value_statement\": right,\n                    \"is_pydict\": is_pydict\n                }), \"}\");\n            }\n            function as_name() {\n                var tmp, tmp_;\n                tmp = S.token;\n                next();\n                tmp_ = tmp.type;\n                if (tmp_ === \"name\" || tmp_ === \"operator\" || tmp_ === \"keyword\" || tmp_ === \"atom\") {\n                    return tmp.value;\n                } else {\n                    unexpected();\n                }\n            }\n            function token_as_symbol(tok, ttype) {\n                var name;\n                name = tok.value;\n                return new ((name === \"this\") ? AST_This : ttype)({\n                    \"name\": String(tok.value),\n                    \"start\": tok,\n                    \"end\": tok\n                });\n            }\n            function as_symbol(ttype, noerror) {\n                var sym;\n                if (!is_(\"name\")) {\n                    if (!noerror) {\n                        croak(\"Name expected\");\n                    }\n                    return null;\n                }\n                sym = token_as_symbol(S.token, ttype);\n                next();\n                return sym;\n            }\n            function new_symbol(type, name) {\n                var sym;\n                sym = new ((name === \"this\") ? AST_This : type)({\n                    \"name\": String(name),\n                    \"start\": null,\n                    \"end\": null\n                });\n                return sym;\n            }\n            function is_static_method(cls, method) {\n                if (COMMON_STATIC.indexOf(method) !== -1 || cls.static && cls.static.indexOf(method) !== -1) {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n            subscripts = function(expr, allow_calls) {\n                var start, is_py_sub, slice_bounds, is_slice, i, assignment, ret, c, funcname, tmp_, args;\n                start = expr.start;\n                if (is_(\"punc\", \".\")) {\n                    next();\n                    return subscripts(new AST_Dot({\n                        \"start\": start,\n                        \"expression\": expr,\n                        \"property\": as_name(),\n                        \"end\": prev()\n                    }), allow_calls);\n                }\n                if (is_(\"punc\", \"[\") && !S.token.nlb) {\n                    next();\n                    is_py_sub = false;\n                    if (is_(\"punc\", \"!\")) {\n                        next();\n                        is_py_sub = true;\n                    }\n                    slice_bounds = _$rapyd$_list_decorate([]);\n                    is_slice = false;\n                    if (is_(\"punc\", \":\")) {\n                        slice_bounds.push(null);\n                    } else {\n                        slice_bounds.push(expression(false));\n                    }\n                    if (is_(\"punc\", \":\")) {\n                        is_slice = true;\n                        next();\n                        if (is_(\"punc\", \":\")) {\n                            slice_bounds.push(null);\n                        } else if (!is_(\"punc\", \"]\")) {\n                            slice_bounds.push(expression(false));\n                        }\n                    }\n                    if (is_(\"punc\", \":\")) {\n                        next();\n                        if (is_(\"punc\", \"]\")) {\n                            unexpected();\n                        } else {\n                            slice_bounds.push(expression(false));\n                        }\n                    }\n                    expect(\"]\");\n                    if (is_slice) {\n                        if (is_(\"operator\") && S.token.value === \"=\") {\n                            next();\n                            return subscripts(new AST_Splice({\n                                \"start\": start,\n                                \"expression\": expr,\n                                \"property\": slice_bounds[0] || new AST_Number({\n                                    \"value\": 0\n                                }),\n                                \"property2\": slice_bounds[1],\n                                \"assignment\": expression(true),\n                                \"end\": prev()\n                            }), allow_calls);\n                        } else if (slice_bounds.length === 3) {\n                            slice_bounds.unshift(slice_bounds.pop());\n                            if (!slice_bounds[slice_bounds.length-1]) {\n                                slice_bounds.pop();\n                                if (!slice_bounds[slice_bounds.length-1]) {\n                                    slice_bounds.pop();\n                                }\n                            } else if (!slice_bounds[slice_bounds.length-2]) {\n                                slice_bounds[slice_bounds.length-2] = new AST_Undefined();\n                            }\n                            return subscripts(new AST_Call({\n                                \"start\": start,\n                                \"expression\": new AST_SymbolRef({\n                                    \"name\": \"_$rapyd$_eslice\"\n                                }),\n                                \"args\": _$rapyd$_list_decorate([ expr ]).concat(slice_bounds),\n                                \"end\": prev()\n                            }), allow_calls);\n                        } else {\n                            slice_bounds = (function() {\n                                var _$rapyd$_Iter = _$rapyd$_Iterable(slice_bounds), _$rapyd$_Result = [], i;\n                                for (var _$rapyd$_Index = 0; _$rapyd$_Index < _$rapyd$_Iter.length; _$rapyd$_Index++) {\n                                    i = _$rapyd$_Iter[_$rapyd$_Index];\n                                    _$rapyd$_Result.push((i === null) ? new AST_Number({\n                                        \"value\": 0\n                                    }) : i);\n                                }\n                                _$rapyd$_Result = _$rapyd$_list_constructor(_$rapyd$_Result);\n                                return _$rapyd$_Result;\n                            })();\n                            return subscripts(new AST_Call({\n                                \"start\": start,\n                                \"expression\": new AST_Dot({\n                                    \"start\": start,\n                                    \"expression\": expr,\n                                    \"property\": \"slice\",\n                                    \"end\": prev()\n                                }),\n                                \"args\": slice_bounds,\n                                \"end\": prev()\n                            }), allow_calls);\n                        }\n                    } else {\n                        if (is_py_sub) {\n                            assignment = null;\n                            if (is_(\"operator\") && S.token.value === \"=\") {\n                                next();\n                                assignment = expression(true);\n                            }\n                            return subscripts(new AST_ItemAccess({\n                                \"start\": start,\n                                \"expression\": expr,\n                                \"property\": slice_bounds[0] || new AST_Number({\n                                    \"value\": 0\n                                }),\n                                \"assignment\": assignment,\n                                \"end\": prev()\n                            }), allow_calls);\n                        }\n                        return subscripts(new AST_Sub({\n                            \"start\": start,\n                            \"expression\": expr,\n                            \"property\": slice_bounds[0] || new AST_Number({\n                                \"value\": 0\n                            }),\n                            \"end\": prev()\n                        }), allow_calls);\n                    }\n                }\n                if (allow_calls && is_(\"punc\", \"(\") && !S.token.nlb) {\n                    S.in_parenthesized_expr = true;\n                    next();\n                    if (!expr.parens && get_class_in_scope(expr)) {\n                        ret = subscripts(new AST_New({\n                            \"start\": start,\n                            \"expression\": expr,\n                            \"args\": func_call_list(),\n                            \"end\": prev()\n                        }), true);\n                        S.in_parenthesized_expr = false;\n                        return ret;\n                    } else {\n                        if (expr instanceof AST_Dot) {\n                            c = get_class_in_scope(expr.expression);\n                        }\n                        if (c) {\n                            funcname = expr;\n                            if (funcname.property === \"__init__\") {\n                                funcname.property = \"constructor\";\n                            }\n                            ret = subscripts(new AST_ClassCall({\n                                \"start\": start,\n                                \"class\": expr.expression,\n                                \"method\": funcname.property,\n                                \"static\": is_static_method(c, funcname.property),\n                                \"args\": func_call_list(),\n                                \"end\": prev()\n                            }), true);\n                            S.in_parenthesized_expr = false;\n                            return ret;\n                        } else if (expr instanceof AST_SymbolRef) {\n                            tmp_ = expr.name;\n                            if (BASELIB_ITEMS.has(tmp_)) {\n                                if (BASELIB_FUNCS.has(tmp_)) {\n                                    baselib_items[tmp_ + \"()\"] = true;\n                                } else if (BASELIB_ITERTOOLS.has(tmp_)) {\n                                    baselib_items[\"itertools\"] = true;\n                                } else {\n                                    baselib_items[tmp_] = true;\n                                }\n                            } else if (tmp_ === \"type\") {\n                                ret = new AST_UnaryPrefix({\n                                    \"start\": start,\n                                    \"operator\": \"typeof\",\n                                    \"expression\": func_call_list()[0],\n                                    \"end\": prev()\n                                });\n                                S.in_parenthesized_expr = false;\n                                return ret;\n                            } else if (tmp_ === \"isinstance\") {\n                                args = func_call_list();\n                                if (args.length !== 2) {\n                                    croak(\"isinstance() must be called with exactly two arguments\");\n                                }\n                                ret = new AST_Binary({\n                                    \"start\": start,\n                                    \"left\": args[0],\n                                    \"operator\": \"instanceof\",\n                                    \"right\": args[1],\n                                    \"end\": prev()\n                                });\n                                S.in_parenthesized_expr = false;\n                                return ret;\n                            }\n                        }\n                        ret = subscripts(new AST_Call({\n                            \"start\": start,\n                            \"expression\": expr,\n                            \"args\": func_call_list(),\n                            \"end\": prev()\n                        }), true);\n                        S.in_parenthesized_expr = false;\n                        return ret;\n                    }\n                }\n                return expr;\n            };\n            maybe_unary = function(allow_calls) {\n                var start, expr, ex, val;\n                start = S.token;\n                if (is_(\"operator\", \"@\")) {\n                    if (S.parsing_decorator) {\n                        croak(\"Nested decorators are not allowed\");\n                    }\n                    next();\n                    S.parsing_decorator = true;\n                    expr = expression();\n                    S.parsing_decorator = false;\n                    S.decorators.push(expr);\n                    return new AST_EmptyStatement({\n                        \"stype\": \"@\",\n                        \"start\": prev(),\n                        \"end\": prev()\n                    });\n                }\n                if (is_(\"operator\") && UNARY_PREFIX(start.value)) {\n                    next();\n                    ex = make_unary(AST_UnaryPrefix, start.value, maybe_unary(allow_calls));\n                    ex.start = start;\n                    ex.end = prev();\n                    return ex;\n                }\n                val = expr_atom(allow_calls);\n                while (is_(\"operator\") && UNARY_POSTFIX(S.token.value) && !S.token.nlb) {\n                    val = make_unary(AST_UnaryPostfix, S.token.value, val);\n                    val.start = start;\n                    val.end = S.token;\n                    next();\n                }\n                return val;\n            };\n            function make_unary(ctor, op, expr) {\n                return new ctor({\n                    \"operator\": op,\n                    \"expression\": expr\n                });\n            }\n            expr_op = function(left, min_prec, no_in) {\n                var op, not_in, prec, right, ret;\n                op = (is_(\"operator\")) ? S.token.value : null;\n                not_in = false;\n                if (op === \"!\" && peek().type === \"operator\" && peek().value === \"in\") {\n                    next();\n                    op = \"in\";\n                    not_in = true;\n                }\n                if (op === \"in\") {\n                    if (no_in) {\n                        op = null;\n                    } else {\n                        baselib_items[\"_$rapyd$_in()\"] = true;\n                    }\n                }\n                prec = (op !== null) ? PRECEDENCE[op] : null;\n                if (prec !== null && prec > min_prec) {\n                    next();\n                    right = expr_op(maybe_unary(true), prec, no_in);\n                    ret = new AST_Binary({\n                        \"start\": left.start,\n                        \"left\": left,\n                        \"operator\": op,\n                        \"right\": right,\n                        \"end\": right.end\n                    });\n                    if (not_in) {\n                        ret = new AST_UnaryPrefix({\n                            \"start\": left.start,\n                            \"operator\": \"!\",\n                            \"expression\": ret,\n                            \"end\": right.end\n                        });\n                    }\n                    return expr_op(ret, min_prec, no_in);\n                }\n                return left;\n            };\n            function expr_ops(no_in) {\n                return expr_op(maybe_unary(true), 0, no_in);\n            }\n            maybe_conditional = function(no_in) {\n                var start, expr, pystyle, ne, conditional, yes;\n                start = S.token;\n                expr = expr_ops(no_in);\n                if (is_(\"operator\", \"?\") || is_(\"keyword\", \"if\") && (S.in_parenthesized_expr || S.statement_starting_token !== S.token && !S.in_comprehension && !S.token.nlb)) {\n                    pystyle = is_(\"keyword\", \"if\");\n                    next();\n                    ne = expression(false);\n                    if (pystyle) {\n                        expect_token(\"keyword\", \"else\");\n                        conditional = new AST_Conditional({\n                            \"start\": start,\n                            \"condition\": ne,\n                            \"consequent\": expr,\n                            \"alternative\": expression(false, no_in),\n                            \"end\": peek()\n                        });\n                    } else {\n                        yes = ne;\n                        expect(\":\");\n                        conditional = new AST_Conditional({\n                            \"start\": start,\n                            \"condition\": expr,\n                            \"consequent\": yes,\n                            \"alternative\": expression(false, no_in),\n                            \"end\": peek()\n                        });\n                    }\n                    return conditional;\n                }\n                return expr;\n            };\n            function create_assign(data) {\n                if (data.right && data.right instanceof AST_Seq && (data.right.car instanceof AST_Assign || data.right.cdr instanceof AST_Assign) && data.operator !== \"=\") {\n                    token_error(data.start, \"Invalid assignment operator for chained assignment: \" + data.operator);\n                }\n                return new AST_Assign(data);\n            }\n            maybe_assign = function(no_in, only_plain_assignment) {\n                var start, left, val;\n                start = S.token;\n                left = maybe_conditional(no_in);\n                val = S.token.value;\n                if (is_(\"operator\") && ASSIGNMENT(val)) {\n                    if (only_plain_assignment && val !== \"=\") {\n                        croak(\"Invalid assignment operator for chained assignment: \" + val);\n                    }\n                    next();\n                    return create_assign({\n                        \"start\": start,\n                        \"left\": left,\n                        \"operator\": val,\n                        \"right\": maybe_assign(no_in, true),\n                        \"end\": prev()\n                    });\n                }\n                return left;\n            };\n            expression = function(commas, no_in) {\n                var start, expr, left;\n                start = S.token;\n                expr = maybe_assign(no_in);\n                function build_seq(a) {\n                    if (a.length === 1) {\n                        return a[0];\n                    }\n                    return new AST_Seq({\n                        \"start\": start,\n                        \"car\": a.shift(),\n                        \"cdr\": build_seq(a),\n                        \"end\": peek()\n                    });\n                }\n                if (commas) {\n                    left = [ expr ];\n                    while (is_(\"punc\", \",\") && !peek().nlb) {\n                        next();\n                        if (expr instanceof AST_Assign) {\n                            left[left.length-1] = left[left.length-1].left;\n                            return create_assign({\n                                \"start\": start,\n                                \"left\": (left.length === 1) ? left[0] : new AST_Array({\n                                    \"elements\": left\n                                }),\n                                \"operator\": expr.operator,\n                                \"right\": new AST_Seq({\n                                    \"car\": expr.right,\n                                    \"cdr\": expression(true, no_in)\n                                }),\n                                \"end\": peek()\n                            });\n                        }\n                        expr = maybe_assign(no_in);\n                        left.push(expr);\n                    }\n                    if (left.length > 1 && left[left.length-1] instanceof AST_Assign) {\n                        left[left.length-1] = left[left.length-1].left;\n                        return create_assign({\n                            \"start\": start,\n                            \"left\": new AST_Array({\n                                \"elements\": left\n                            }),\n                            \"operator\": expr.operator,\n                            \"right\": expr.right,\n                            \"end\": peek()\n                        });\n                    }\n                    return build_seq(left);\n                }\n                return expr;\n            };\n            function in_loop(cont) {\n                var ret;\n                S.in_loop += 1;\n                ret = cont();\n                S.in_loop -= 1;\n                return ret;\n            }\n            return function() {\n                var start, body, first_token, element, shebang, end, toplevel, seen_exports;\n                start = S.token;\n                body = _$rapyd$_list_decorate([]);\n                first_token = true;\n                while (!is_(\"eof\")) {\n                    element = statement();\n                    if (first_token && element instanceof AST_Directive && element.value.indexOf(\"#!\") === 0) {\n                        shebang = element.value;\n                    } else {\n                        body.push(element);\n                    }\n                    first_token = false;\n                }\n                end = prev();\n                toplevel = options.toplevel;\n                if (toplevel) {\n                    toplevel.body = toplevel.body.concat(body);\n                    toplevel.end = end;\n                } else {\n                    toplevel = new AST_Toplevel({\n                        \"start\": start,\n                        \"body\": body,\n                        \"shebang\": shebang,\n                        \"end\": end\n                    });\n                }\n                toplevel.nonlocalvars = scan_for_nonlocal_defs(toplevel.body);\n                toplevel.localvars = _$rapyd$_list_decorate([]);\n                toplevel.exports = _$rapyd$_list_decorate([]);\n                seen_exports = {};\n                function add_item(item, isvar) {\n                    var symbol;\n                    if (toplevel.nonlocalvars.indexOf(item) < 0) {\n                        symbol = new_symbol(AST_SymbolVar, item);\n                        if (isvar) {\n                            toplevel.localvars.push(symbol);\n                        }\n                        if (!Object.prototype.hasOwnProperty.call(seen_exports, item)) {\n                            toplevel.exports.push(symbol);\n                            seen_exports[item] = true;\n                        }\n                    }\n                }\n                scan_for_local_vars(toplevel.body).forEach(function(item) {\n                    add_item(item, true);\n                });\n                scan_for_top_level_callables(toplevel.body).forEach(function(item) {\n                    add_item(item, false);\n                });\n                toplevel.filename = options.filename;\n                toplevel.submodules = _$rapyd$_list_decorate([]);\n                toplevel.imported_module_ids = imported_module_ids;\n                toplevel.classes = scan_for_classes(toplevel.body);\n                toplevel.import_order = Object.keys(IMPORTED).length;\n                toplevel.module_id = module_id;\n                IMPORTED[module_id] = toplevel;\n                toplevel.imports = IMPORTED;\n                toplevel.baselib = baselib_items;\n                IMPORTING[module_id] = false;\n                return toplevel;\n            }();\n        }\n        _$rapyd$_modules[\"parse\"][\"COMPILER_VERSION\"] = COMPILER_VERSION;\n\n        _$rapyd$_modules[\"parse\"][\"BASELIB_ITEMS\"] = BASELIB_ITEMS;\n\n        _$rapyd$_modules[\"parse\"][\"BASELIB_FUNCS\"] = BASELIB_FUNCS;\n\n        _$rapyd$_modules[\"parse\"][\"BASELIB_ITERTOOLS\"] = BASELIB_ITERTOOLS;\n\n        _$rapyd$_modules[\"parse\"][\"NATIVE_CLASSES\"] = NATIVE_CLASSES;\n\n        _$rapyd$_modules[\"parse\"][\"ERROR_CLASSES\"] = ERROR_CLASSES;\n\n        _$rapyd$_modules[\"parse\"][\"COMMON_STATIC\"] = COMMON_STATIC;\n\n        _$rapyd$_modules[\"parse\"][\"UNARY_PREFIX\"] = UNARY_PREFIX;\n\n        _$rapyd$_modules[\"parse\"][\"ASSIGNMENT\"] = ASSIGNMENT;\n\n        _$rapyd$_modules[\"parse\"][\"PRECEDENCE\"] = PRECEDENCE;\n\n        _$rapyd$_modules[\"parse\"][\"STATEMENTS_WITH_LABELS\"] = STATEMENTS_WITH_LABELS;\n\n        _$rapyd$_modules[\"parse\"][\"ATOMIC_START_TOKEN\"] = ATOMIC_START_TOKEN;\n\n        _$rapyd$_modules[\"parse\"][\"compile_time_decorators\"] = compile_time_decorators;\n\n        _$rapyd$_modules[\"parse\"][\"has_simple_decorator\"] = has_simple_decorator;\n\n        _$rapyd$_modules[\"parse\"][\"has_setter_decorator\"] = has_setter_decorator;\n\n        _$rapyd$_modules[\"parse\"][\"parse\"] = parse;\n    })();\n\n    (function(){\n        var __name__ = \"output\";\n        var DANGEROUS;\n        var make_predicate = _$rapyd$_modules[\"utils\"].make_predicate;\n        var defaults = _$rapyd$_modules[\"utils\"].defaults;\n        var repeat_string = _$rapyd$_modules[\"utils\"].repeat_string;\n        var noop = _$rapyd$_modules[\"utils\"].noop;\n        \n        var is_identifier_char = _$rapyd$_modules[\"tokenizer\"].is_identifier_char;\n        \n        var COMPILER_VERSION = _$rapyd$_modules[\"parse\"].COMPILER_VERSION;\n        var PRECEDENCE = _$rapyd$_modules[\"parse\"].PRECEDENCE;\n        \n        var AST_Array = _$rapyd$_modules[\"ast\"].AST_Array;\n        var AST_Assign = _$rapyd$_modules[\"ast\"].AST_Assign;\n        var AST_BaseCall = _$rapyd$_modules[\"ast\"].AST_BaseCall;\n        var AST_Binary = _$rapyd$_modules[\"ast\"].AST_Binary;\n        var AST_BlockStatement = _$rapyd$_modules[\"ast\"].AST_BlockStatement;\n        var AST_Break = _$rapyd$_modules[\"ast\"].AST_Break;\n        var AST_Catch = _$rapyd$_modules[\"ast\"].AST_Catch;\n        var AST_Class = _$rapyd$_modules[\"ast\"].AST_Class;\n        var AST_ClassCall = _$rapyd$_modules[\"ast\"].AST_ClassCall;\n        var AST_Conditional = _$rapyd$_modules[\"ast\"].AST_Conditional;\n        var AST_Const = _$rapyd$_modules[\"ast\"].AST_Const;\n        var AST_Constant = _$rapyd$_modules[\"ast\"].AST_Constant;\n        var AST_Continue = _$rapyd$_modules[\"ast\"].AST_Continue;\n        var AST_Debugger = _$rapyd$_modules[\"ast\"].AST_Debugger;\n        var AST_Definitions = _$rapyd$_modules[\"ast\"].AST_Definitions;\n        var AST_Directive = _$rapyd$_modules[\"ast\"].AST_Directive;\n        var AST_Do = _$rapyd$_modules[\"ast\"].AST_Do;\n        var AST_Dot = _$rapyd$_modules[\"ast\"].AST_Dot;\n        var AST_EmptyStatement = _$rapyd$_modules[\"ast\"].AST_EmptyStatement;\n        var AST_Except = _$rapyd$_modules[\"ast\"].AST_Except;\n        var AST_Exit = _$rapyd$_modules[\"ast\"].AST_Exit;\n        var AST_ExpressiveObject = _$rapyd$_modules[\"ast\"].AST_ExpressiveObject;\n        var AST_Finally = _$rapyd$_modules[\"ast\"].AST_Finally;\n        var AST_ForIn = _$rapyd$_modules[\"ast\"].AST_ForIn;\n        var AST_ForJS = _$rapyd$_modules[\"ast\"].AST_ForJS;\n        var AST_Function = _$rapyd$_modules[\"ast\"].AST_Function;\n        var AST_Hole = _$rapyd$_modules[\"ast\"].AST_Hole;\n        var AST_If = _$rapyd$_modules[\"ast\"].AST_If;\n        var AST_Imports = _$rapyd$_modules[\"ast\"].AST_Imports;\n        var AST_Infinity = _$rapyd$_modules[\"ast\"].AST_Infinity;\n        var AST_Jump = _$rapyd$_modules[\"ast\"].AST_Jump;\n        var AST_Lambda = _$rapyd$_modules[\"ast\"].AST_Lambda;\n        var AST_ListComprehension = _$rapyd$_modules[\"ast\"].AST_ListComprehension;\n        var AST_LoopControl = _$rapyd$_modules[\"ast\"].AST_LoopControl;\n        var AST_Method = _$rapyd$_modules[\"ast\"].AST_Method;\n        var AST_NaN = _$rapyd$_modules[\"ast\"].AST_NaN;\n        var AST_New = _$rapyd$_modules[\"ast\"].AST_New;\n        var AST_Node = _$rapyd$_modules[\"ast\"].AST_Node;\n        var AST_Number = _$rapyd$_modules[\"ast\"].AST_Number;\n        var AST_Object = _$rapyd$_modules[\"ast\"].AST_Object;\n        var AST_ObjectKeyVal = _$rapyd$_modules[\"ast\"].AST_ObjectKeyVal;\n        var AST_ObjectProperty = _$rapyd$_modules[\"ast\"].AST_ObjectProperty;\n        var AST_PropAccess = _$rapyd$_modules[\"ast\"].AST_PropAccess;\n        var AST_RegExp = _$rapyd$_modules[\"ast\"].AST_RegExp;\n        var AST_Return = _$rapyd$_modules[\"ast\"].AST_Return;\n        var AST_Scope = _$rapyd$_modules[\"ast\"].AST_Scope;\n        var AST_Set = _$rapyd$_modules[\"ast\"].AST_Set;\n        var AST_Seq = _$rapyd$_modules[\"ast\"].AST_Seq;\n        var AST_SimpleStatement = _$rapyd$_modules[\"ast\"].AST_SimpleStatement;\n        var AST_Splice = _$rapyd$_modules[\"ast\"].AST_Splice;\n        var AST_Statement = _$rapyd$_modules[\"ast\"].AST_Statement;\n        var AST_StatementWithBody = _$rapyd$_modules[\"ast\"].AST_StatementWithBody;\n        var AST_String = _$rapyd$_modules[\"ast\"].AST_String;\n        var AST_Sub = _$rapyd$_modules[\"ast\"].AST_Sub;\n        var AST_ItemAccess = _$rapyd$_modules[\"ast\"].AST_ItemAccess;\n        var AST_Symbol = _$rapyd$_modules[\"ast\"].AST_Symbol;\n        var AST_SymbolRef = _$rapyd$_modules[\"ast\"].AST_SymbolRef;\n        var AST_This = _$rapyd$_modules[\"ast\"].AST_This;\n        var AST_Throw = _$rapyd$_modules[\"ast\"].AST_Throw;\n        var AST_Toplevel = _$rapyd$_modules[\"ast\"].AST_Toplevel;\n        var AST_Try = _$rapyd$_modules[\"ast\"].AST_Try;\n        var AST_Unary = _$rapyd$_modules[\"ast\"].AST_Unary;\n        var AST_UnaryPostfix = _$rapyd$_modules[\"ast\"].AST_UnaryPostfix;\n        var AST_UnaryPrefix = _$rapyd$_modules[\"ast\"].AST_UnaryPrefix;\n        var AST_Undefined = _$rapyd$_modules[\"ast\"].AST_Undefined;\n        var AST_Var = _$rapyd$_modules[\"ast\"].AST_Var;\n        var AST_VarDef = _$rapyd$_modules[\"ast\"].AST_VarDef;\n        var AST_Verbatim = _$rapyd$_modules[\"ast\"].AST_Verbatim;\n        var AST_While = _$rapyd$_modules[\"ast\"].AST_While;\n        var AST_With = _$rapyd$_modules[\"ast\"].AST_With;\n        var AST_Yield = _$rapyd$_modules[\"ast\"].AST_Yield;\n        var TreeWalker = _$rapyd$_modules[\"ast\"].TreeWalker;\n        \n        DANGEROUS = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n        function OutputStream(options) {\n            var indentation, current_col, current_line, current_pos, OUTPUT, IMPORTED, might_need_space, might_need_semicolon, last, requireSemicolonChars, space, indent, with_indent, newline, semicolon, add_mapping, stack;\n            options = defaults(options, {\n                \"indent_start\": 0,\n                \"indent_level\": 4,\n                \"quote_keys\": false,\n                \"space_colon\": true,\n                \"ascii_only\": false,\n                \"width\": 80,\n                \"max_line_len\": 32e3,\n                \"ie_proof\": true,\n                \"beautify\": false,\n                \"source_map\": null,\n                \"bracketize\": false,\n                \"semicolons\": true,\n                \"comments\": false,\n                \"preserve_line\": false,\n                \"omit_baselib\": false,\n                \"baselib\": null,\n                \"private_scope\": true,\n                \"auto_bind\": false,\n                \"js_version\": 5,\n                \"write_name\": true\n            }, true);\n            indentation = 0;\n            current_col = 0;\n            current_line = 1;\n            current_pos = 0;\n            OUTPUT = \"\";\n            IMPORTED = {};\n            function to_ascii(str_, identifier) {\n                return str_.replace(/[\\u0080-\\uffff]/g, function(ch) {\n                    var code;\n                    code = ch.charCodeAt(0).toString(16);\n                    if (code.length <= 2 && !identifier) {\n                        while (code.length < 2) {\n                            code = \"0\" + code;\n                        }\n                        return \"\\\\x\" + code;\n                    } else {\n                        while (code.length < 4) {\n                            code = \"0\" + code;\n                        }\n                        return \"\\\\u\" + code;\n                    }\n                });\n            }\n            function encode_string(str_) {\n                return JSON.stringify(str_).replace(DANGEROUS, function(a) {\n                    return \"\\\\u\" + a.charCodeAt(0).toString(16);\n                });\n            }\n            function make_name(name) {\n                name = name.toString();\n                if (options.ascii_only) {\n                    name = to_ascii(name, true);\n                }\n                return name;\n            }\n            function make_indent(back) {\n                return repeat_string(\" \", options.indent_start + indentation - back * options.indent_level);\n            }\n            might_need_space = false;\n            might_need_semicolon = false;\n            last = null;\n            function last_char() {\n                return last.charAt(last.length - 1);\n            }\n            function maybe_newline() {\n                if (options.max_line_len && current_col > options.max_line_len) {\n                    print_(\"\\n\");\n                }\n            }\n            requireSemicolonChars = make_predicate(\"( [ + * / - , .\");\n            function print_(str_) {\n                var ch, target_line, prev, a, n;\n                str_ = String(str_);\n                ch = str_.charAt(0);\n                if (might_need_semicolon) {\n                    if ((!ch || \";}\".indexOf(ch) < 0) && !/[;]$/.test(last)) {\n                        if (options.semicolons || requireSemicolonChars(ch)) {\n                            OUTPUT += \";\";\n                            current_col += 1;\n                            current_pos += 1;\n                        } else {\n                            OUTPUT += \"\\n\";\n                            current_pos += 1;\n                            current_line += 1;\n                            current_col = 0;\n                        }\n                        if (!options.beautify) {\n                            might_need_space = false;\n                        }\n                    }\n                    might_need_semicolon = false;\n                    maybe_newline();\n                }\n                if (!options.beautify && options.preserve_line && stack[stack.length - 1]) {\n                    target_line = stack[stack.length - 1].start.line;\n                    while (current_line < target_line) {\n                        OUTPUT += \"\\n\";\n                        current_pos += 1;\n                        current_line += 1;\n                        current_col = 0;\n                        might_need_space = false;\n                    }\n                }\n                if (might_need_space) {\n                    prev = last_char();\n                    if (is_identifier_char(prev) && (is_identifier_char(ch) || ch === \"\\\\\") || /^[\\+\\-\\/]$/.test(ch) && ch === prev) {\n                        OUTPUT += \" \";\n                        current_col += 1;\n                        current_pos += 1;\n                    }\n                    might_need_space = false;\n                }\n                a = str_.split(/\\r?\\n/);\n                n = a.length - 1;\n                current_line += n;\n                if (n === 0) {\n                    current_col += a[n].length;\n                } else {\n                    current_col = a[n].length;\n                }\n                current_pos += str_.length;\n                last = str_;\n                OUTPUT += str_;\n            }\n            space = (options.beautify) ? function() {\n                print_(\" \");\n            } : function() {\n                might_need_space = true;\n            };\n            indent = (options.beautify) ? function(half) {\n                if (options.beautify) {\n                    print_(make_indent((half) ? .5 : 0));\n                }\n            } : noop;\n            with_indent = (options.beautify) ? function(col, cont) {\n                var save_indentation, ret;\n                if (col === true) {\n                    col = next_indent();\n                }\n                save_indentation = indentation;\n                indentation = col;\n                ret = cont();\n                indentation = save_indentation;\n                return ret;\n            } : function(col, cont) {\n                return cont();\n            };\n            function set_indentation(val) {\n                if (options.beautify) {\n                    indentation = val;\n                }\n            }\n            newline = (options.beautify) ? function() {\n                print_(\"\\n\");\n            } : noop;\n            semicolon = (options.beautify) ? function() {\n                print_(\";\");\n            } : function() {\n                might_need_semicolon = true;\n            };\n            function force_semicolon() {\n                might_need_semicolon = false;\n                print_(\";\");\n            }\n            function next_indent() {\n                return indentation + options.indent_level;\n            }\n            function spaced() {\n                for (var i=0; i < arguments.length; i++) {\n                    if (i > 0) {\n                        space();\n                    }\n                    if (typeof arguments[i].print === \"function\") {\n                        arguments[i].print(this);\n                    } else {\n                        print_(arguments[i]);\n                    }\n                }\n            }\n            function end_statement() {\n                semicolon();\n                newline();\n            }\n            function with_block(cont) {\n                var ret;\n                ret = null;\n                print_(\"{\");\n                newline();\n                with_indent(next_indent(), function() {\n                    ret = cont();\n                });\n                indent();\n                print_(\"}\");\n                return ret;\n            }\n            function with_parens(cont) {\n                var ret;\n                print_(\"(\");\n                ret = cont();\n                print_(\")\");\n                return ret;\n            }\n            function with_square(cont) {\n                var ret;\n                print_(\"[\");\n                ret = cont();\n                print_(\"]\");\n                return ret;\n            }\n            function comma() {\n                print_(\",\");\n                space();\n            }\n            function colon() {\n                print_(\":\");\n                if (options.space_colon) {\n                    space();\n                }\n            }\n            add_mapping = (options.source_map) ? function(token, name) {\n                try {\n                    if (token) {\n                        options.source_map.add(token.file || \"?\", current_line, current_col, token.line, token.col, (!name && token.type === \"name\") ? token.value : name);\n                    }\n                } catch (_$rapyd$_Exception) {\n                    AST_Node.warn(\"Couldn't figure out mapping for {file}:{line},{col} → {cline},{ccol} [{name}]\", {\n                        \"file\": token.file,\n                        \"line\": token.line,\n                        \"col\": token.col,\n                        \"cline\": current_line,\n                        \"ccol\": current_col,\n                        \"name\": name || \"\"\n                    });\n                }\n            } : noop;\n            function dump_baselib(key) {\n                var is_func, v, ckey;\n                indent();\n                is_func = key.substr(key.length - 2) === \"()\";\n                v = (options.js_version > 5) ? \"const\" : \"var\";\n                if (is_func) {\n                    ckey = key.substr(0, key.length - 2);\n                    spaced(v, ckey, \"=\", \"(\");\n                }\n                print_(options.baselib[key]);\n                if (is_func) {\n                    print_(\")()\");\n                }\n                semicolon();\n                newline();\n            }\n            function dump_yield() {\n                var code, ci;\n                indent();\n                spaced(\"var\", \"_$rapyd$_regenerator\", \"=\", \"{}\");\n                end_statement();\n                code = regenerate(false, options.beautify);\n                if (options.beautify) {\n                    code = code.replace(/\\/\\/.*$/gm, \"\\n\").replace(/^\\s*$/gm, \"\");\n                    ci = make_indent(0);\n                    code = (function() {\n                        var _$rapyd$_Iter = _$rapyd$_Iterable(code.split(\"\\n\")), _$rapyd$_Result = [], x;\n                        for (var _$rapyd$_Index = 0; _$rapyd$_Index < _$rapyd$_Iter.length; _$rapyd$_Index++) {\n                            x = _$rapyd$_Iter[_$rapyd$_Index];\n                            _$rapyd$_Result.push(ci + x);\n                        }\n                        _$rapyd$_Result = _$rapyd$_list_constructor(_$rapyd$_Result);\n                        return _$rapyd$_Result;\n                    })().join(\"\\n\");\n                }\n                print_(code + \"(_$rapyd$_regenerator)\");\n                end_statement();\n            }\n            function prologue(module_) {\n                var v, baselib_items, k, deps, lib;\n                if (options.omit_baselib) {\n                    return;\n                }\n                indent();\n                v = (options.js_version > 5) ? \"const\" : \"var\";\n                [print_(v), space()];\n                spaced.apply(null, \"_$rapyd$_iterator_symbol = (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") ? Symbol.iterator : \\\"iterator-Symbol-5d0927e5554349048cf0e3762a228256\\\"\".split(\" \"));\n                end_statement();\n                [indent(), print_(v), space()];\n                spaced.apply(null, \"_$rapyd$_kwargs_symbol = (typeof Symbol === \\\"function\\\") ? Symbol(\\\"kwargs-object\\\") : \\\"kwargs-object-Symbol-5d0927e5554349048cf0e3762a228256\\\"\".split(\" \"));\n                end_statement();\n                [indent(), spaced(\"var\", \"_$rapyd$_cond_temp\"), end_statement()];\n                [indent(), spaced(\"var\", \"_$rapyd$_object_counter\", \"=\", \"0\"), end_statement()];\n                baselib_items = (function() {\n                    var _$rapyd$_Iter = _$rapyd$_Iterable(module_.baselib), _$rapyd$_Result = {}, k;\n                    for (var _$rapyd$_Index = 0; _$rapyd$_Index < _$rapyd$_Iter.length; _$rapyd$_Index++) {\n                        k = _$rapyd$_Iter[_$rapyd$_Index];\n                        _$rapyd$_Result[k] = (true);\n                    }\n                    return _$rapyd$_Result;\n                })();\n                baselib_items[\"errors\"] = true;\n                baselib_items[\"containers\"] = true;\n                baselib_items[\"builtins\"] = true;\n                baselib_items[\"str\"] = true;\n                deps = options.baselib[\"#dependencies#\"];\n                var _$rapyd$_Iter53 = _$rapyd$_Iterable(baselib_items);\n                for (var _$rapyd$_Index53 = 0; _$rapyd$_Index53 < _$rapyd$_Iter53.length; _$rapyd$_Index53++) {\n                    lib = _$rapyd$_Iter53[_$rapyd$_Index53];\n                    if (Object.prototype.hasOwnProperty.call(deps, lib)) {\n                        Object.keys(deps[lib]).forEach(function(k) {\n                            baselib_items[k] = true;\n                        });\n                    }\n                }\n                var _$rapyd$_Iter54 = _$rapyd$_Iterable(baselib_items);\n                for (var _$rapyd$_Index54 = 0; _$rapyd$_Index54 < _$rapyd$_Iter54.length; _$rapyd$_Index54++) {\n                    lib = _$rapyd$_Iter54[_$rapyd$_Index54];\n                    if (options.js_version >= 6 && (lib === \"iterable\" || lib === \"yield\")) {\n                        continue;\n                    }\n                    if (lib === \"yield\") {\n                        dump_yield();\n                    } else {\n                        dump_baselib(lib);\n                    }\n                }\n            }\n            function get() {\n                return OUTPUT;\n            }\n            function assign_var(name) {\n                if (typeof name === \"string\") {\n                    print_(name);\n                } else {\n                    name.print(this);\n                }\n                space();\n                print_(\"=\");\n                space();\n            }\n            stack = _$rapyd$_list_decorate([]);\n            return {\n                \"index_counter\": 0,\n                \"with_counter\": 0,\n                \"options\": options,\n                \"get\": get,\n                \"toString\": get,\n                \"indent\": indent,\n                \"indentation\": function() {\n                    return indentation;\n                },\n                \"set_indentation\": set_indentation,\n                \"make_indent\": make_indent,\n                \"current_width\": function() {\n                    return current_col - indentation;\n                },\n                \"should_break\": function() {\n                    return options.width && this.current_width() >= options.width;\n                },\n                \"newline\": newline,\n                \"print\": print_,\n                \"space\": space,\n                \"comma\": comma,\n                \"colon\": colon,\n                \"last\": function() {\n                    return last;\n                },\n                \"semicolon\": semicolon,\n                \"force_semicolon\": force_semicolon,\n                \"to_ascii\": to_ascii,\n                \"print_name\": function(name) {\n                    print_(make_name(name));\n                },\n                \"print_string\": function(str_) {\n                    print_(encode_string(str_));\n                },\n                \"next_indent\": next_indent,\n                \"with_indent\": with_indent,\n                \"with_block\": with_block,\n                \"with_parens\": with_parens,\n                \"spaced\": spaced,\n                \"end_statement\": end_statement,\n                \"with_square\": with_square,\n                \"add_mapping\": add_mapping,\n                \"assign\": assign_var,\n                \"prologue\": prologue,\n                \"import\": function(module_) {\n                    if (!Object.prototype.hasOwnProperty.call(IMPORTED, module_.key)) {\n                        IMPORTED[module_.key] = module_;\n                    }\n                },\n                \"is_main\": function() {\n                    return OUTPUT.length === 0;\n                },\n                \"option\": function(opt) {\n                    return options[opt];\n                },\n                \"line\": function() {\n                    return current_line;\n                },\n                \"col\": function() {\n                    return current_col;\n                },\n                \"pos\": function() {\n                    return current_pos;\n                },\n                \"push_node\": function(node) {\n                    stack.push(node);\n                },\n                \"pop_node\": function() {\n                    return stack.pop();\n                },\n                \"stack\": function() {\n                    return stack;\n                },\n                \"parent\": function(n) {\n                    return stack[stack.length - 2 - (n || 0)];\n                }\n            };\n        }\n        function codegen() {\n            function DEFPRINT(nodetype, generator) {\n                nodetype.DEFMETHOD(\"_codegen\", generator);\n            }\n            AST_Node.DEFMETHOD(\"print\", function(stream, force_parens) {\n                var self, generator;\n                self = this;\n                generator = self._codegen;\n                stream.push_node(self);\n                if (force_parens || self.needs_parens(stream)) {\n                    stream.with_parens(function() {\n                        self.add_comments(stream);\n                        self.add_source_map(stream);\n                        generator(self, stream);\n                    });\n                } else {\n                    self.add_comments(stream);\n                    self.add_source_map(stream);\n                    generator(self, stream);\n                }\n                stream.pop_node();\n            });\n            AST_Node.DEFMETHOD(\"print_to_string\", function(options) {\n                var s;\n                s = OutputStream(options);\n                this.print(s);\n                return s.get();\n            });\n            AST_Node.DEFMETHOD(\"add_comments\", function(output) {\n                var c, self, start, comments;\n                c = output.option(\"comments\");\n                self = this;\n                if (c) {\n                    start = self.start;\n                    if (start && !start._comments_dumped) {\n                        start._comments_dumped = true;\n                        comments = start.comments_before;\n                        if (self instanceof AST_Exit && self.value && self.value.start.comments_before.length > 0) {\n                            comments = (comments || _$rapyd$_list_decorate([])).concat(self.value.start.comments_before);\n                            self.value.start.comments_before = _$rapyd$_list_decorate([]);\n                        }\n                        if (c.test) {\n                            comments = comments.filter(function(comment) {\n                                return c.test(comment.value);\n                            });\n                        } else if (typeof c === \"function\") {\n                            comments = comments.filter(function(comment) {\n                                return c(self, comment);\n                            });\n                        }\n                        comments.forEach(function(c) {\n                            if (c.type === \"comment1\") {\n                                output.print(\"//\" + c.value + \"\\n\");\n                                output.indent();\n                            } else if (c.type === \"comment2\") {\n                                output.print(\"/*\" + c.value + \"*/\");\n                                if (start.nlb) {\n                                    output.print(\"\\n\");\n                                    output.indent();\n                                } else {\n                                    output.space();\n                                }\n                            }\n                        });\n                    }\n                }\n            });\n            function PARENS(nodetype, func) {\n                nodetype.DEFMETHOD(\"needs_parens\", func);\n            }\n            PARENS(AST_Node, function() {\n                return false;\n            });\n            PARENS(AST_Function, function(output) {\n                return first_in_statement(output);\n            });\n            PARENS(AST_Object, function(output) {\n                return first_in_statement(output);\n            });\n            PARENS(AST_Unary, function(output) {\n                var p;\n                p = output.parent();\n                return p instanceof AST_PropAccess && p.expression === this;\n            });\n            PARENS(AST_Seq, function(output) {\n                var p;\n                p = output.parent();\n                return p instanceof AST_Unary || p instanceof AST_VarDef || p instanceof AST_Dot || p instanceof AST_ObjectProperty || p instanceof AST_Conditional;\n            });\n            PARENS(AST_Binary, function(output) {\n                var p, po, pp, so, sp;\n                p = output.parent();\n                if (p instanceof AST_BaseCall && p.expression === this) {\n                    return true;\n                }\n                if (p instanceof AST_Unary) {\n                    return true;\n                }\n                if (p instanceof AST_PropAccess && p.expression === this) {\n                    return true;\n                }\n                if (p instanceof AST_Binary) {\n                    po = p.operator;\n                    pp = PRECEDENCE[po];\n                    so = this.operator;\n                    sp = PRECEDENCE[so];\n                    if (pp > sp || pp === sp && this === p.right && !(so === po && (so === \"*\" || so === \"&&\" || so === \"||\"))) {\n                        return true;\n                    }\n                }\n            });\n            PARENS(AST_PropAccess, function(output) {\n                var p;\n                p = output.parent();\n                if (p instanceof AST_New && p.expression === this) {\n                    try {\n                        this.walk(new TreeWalker(function(node) {\n                            if (node instanceof AST_BaseCall) {\n                                throw p;\n                            }\n                        }));\n                    } catch (_$rapyd$_Exception) {\n                        var ex = _$rapyd$_Exception;\n                        if (ex !== p) {\n                            throw ex;\n                        }\n                        return true;\n                    }\n                }\n            });\n            PARENS(AST_BaseCall, function(output) {\n                var p;\n                p = output.parent();\n                return p instanceof AST_New && p.expression === this;\n            });\n            PARENS(AST_New, function(output) {\n                var p;\n                p = output.parent();\n                if (no_constructor_parens(this, output) && (p instanceof AST_PropAccess || p instanceof AST_BaseCall && p.expression === this)) {\n                    return true;\n                }\n            });\n            PARENS(AST_Number, function(output) {\n                var p;\n                p = output.parent();\n                if (this.getValue() < 0 && p instanceof AST_PropAccess && p.expression === this) {\n                    return true;\n                }\n            });\n            PARENS(AST_NaN, function(output) {\n                var p;\n                p = output.parent();\n                if (p instanceof AST_PropAccess && p.expression === this) {\n                    return true;\n                }\n            });\n            function assign_and_conditional_paren_rules(output) {\n                var p;\n                p = output.parent();\n                if (p instanceof AST_Unary) {\n                    return true;\n                }\n                if (p instanceof AST_Binary && !(p instanceof AST_Assign)) {\n                    return true;\n                }\n                if (p instanceof AST_BaseCall && p.expression === this) {\n                    return true;\n                }\n                if (p instanceof AST_Conditional && p.condition === this) {\n                    return true;\n                }\n                if (p instanceof AST_PropAccess && p.expression === this) {\n                    return true;\n                }\n            }\n            PARENS(AST_Assign, assign_and_conditional_paren_rules);\n            PARENS(AST_Conditional, assign_and_conditional_paren_rules);\n            DEFPRINT(AST_Directive, function(self, output) {\n                output.print_string(self.value);\n                output.semicolon();\n            });\n            DEFPRINT(AST_Debugger, function(self, output) {\n                output.print(\"debugger\");\n                output.semicolon();\n            });\n            function display_body(body, is_toplevel, output) {\n                var last;\n                last = body.length - 1;\n                body.forEach(function(stmt, i) {\n                    if (!(stmt instanceof AST_EmptyStatement) && !(stmt instanceof AST_Definitions)) {\n                        output.indent();\n                        stmt.print(output);\n                        if (!(i === last && is_toplevel)) {\n                            output.newline();\n                        }\n                    }\n                });\n            }\n            function bind_methods(methods, output) {\n                var arg;\n                if (methods) {\n                    var _$rapyd$_Iter55 = _$rapyd$_Iterable(methods);\n                    for (var _$rapyd$_Index55 = 0; _$rapyd$_Index55 < _$rapyd$_Iter55.length; _$rapyd$_Index55++) {\n                        arg = _$rapyd$_Iter55[_$rapyd$_Index55];\n                        output.indent();\n                        output.print(\"this.\");\n                        output.assign(arg);\n                        output.print(\"_$rapyd$_bind\");\n                        output.with_parens(function() {\n                            output.print(\"this.\");\n                            output.print(arg);\n                            output.comma();\n                            output.print(\"this\");\n                        });\n                        output.semicolon();\n                        output.newline();\n                    }\n                }\n            }\n            function write_imports(module, output) {\n                var imports, import_id, nonlocalvars, name, module_;\n                imports = _$rapyd$_list_decorate([]);\n                var _$rapyd$_Iter56 = _$rapyd$_Iterable(Object.keys(module.imports));\n                for (var _$rapyd$_Index56 = 0; _$rapyd$_Index56 < _$rapyd$_Iter56.length; _$rapyd$_Index56++) {\n                    import_id = _$rapyd$_Iter56[_$rapyd$_Index56];\n                    imports.push(module.imports[import_id]);\n                }\n                imports.sort(function(a, b) {\n                    var _$rapyd$_unpack;\n                    _$rapyd$_unpack = [a.import_order, b.import_order];\n                    a = _$rapyd$_unpack[0];\n                    b = _$rapyd$_unpack[1];\n                    return (a < b) ? -1 : (a > b) ? 1 : 0;\n                });\n                if (imports.length > 1) {\n                    output.indent();\n                    output.print(\"var _$rapyd$_modules = {};\");\n                    output.newline();\n                }\n                nonlocalvars = {};\n                var _$rapyd$_Iter57 = _$rapyd$_Iterable(imports);\n                for (var _$rapyd$_Index57 = 0; _$rapyd$_Index57 < _$rapyd$_Iter57.length; _$rapyd$_Index57++) {\n                    module_ = _$rapyd$_Iter57[_$rapyd$_Index57];\n                    var _$rapyd$_Iter58 = _$rapyd$_Iterable(module_.nonlocalvars);\n                    for (var _$rapyd$_Index58 = 0; _$rapyd$_Index58 < _$rapyd$_Iter58.length; _$rapyd$_Index58++) {\n                        name = _$rapyd$_Iter58[_$rapyd$_Index58];\n                        nonlocalvars[name] = true;\n                    }\n                }\n                nonlocalvars = Object.getOwnPropertyNames(nonlocalvars).join(\", \");\n                if (nonlocalvars.length) {\n                    output.indent();\n                    output.print(\"var \" + nonlocalvars);\n                    output.semicolon();\n                    output.newline();\n                }\n                var _$rapyd$_Iter59 = _$rapyd$_Iterable(imports);\n                for (var _$rapyd$_Index59 = 0; _$rapyd$_Index59 < _$rapyd$_Iter59.length; _$rapyd$_Index59++) {\n                    module_ = _$rapyd$_Iter59[_$rapyd$_Index59];\n                    if (module_.module_id !== \"__main__\") {\n                        output.indent();\n                        output.print(\"_$rapyd$_modules[\\\"\");\n                        output.print(module_.module_id);\n                        output.print(\"\\\"] = {}\");\n                        output.semicolon();\n                        output.newline();\n                    }\n                }\n                var _$rapyd$_Iter60 = _$rapyd$_Iterable(imports);\n                for (var _$rapyd$_Index60 = 0; _$rapyd$_Index60 < _$rapyd$_Iter60.length; _$rapyd$_Index60++) {\n                    module_ = _$rapyd$_Iter60[_$rapyd$_Index60];\n                    if (module_.module_id !== \"__main__\") {\n                        print_module(module_, output);\n                    }\n                }\n            }\n            function write_main_name(output) {\n                if (output.option(\"write_name\")) {\n                    output.newline();\n                    output.indent();\n                    output.print(\"var __name__ = \\\"__main__\\\"\");\n                    output.semicolon();\n                    output.newline();\n                    output.newline();\n                }\n            }\n            function display_complex_body(node, is_toplevel, output) {\n                var offset, a, kw, i, _$rapyd$_unpack, c, arg, dname, nargs;\n                offset = 0;\n                if (node instanceof AST_Method && !node.static) {\n                    output.indent();\n                    output.print(\"var\");\n                    output.space();\n                    output.assign(node.argnames[0]);\n                    output.print(\"this\");\n                    output.semicolon();\n                    output.newline();\n                    offset += 1;\n                }\n                if (node instanceof AST_Scope) {\n                    if (node.argnames) {\n                        if (node.argnames.is_simple_func !== true) {\n                            a = node.argnames;\n                            kw = \"arguments[arguments.length-1]\";\n                            var _$rapyd$_Iter61 = _$rapyd$_Iterable(enumerate(a));\n                            for (var _$rapyd$_Index61 = 0; _$rapyd$_Index61 < _$rapyd$_Iter61.length; _$rapyd$_Index61++) {\n                                _$rapyd$_unpack = _$rapyd$_Iter61[_$rapyd$_Index61];\n                                c = _$rapyd$_unpack[0];\n                                arg = _$rapyd$_unpack[1];\n                                i = c - offset;\n                                if (i >= 0) {\n                                    output.indent();\n                                    output.print(\"var\");\n                                    output.space();\n                                    output.assign(arg);\n                                    if (Object.prototype.hasOwnProperty.call(a.defaults, arg.name)) {\n                                        output.spaced(\"(arguments[\" + i + \"]\", \"===\", \"undefined\", \"||\", \"(\", i, \"===\", \"arguments.length-1\", \"&&\", kw, \"!==\", \"null\", \"&&\", \"typeof\", kw, \"===\", \"\\\"object\\\"\", \"&&\", kw, \"[_$rapyd$_kwargs_symbol]\", \"===\", \"true))\", \"?\", \"\");\n                                        output.with_parens(function() {\n                                            a.defaults[arg.name].print(output);\n                                        });\n                                        output.space();\n                                        output.print(\":\");\n                                        output.space();\n                                    } else {\n                                        output.spaced(\"(\", i, \"===\", \"arguments.length-1\", \"&&\", kw, \"!==\", \"null\", \"&&\", \"typeof\", kw, \"===\", \"\\\"object\\\"\", \"&&\", kw, \"[_$rapyd$_kwargs_symbol]\", \"===\", \"true)\", \"?\", \"undefined\", \":\", \"\");\n                                    }\n                                    output.print(\"arguments[\" + i + \"]\");\n                                    output.end_statement();\n                                }\n                            }\n                            if (a.kwargs || a.has_defaults) {\n                                kw = (a.kwargs) ? a.kwargs.name : \"_$rapyd$_kwargs_obj\";\n                                output.indent();\n                                output.spaced(\"var\", kw, \"=\", \"arguments[arguments.length-1]\");\n                                output.end_statement();\n                                output.indent();\n                                output.spaced(\"if\", \"(\" + kw, \"===\", \"null\", \"||\", \"typeof\", kw, \"!==\", \"\\\"object\\\"\", \"||\", kw, \"[_$rapyd$_kwargs_symbol]\", \"!==\", \"true)\", kw, \"=\", \"{}\");\n                                output.end_statement();\n                                if (a.has_defaults) {\n                                    var _$rapyd$_Iter62 = _$rapyd$_Iterable(Object.keys(a.defaults));\n                                    for (var _$rapyd$_Index62 = 0; _$rapyd$_Index62 < _$rapyd$_Iter62.length; _$rapyd$_Index62++) {\n                                        dname = _$rapyd$_Iter62[_$rapyd$_Index62];\n                                        output.indent();\n                                        output.spaced(\"if\", \"(Object.prototype.hasOwnProperty.call(\" + kw + \",\", \"\\\"\" + dname + \"\\\"))\");\n                                        output.with_block(function() {\n                                            output.indent();\n                                            output.spaced(dname, \"=\", kw + \".\" + dname);\n                                            output.end_statement();\n                                            if (a.kwargs) {\n                                                output.indent();\n                                                output.spaced(\"delete\", kw + \".\" + dname);\n                                                output.end_statement();\n                                            }\n                                        });\n                                        output.newline();\n                                    }\n                                }\n                            }\n                            if (a.starargs !== undefined) {\n                                nargs = a.length - offset;\n                                output.indent();\n                                output.spaced(\"var\", a.starargs.name, \"=\", \"Array.prototype.slice.call(arguments,\", nargs, \")\");\n                                output.end_statement();\n                                output.indent();\n                                output.spaced(\"if\", \"(\" + kw, \"!==\", \"null\", \"&&\", \"typeof\", kw, \"===\", \"\\\"object\\\"\", \"&&\", kw, \"[_$rapyd$_kwargs_symbol]\", \"===\", \"true)\", a.starargs.name, \".pop()\");\n                                output.end_statement();\n                            }\n                        }\n                    }\n                    if (output.option(\"auto_bind\") && node.name && node.name.name === \"__init__\") {\n                        output.indent();\n                        output.print(\"_$rapyd$_rebind_all\");\n                        output.with_parens(function() {\n                            output.print(\"this\");\n                            output.comma();\n                            output.print(\"true\");\n                        });\n                        output.semicolon();\n                        output.newline();\n                        bind_methods(node.bound, output);\n                    }\n                    declare_vars(node.localvars, output);\n                } else if (node instanceof AST_Except) {\n                    if (node.argname) {\n                        output.indent();\n                        output.print(\"var\");\n                        output.space();\n                        output.assign(node.argname);\n                        output.print(\"_$rapyd$_Exception\");\n                        output.semicolon();\n                        output.newline();\n                    }\n                }\n                display_body(node.body, is_toplevel, output);\n            }\n            function declare_vars(vars, output) {\n                if (vars.length) {\n                    output.indent();\n                    output.print(\"var\");\n                    output.space();\n                    vars.forEach(function(arg, i) {\n                        if (i) {\n                            output.comma();\n                        }\n                        arg.print(output);\n                    });\n                    output.semicolon();\n                    output.newline();\n                }\n            }\n            function declare_exports(module_id, exports, submodules, output) {\n                var seen, symbol;\n                seen = {};\n                var _$rapyd$_Iter63 = _$rapyd$_Iterable(exports);\n                for (var _$rapyd$_Index63 = 0; _$rapyd$_Index63 < _$rapyd$_Iter63.length; _$rapyd$_Index63++) {\n                    symbol = _$rapyd$_Iter63[_$rapyd$_Index63];\n                    if (!Object.prototype.hasOwnProperty.call(seen, symbol.name)) {\n                        output.newline();\n                        output.indent();\n                        output.print(\"_$rapyd$_modules[\\\"\" + module_id + \"\\\"][\\\"\" + symbol.name + \"\\\"] = \" + symbol.name);\n                        seen[symbol.name] = true;\n                        output.semicolon();\n                        output.newline();\n                    }\n                }\n            }\n            function declare_submodules(module_id, submodules, output) {\n                var seen, key, sub_module_id;\n                seen = {};\n                var _$rapyd$_Iter64 = _$rapyd$_Iterable(submodules);\n                for (var _$rapyd$_Index64 = 0; _$rapyd$_Index64 < _$rapyd$_Iter64.length; _$rapyd$_Index64++) {\n                    sub_module_id = _$rapyd$_Iter64[_$rapyd$_Index64];\n                    if (!Object.prototype.hasOwnProperty.call(seen, sub_module_id)) {\n                        seen[sub_module_id] = true;\n                        key = sub_module_id.split(\".\")[sub_module_id.split(\".\").length-1];\n                        output.indent();\n                        output.spaced(\"_$rapyd$_modules[\\\"\" + module_id + \"\\\"][\\\"\" + key + \"\\\"]\", \"=\", \"_$rapyd$_modules[\\\"\" + sub_module_id + \"\\\"]\");\n                        output.end_statement();\n                    }\n                }\n            }\n            function unpack_tuple(elems, output, in_statement) {\n                elems.forEach(function(elem, i) {\n                    output.indent();\n                    output.assign(elem);\n                    output.print(\"_$rapyd$_unpack\");\n                    output.with_square(function() {\n                        output.print(i);\n                    });\n                    if (!in_statement || i < elems.length - 1) {\n                        output.semicolon();\n                        output.newline();\n                    }\n                });\n            }\n            AST_StatementWithBody.DEFMETHOD(\"_do_print_body\", function(output) {\n                force_statement(this.body, output);\n            });\n            DEFPRINT(AST_Statement, function(self, output) {\n                self.body.print(output);\n                output.semicolon();\n            });\n            DEFPRINT(AST_Toplevel, function(self, output) {\n                var is_main;\n                is_main = output.is_main();\n                if (output.option(\"private_scope\") && is_main) {\n                    output.with_parens(function() {\n                        output.print(\"function()\");\n                        output.with_block(function() {\n                            output.indent();\n                            output.print(\"\\\"use strict\\\"\");\n                            output.end_statement();\n                            output.prologue(self);\n                            write_imports(self, output);\n                            output.newline();\n                            output.indent();\n                            output.with_parens(function() {\n                                output.print(\"function()\");\n                                output.with_block(function() {\n                                    write_main_name(output);\n                                    output.newline();\n                                    declare_vars(self.localvars, output);\n                                    display_body(self.body, true, output);\n                                    output.newline();\n                                });\n                            });\n                            output.print(\"();\");\n                            output.newline();\n                        });\n                    });\n                    output.print(\"();\");\n                    output.print(\"\");\n                } else {\n                    if (is_main) {\n                        output.prologue(self);\n                        write_imports(self, output);\n                        write_main_name(output);\n                    }\n                    declare_vars(self.localvars, output);\n                    display_body(self.body, true, output);\n                }\n            });\n            function print_module(self, output) {\n                function output_module(output) {\n                    declare_vars(self.localvars, output);\n                    display_body(self.body, true, output);\n                    declare_exports(self.module_id, self.exports, self.submodules, output);\n                }\n                output.newline();\n                output.indent();\n                output.with_parens(function() {\n                    output.print(\"function()\");\n                    output.with_block(function() {\n                        var okey, cached, cobj, cname, symdef, co, raw, js_version, auto_bind, beautify;\n                        if (output.option(\"write_name\")) {\n                            output.indent();\n                            output.print(\"var \");\n                            output.assign(\"__name__\");\n                            output.print(\"\\\"\" + self.module_id + \"\\\"\");\n                            output.semicolon();\n                            output.newline();\n                        }\n                        function output_key(beautify, auto_bind, js_version) {\n                            return \"beautify:\" + beautify + \" auto_bind:\" + auto_bind + \" js_version:\" + js_version;\n                        }\n                        okey = output_key(output.option(\"beautify\"), output.option(\"auto_bind\"), output.option(\"js_version\"));\n                        if (self.is_cached && _$rapyd$_in(okey, self.outputs)) {\n                            output.print(self.outputs[okey]);\n                            declare_submodules(self.module_id, self.submodules, output);\n                        } else {\n                            output_module(output);\n                            declare_submodules(self.module_id, self.submodules, output);\n                            if (self.srchash && self.filename) {\n                                cached = {\n                                    \"version\": COMPILER_VERSION,\n                                    \"signature\": self.srchash,\n                                    \"classes\": {},\n                                    \"baselib\": self.baselib,\n                                    \"nonlocalvars\": self.nonlocalvars,\n                                    \"imported_module_ids\": self.imported_module_ids,\n                                    \"exports\": _$rapyd$_list_decorate([]),\n                                    \"outputs\": {}\n                                };\n                                var _$rapyd$_Iter65 = _$rapyd$_Iterable(Object.keys(self.classes));\n                                for (var _$rapyd$_Index65 = 0; _$rapyd$_Index65 < _$rapyd$_Iter65.length; _$rapyd$_Index65++) {\n                                    cname = _$rapyd$_Iter65[_$rapyd$_Index65];\n                                    cobj = self.classes[cname];\n                                    cached.classes[cname] = {\n                                        \"name\": {\n                                            \"name\": cobj.name.name\n                                        },\n                                        \"static\": cobj.static,\n                                        \"bound\": cobj.bound\n                                    };\n                                }\n                                var _$rapyd$_Iter66 = _$rapyd$_Iterable(self.exports);\n                                for (var _$rapyd$_Index66 = 0; _$rapyd$_Index66 < _$rapyd$_Iter66.length; _$rapyd$_Index66++) {\n                                    symdef = _$rapyd$_Iter66[_$rapyd$_Index66];\n                                    cached.exports.push({\n                                        \"name\": symdef.name\n                                    });\n                                }\n                                var _$rapyd$_Iter67 = _$rapyd$_Iterable(_$rapyd$_list_decorate([ true, false ]));\n                                for (var _$rapyd$_Index67 = 0; _$rapyd$_Index67 < _$rapyd$_Iter67.length; _$rapyd$_Index67++) {\n                                    beautify = _$rapyd$_Iter67[_$rapyd$_Index67];\n                                    var _$rapyd$_Iter68 = _$rapyd$_Iterable(_$rapyd$_list_decorate([ true, false ]));\n                                    for (var _$rapyd$_Index68 = 0; _$rapyd$_Index68 < _$rapyd$_Iter68.length; _$rapyd$_Index68++) {\n                                        auto_bind = _$rapyd$_Iter68[_$rapyd$_Index68];\n                                        var _$rapyd$_Iter69 = _$rapyd$_Iterable(_$rapyd$_list_decorate([ 5, 6 ]));\n                                        for (var _$rapyd$_Index69 = 0; _$rapyd$_Index69 < _$rapyd$_Iter69.length; _$rapyd$_Index69++) {\n                                            js_version = _$rapyd$_Iter69[_$rapyd$_Index69];\n                                            co = OutputStream({\n                                                \"beautify\": beautify,\n                                                \"auto_bind\": auto_bind,\n                                                \"js_version\": js_version,\n                                                \"private_scope\": false,\n                                                \"write_name\": false\n                                            });\n                                            co.with_indent(output.indentation(), function() {\n                                                output_module(co);\n                                            });\n                                            raw = co.toString();\n                                            cached.outputs[output_key(beautify, auto_bind, js_version)] = raw;\n                                        }\n                                    }\n                                }\n                                try {\n                                    writefile(self.filename + \"-cached\", JSON.stringify(cached, null, \"\\t\"));\n                                } catch (_$rapyd$_Exception) {\n                                    if (_$rapyd$_Exception instanceof Error) {\n                                        var e = _$rapyd$_Exception;\n                                        console.error(\"Failed to write output cache file:\", self.filename + \"-cached\", \"with error:\", e);\n                                    } else {\n                                        throw _$rapyd$_Exception;\n                                    }\n                                }\n                            }\n                        }\n                    });\n                });\n                output.print(\"()\");\n                output.semicolon();\n                output.newline();\n            }\n            DEFPRINT(AST_Imports, function(container, output) {\n                var akey, argname, bound_name, self;\n                function add_aname(aname, key, from_import) {\n                    output.print(\"var \");\n                    output.assign(aname);\n                    output.print(\"_$rapyd$_modules[\\\"\");\n                    output.print(key);\n                    output.print(\"\\\"]\");\n                    if (from_import) {\n                        output.print(\".\");\n                        output.print(from_import);\n                    }\n                    output.semicolon();\n                    output.newline();\n                    output.indent();\n                }\n                var _$rapyd$_Iter70 = _$rapyd$_Iterable(container.imports);\n                for (var _$rapyd$_Index70 = 0; _$rapyd$_Index70 < _$rapyd$_Iter70.length; _$rapyd$_Index70++) {\n                    self = _$rapyd$_Iter70[_$rapyd$_Index70];\n                    output.import(self.module);\n                    if (self.argnames) {\n                        var _$rapyd$_Iter71 = _$rapyd$_Iterable(self.argnames);\n                        for (var _$rapyd$_Index71 = 0; _$rapyd$_Index71 < _$rapyd$_Iter71.length; _$rapyd$_Index71++) {\n                            argname = _$rapyd$_Iter71[_$rapyd$_Index71];\n                            akey = (argname.alias) ? argname.alias.name : argname.name;\n                            add_aname(akey, self.key, argname.name);\n                        }\n                    } else {\n                        if (self.alias) {\n                            add_aname(self.alias.name, self.key, false);\n                        } else {\n                            bound_name = self.key.split(\".\", 1)[0];\n                            add_aname(bound_name, bound_name, false);\n                        }\n                    }\n                }\n            });\n            DEFPRINT(AST_SimpleStatement, function(self, output) {\n                if (!(self.body instanceof AST_EmptyStatement)) {\n                    self.body.print(output);\n                    output.semicolon();\n                }\n            });\n            function print_bracketed(node, output, complex) {\n                if (node.body.length > 0) {\n                    output.with_block(function() {\n                        if (complex) {\n                            display_complex_body(node, false, output);\n                        } else {\n                            display_body(node.body, false, output);\n                        }\n                    });\n                } else {\n                    output.print(\"{}\");\n                }\n            }\n            DEFPRINT(AST_BlockStatement, function(self, output) {\n                print_bracketed(self, output);\n            });\n            DEFPRINT(AST_EmptyStatement, function(self, output) {\n            });\n            DEFPRINT(AST_Do, function(self, output) {\n                output.print(\"do\");\n                output.space();\n                self._do_print_body(output);\n                output.space();\n                output.print(\"while\");\n                output.space();\n                output.with_parens(function() {\n                    self.condition.print(output);\n                });\n                output.semicolon();\n            });\n            DEFPRINT(AST_While, function(self, output) {\n                output.print(\"while\");\n                output.space();\n                output.with_parens(function() {\n                    self.condition.print(output);\n                });\n                output.space();\n                self._do_print_body(output);\n            });\n            function is_simple_for_in(self) {\n                if (self.object instanceof AST_BaseCall && self.object.expression instanceof AST_SymbolRef && self.object.expression.name === \"dir\" && self.object.args.length === 1) {\n                    return true;\n                }\n                return false;\n            }\n            function is_simple_for(self) {\n                if (self.object instanceof AST_BaseCall && self.object.expression instanceof AST_SymbolRef && self.object.expression.name === \"range\" && !(self.init instanceof AST_Array) && (self.object.args.length < 3 || self.object.args.slice(-1)[0] instanceof AST_Number || self.object.args.slice(-1)[0] instanceof AST_Unary && self.object.args.slice(-1)[0].operator === \"-\" && self.object.args.slice(-1)[0].expression instanceof AST_Number)) {\n                    return true;\n                }\n                return false;\n            }\n            AST_ForIn.DEFMETHOD(\"_do_print_body\", function(output) {\n                var self;\n                self = this;\n                output.with_block(function() {\n                    var itervar, flat;\n                    if (!(self.simple_for_index || is_simple_for_in(self))) {\n                        output.indent();\n                        if (output.option(\"js_version\") === 5) {\n                            itervar = \"_$rapyd$_Iter\" + output.index_counter + \"[_$rapyd$_Index\" + output.index_counter + \"]\";\n                        } else {\n                            itervar = \"_$rapyd$_Index\" + output.index_counter;\n                        }\n                        if (self.init instanceof AST_Array) {\n                            flat = self.init.flatten();\n                            output.assign(\"_$rapyd$_unpack\");\n                            if (flat.length > self.init.elements.length) {\n                                output.print(\"_$rapyd$_flatten(\" + itervar + \")\");\n                            } else {\n                                output.print(itervar);\n                            }\n                            output.end_statement();\n                            unpack_tuple(flat, output);\n                        } else {\n                            output.assign(self.init);\n                            output.print(itervar);\n                            output.end_statement();\n                        }\n                        output.index_counter += 1;\n                    }\n                    if (self.simple_for_index) {\n                        output.indent();\n                        output.assign(self.init);\n                        output.print(self.simple_for_index);\n                        output.end_statement();\n                    }\n                    self.body.body.forEach(function(stmt, i) {\n                        output.indent();\n                        stmt.print(output);\n                        output.newline();\n                    });\n                });\n            });\n            function init_es6_itervar(output, itervar) {\n                output.indent();\n                output.spaced(itervar, \"=\", \"((typeof\", itervar + \"[Symbol.iterator]\", \"===\", \"\\\"function\\\")\", \"?\", \"(\" + itervar, \"instanceof\", \"Map\", \"?\", itervar + \".keys()\", \":\", itervar + \")\", \":\", \"Object.keys(\" + itervar + \"))\");\n                output.end_statement();\n            }\n            DEFPRINT(AST_ForIn, function(self, output) {\n                var increment, args, tmp_, start, end, idx, _$rapyd$_chain_assign_temp, itervar;\n                function write_object() {\n                    if (self.object.TYPE === \"Seq\") {\n                        new AST_Array({\n                            \"elements\": self.object.to_array()\n                        }).print(output);\n                    } else {\n                        self.object.print(output);\n                    }\n                }\n                if (is_simple_for(self)) {\n                    increment = null;\n                    args = self.object.args;\n                    tmp_ = args.length;\n                    if (tmp_ === 1) {\n                        start = 0;\n                        end = args[0];\n                    } else if (tmp_ === 2) {\n                        start = args[0];\n                        end = args[1];\n                    } else if (tmp_ === 3) {\n                        start = args[0];\n                        end = args[1];\n                        increment = args[2];\n                    }\n                    _$rapyd$_chain_assign_temp = \"_$rapyd$_Index\" + output.index_counter;\n                    self.simple_for_index = _$rapyd$_chain_assign_temp;\n                    idx = _$rapyd$_chain_assign_temp;\n;\n                    output.index_counter += 1;\n                    output.print(\"for\");\n                    output.space();\n                    output.with_parens(function() {\n                        [output.spaced(\"var\", idx, \"=\"), output.space()];\n                        (start.print) ? start.print(output) : output.print(start);\n                        output.semicolon();\n                        output.space();\n                        output.print(idx);\n                        output.space();\n                        (increment instanceof AST_Unary) ? output.print(\">\") : output.print(\"<\");\n                        output.space();\n                        end.print(output);\n                        output.semicolon();\n                        output.space();\n                        output.print(idx);\n                        if (increment && (!(increment instanceof AST_Unary) || increment.expression.value !== \"1\")) {\n                            if (increment instanceof AST_Unary) {\n                                output.print(\"-=\");\n                                increment.expression.print(output);\n                            } else {\n                                output.print(\"+=\");\n                                increment.print(output);\n                            }\n                        } else {\n                            if (increment instanceof AST_Unary) {\n                                output.print(\"--\");\n                            } else {\n                                output.print(\"++\");\n                            }\n                        }\n                    });\n                } else if (is_simple_for_in(self)) {\n                    output.print(\"for\");\n                    output.space();\n                    output.with_parens(function() {\n                        self.init.print(output);\n                        output.space();\n                        output.print(\"in\");\n                        output.space();\n                        self.object.args[0].print(output);\n                    });\n                } else {\n                    if (output.options.js_version === 5) {\n                        output.assign(\"var _$rapyd$_Iter\" + output.index_counter);\n                        output.print(\"_$rapyd$_Iterable\");\n                        output.with_parens(write_object);\n                        output.semicolon();\n                        output.newline();\n                        output.indent();\n                        output.print(\"for\");\n                        output.space();\n                        output.with_parens(function() {\n                            output.print(\"var\");\n                            output.space();\n                            output.assign(\"_$rapyd$_Index\" + output.index_counter);\n                            output.print(\"0\");\n                            output.semicolon();\n                            output.space();\n                            output.print(\"_$rapyd$_Index\" + output.index_counter);\n                            output.space();\n                            output.print(\"<\");\n                            output.space();\n                            output.print(\"_$rapyd$_Iter\" + output.index_counter + \".length\");\n                            output.semicolon();\n                            output.space();\n                            output.print(\"_$rapyd$_Index\" + output.index_counter + \"++\");\n                        });\n                    } else {\n                        itervar = \"_$rapyd$_Iter\" + output.index_counter;\n                        output.assign(\"var \" + itervar);\n                        write_object();\n                        output.end_statement();\n                        init_es6_itervar(output, itervar);\n                        output.indent();\n                        output.spaced(\"for\", \"(var\", \"_$rapyd$_Index\" + output.index_counter, \"of\", itervar + \")\");\n                    }\n                }\n                output.space();\n                self._do_print_body(output);\n            });\n            AST_ForJS.DEFMETHOD(\"_do_print_body\", function(output) {\n                var self;\n                self = this;\n                output.with_block(function() {\n                    self.body.body.forEach(function(stmt, i) {\n                        output.indent();\n                        stmt.print(output);\n                        output.newline();\n                    });\n                });\n            });\n            DEFPRINT(AST_ForJS, function(self, output) {\n                output.print(\"for\");\n                output.space();\n                output.with_parens(function() {\n                    self.condition.print(output);\n                });\n                output.space();\n                self._do_print_body(output);\n            });\n            DEFPRINT(AST_ListComprehension, function(self, output) {\n                var result_obj, is_generator, es5, add_to_result, push_func;\n                result_obj = {\n                    \"ListComprehension\": \"[]\",\n                    \"DictComprehension\": \"{}\",\n                    \"SetComprehension\": \"_$rapyd$_set()\"\n                }[self.TYPE];\n                is_generator = self.TYPE === \"GeneratorComprehension\";\n                es5 = output.option(\"js_version\") === 5;\n                if (self.TYPE === \"DictComprehension\") {\n                    if (self.is_pydict) {\n                        result_obj = \"_$rapyd$_dict()\";\n                        add_to_result = function(output) {\n                            output.indent();\n                            output.print(\"_$rapyd$_Result.set\");\n                            output.with_parens(function() {\n                                self.statement.print(output);\n                                [output.space(), output.print(\",\"), output.space()];\n                                output.with_parens(function() {\n                                    if (self.value_statement.TYPE === \"Seq\") {\n                                        output.with_square(function() {\n                                            self.value_statement.print(output);\n                                        });\n                                    } else {\n                                        self.value_statement.print(output);\n                                    }\n                                });\n                            });\n                            output.end_statement();\n                        };\n                    } else {\n                        add_to_result = function(output) {\n                            output.indent();\n                            output.print(\"_$rapyd$_Result\");\n                            output.with_square(function() {\n                                self.statement.print(output);\n                            });\n                            [output.space(), output.print(\"=\"), output.space()];\n                            output.with_parens(function() {\n                                if (self.value_statement.TYPE === \"Seq\") {\n                                    output.with_square(function() {\n                                        self.value_statement.print(output);\n                                    });\n                                } else {\n                                    self.value_statement.print(output);\n                                }\n                            });\n                            output.end_statement();\n                        };\n                    }\n                } else {\n                    push_func = \"_$rapyd$_Result.\" + ((self.TYPE === \"ListComprehension\") ? \"push\" : \"add\");\n                    if (is_generator) {\n                        push_func = \"yield \";\n                    }\n                    add_to_result = function(output) {\n                        output.indent();\n                        output.print(push_func);\n                        output.with_parens(function() {\n                            if (self.statement.TYPE === \"Seq\") {\n                                output.with_square(function() {\n                                    self.statement.print(output);\n                                });\n                            } else {\n                                self.statement.print(output);\n                            }\n                        });\n                        output.end_statement();\n                    };\n                }\n                output.with_parens(function() {\n                    output.print(\"function\");\n                    output.print(\"()\");\n                    output.space();\n                    output.with_block(function() {\n                        var body_out, previous_indentation, transpiled, ci;\n                        body_out = output;\n                        if (is_generator) {\n                            if (es5) {\n                                body_out = OutputStream({\n                                    \"beautify\": true\n                                });\n                            }\n                            body_out.indent();\n                            [body_out.print(\"function* js_generator()\"), body_out.space(), body_out.print(\"{\")];\n                            body_out.newline();\n                            previous_indentation = output.indentation();\n                            output.set_indentation(output.next_indent());\n                        }\n                        body_out.indent();\n                        body_out.assign(\"var _$rapyd$_Iter\");\n                        if (es5) {\n                            body_out.print(\"_$rapyd$_Iterable\");\n                            body_out.with_parens(function() {\n                                self.object.print(body_out);\n                            });\n                        } else {\n                            self.object.print(body_out);\n                        }\n                        if (result_obj) {\n                            body_out.comma();\n                            body_out.assign(\"_$rapyd$_Result\");\n                            body_out.print(result_obj);\n                        }\n                        if (self.init instanceof AST_Array) {\n                            self.init.elements.forEach(function(i) {\n                                body_out.comma();\n                                i.print(body_out);\n                            });\n                        } else {\n                            body_out.comma();\n                            self.init.print(body_out);\n                        }\n                        body_out.end_statement();\n                        if (!es5) {\n                            init_es6_itervar(body_out, \"_$rapyd$_Iter\");\n                        }\n                        body_out.indent();\n                        body_out.print(\"for\");\n                        body_out.space();\n                        body_out.with_parens(function() {\n                            if (es5) {\n                                body_out.print(\"var\");\n                                body_out.space();\n                                body_out.assign(\"_$rapyd$_Index\");\n                                body_out.print(\"0\");\n                                body_out.semicolon();\n                                body_out.space();\n                                body_out.print(\"_$rapyd$_Index\");\n                                body_out.space();\n                                body_out.print(\"<\");\n                                body_out.space();\n                                body_out.print(\"_$rapyd$_Iter.length\");\n                                body_out.semicolon();\n                                body_out.space();\n                                body_out.print(\"_$rapyd$_Index++\");\n                            } else {\n                                body_out.spaced(\"var\", \"_$rapyd$_Index\", \"of\", \"_$rapyd$_Iter\");\n                            }\n                        });\n                        body_out.space();\n                        body_out.with_block(function() {\n                            var itervar, flat;\n                            body_out.indent();\n                            itervar = (es5) ? \"_$rapyd$_Iter[_$rapyd$_Index]\" : \"_$rapyd$_Index\";\n                            if (self.init instanceof AST_Array) {\n                                flat = self.init.flatten();\n                                body_out.assign(\"_$rapyd$_unpack\");\n                                if (flat.length > self.init.elements.length) {\n                                    body_out.print(\"_$rapyd$_flatten(\" + itervar + \")\");\n                                } else {\n                                    body_out.print(itervar);\n                                }\n                                body_out.end_statement();\n                                unpack_tuple(flat, body_out);\n                            } else {\n                                body_out.assign(self.init);\n                                body_out.print(itervar);\n                                body_out.end_statement();\n                            }\n                            if (self.condition) {\n                                body_out.indent();\n                                body_out.print(\"if\");\n                                body_out.space();\n                                body_out.with_parens(function() {\n                                    self.condition.print(body_out);\n                                });\n                                body_out.space();\n                                body_out.with_block(function() {\n                                    add_to_result(body_out);\n                                });\n                                body_out.newline();\n                            } else {\n                                add_to_result(body_out);\n                            }\n                        });\n                        body_out.newline();\n                        if (self.TYPE === \"ListComprehension\") {\n                            body_out.indent();\n                            body_out.spaced(\"_$rapyd$_Result\", \"=\", \"_$rapyd$_list_constructor(_$rapyd$_Result)\");\n                            body_out.end_statement();\n                        }\n                        if (!is_generator) {\n                            body_out.indent();\n                            body_out.print(\"return _$rapyd$_Result\");\n                            body_out.end_statement();\n                        }\n                        if (is_generator) {\n                            output.set_indentation(previous_indentation);\n                            [body_out.newline(), body_out.indent(), body_out.print(\"}\")];\n                            if (es5) {\n                                transpiled = regenerate(body_out.get(), output.options.beautify).replace(/regeneratorRuntime.(wrap|mark)/g, \"_$rapyd$_regenerator.regeneratorRuntime.$1\");\n                                if (output.options.beautify) {\n                                    ci = output.make_indent(0);\n                                    transpiled = (function() {\n                                        var _$rapyd$_Iter = _$rapyd$_Iterable(transpiled.split(\"\\n\")), _$rapyd$_Result = [], x;\n                                        for (var _$rapyd$_Index = 0; _$rapyd$_Index < _$rapyd$_Iter.length; _$rapyd$_Index++) {\n                                            x = _$rapyd$_Iter[_$rapyd$_Index];\n                                            _$rapyd$_Result.push(ci + x);\n                                        }\n                                        _$rapyd$_Result = _$rapyd$_list_constructor(_$rapyd$_Result);\n                                        return _$rapyd$_Result;\n                                    })().join(\"\\n\");\n                                }\n                                output.print(transpiled);\n                            }\n                            [output.newline(), output.indent()];\n                            output.spaced(\"var\", \"result\", \"=\", \"js_generator.call(this)\");\n                            output.end_statement();\n                            output.indent();\n                            output.spaced(\"result.send\", \"=\", \"result.next\");\n                            output.end_statement();\n                            output.indent();\n                            output.spaced(\"return\", \"result\");\n                            output.end_statement();\n                        }\n                    });\n                });\n                output.print(\"()\");\n            });\n            DEFPRINT(AST_With, function(self, output) {\n                var exits, clause_name, clause;\n                exits = [];\n                [output.assign(\"_$rapyd$_with_exception\"), output.print(\"undefined\"), output.end_statement()];\n                var _$rapyd$_Iter72 = _$rapyd$_Iterable(self.clauses);\n                for (var _$rapyd$_Index72 = 0; _$rapyd$_Index72 < _$rapyd$_Iter72.length; _$rapyd$_Index72++) {\n                    clause = _$rapyd$_Iter72[_$rapyd$_Index72];\n                    output.with_counter += 1;\n                    clause_name = \"_$rapyd$_with_clause_\" + output.with_counter;\n                    exits.push(clause_name);\n                    [output.indent(), output.print(\"var \"), output.assign(clause_name)];\n                    clause.expression.print(output);\n                    output.end_statement();\n                    output.indent();\n                    if (clause.alias) {\n                        output.assign(clause.alias.name);\n                    }\n                    output.print(clause_name + \".__enter__()\");\n                    output.end_statement();\n                }\n                [output.indent(), output.print(\"try\"), output.space()];\n                output.with_block(function() {\n                    output.indent();\n                    self._do_print_body(output);\n                    output.newline();\n                });\n                [output.space(), output.print(\"catch(e)\")];\n                output.with_block(function() {\n                    [output.indent(), output.assign(\"_$rapyd$_with_exception\"), output.print(\"e\"), output.end_statement()];\n                });\n                [output.newline(), output.indent(), output.spaced(\"if\", \"(_$rapyd$_with_exception\", \"===\", \"undefined)\")];\n                output.with_block(function() {\n                    var clause;\n                    var _$rapyd$_Iter73 = _$rapyd$_Iterable(exits);\n                    for (var _$rapyd$_Index73 = 0; _$rapyd$_Index73 < _$rapyd$_Iter73.length; _$rapyd$_Index73++) {\n                        clause = _$rapyd$_Iter73[_$rapyd$_Index73];\n                        [output.indent(), output.print(clause + \".__exit__()\"), output.end_statement()];\n                    }\n                });\n                [output.space(), output.print(\"else\"), output.space()];\n                output.with_block(function() {\n                    var clause;\n                    [output.indent(), output.assign(\"_$rapyd$_with_suppress\"), output.print(\"false\"), \n                    output.end_statement()];\n                    var _$rapyd$_Iter74 = _$rapyd$_Iterable(exits);\n                    for (var _$rapyd$_Index74 = 0; _$rapyd$_Index74 < _$rapyd$_Iter74.length; _$rapyd$_Index74++) {\n                        clause = _$rapyd$_Iter74[_$rapyd$_Index74];\n                        output.indent();\n                        output.spaced(\"_$rapyd$_with_suppress\", \"|=\", \"_$rapyd$_bool(\" + clause + \".__exit__(_$rapyd$_with_exception.constructor,\", \"_$rapyd$_with_exception,\", \"_$rapyd$_with_exception.stack))\");\n                        output.end_statement();\n                    }\n                    [output.indent(), output.spaced(\"if\", \"(!_$rapyd$_with_suppress)\", \"throw _$rapyd$_with_exception\"), \n                    output.end_statement()];\n                });\n            });\n            function decorate(decorators, output, func) {\n                var pos, wrap;\n                pos = 0;\n                wrap = function() {\n                    if (pos < decorators.length) {\n                        decorators[pos].expression.print(output);\n                        pos += 1;\n                        output.with_parens(function() {\n                            wrap();\n                        });\n                    } else {\n                        func();\n                    }\n                };\n                wrap();\n            }\n            function function_args(argnames, output, strip_first) {\n                output.with_parens(function() {\n                    if (argnames && argnames.length && (argnames.is_simple_func === true || argnames.is_simple_func === undefined)) {\n                        ((strip_first) ? argnames.slice(1) : argnames).forEach(function(arg, i) {\n                            if (i) {\n                                output.comma();\n                            }\n                            arg.print(output);\n                        });\n                    }\n                });\n                output.space();\n            }\n            function function_definition(self, output, nokeyword, strip_first) {\n                if (!nokeyword) {\n                    output.print(\"function\");\n                }\n                if (self.name) {\n                    output.space();\n                    self.name.print(output);\n                }\n                if (self.is_generator) {\n                    [output.print(\"()\"), output.space()];\n                    output.with_block(function() {\n                        var temp, transpiled, ci;\n                        if (output.options.js_version >= 6) {\n                            output.indent();\n                            output.print(\"function* js_generator\");\n                            function_args(self.argnames, output, strip_first);\n                            print_bracketed(self, output, true);\n                        } else {\n                            temp = OutputStream({\n                                \"beautify\": true\n                            });\n                            temp.print(\"function* js_generator\");\n                            function_args(self.argnames, temp, strip_first);\n                            print_bracketed(self, temp, true);\n                            transpiled = regenerate(temp.get(), output.options.beautify).replace(/regeneratorRuntime.(wrap|mark)/g, \"_$rapyd$_regenerator.regeneratorRuntime.$1\");\n                            if (output.options.beautify) {\n                                ci = output.make_indent(0);\n                                transpiled = (function() {\n                                    var _$rapyd$_Iter = _$rapyd$_Iterable(transpiled.split(\"\\n\")), _$rapyd$_Result = [], x;\n                                    for (var _$rapyd$_Index = 0; _$rapyd$_Index < _$rapyd$_Iter.length; _$rapyd$_Index++) {\n                                        x = _$rapyd$_Iter[_$rapyd$_Index];\n                                        _$rapyd$_Result.push(ci + x);\n                                    }\n                                    _$rapyd$_Result = _$rapyd$_list_constructor(_$rapyd$_Result);\n                                    return _$rapyd$_Result;\n                                })().join(\"\\n\");\n                            }\n                            output.print(transpiled);\n                        }\n                        output.newline();\n                        output.indent();\n                        output.spaced(\"var\", \"result\", \"=\", \"js_generator.apply(this,\", \"arguments)\");\n                        output.end_statement();\n                        output.indent();\n                        output.spaced(\"result.send\", \"=\", \"result.next\");\n                        output.end_statement();\n                        output.indent();\n                        output.spaced(\"return\", \"result\");\n                        output.end_statement();\n                    });\n                } else {\n                    function_args(self.argnames, output, strip_first);\n                    print_bracketed(self, output, true);\n                }\n            }\n            AST_Lambda.DEFMETHOD(\"_do_print\", function(output, nokeyword) {\n                var self;\n                self = this;\n                if (self.decorators && self.decorators.length) {\n                    output.print(\"var\");\n                    output.space();\n                    output.assign(self.name.name);\n                    decorate(self.decorators, output, function() {\n                        function_definition(self, output, nokeyword, false);\n                    });\n                    output.semicolon();\n                } else {\n                    function_definition(self, output, nokeyword, false);\n                }\n            });\n            DEFPRINT(AST_Lambda, function(self, output) {\n                self._do_print(output);\n            });\n            AST_Class.DEFMETHOD(\"_do_print\", function(output) {\n                var self, class_def, define_method, property_names, defined_methods;\n                self = this;\n                if (self.external) {\n                    return;\n                }\n                class_def = function(method, is_var) {\n                    output.indent();\n                    self.name.print(output);\n                    if (!is_var && method && self.static.indexOf(method) !== -1) {\n                        output.assign(\".\" + method);\n                    } else {\n                        if (is_var) {\n                            output.assign(\".prototype[\" + method + \"]\");\n                        } else {\n                            output.assign(\".prototype\" + ((method) ? \".\" + method : \"\"));\n                        }\n                    }\n                };\n                define_method = function(stmt, is_property) {\n                    var name, strip_first;\n                    name = stmt.name.name;\n                    if (!is_property) {\n                        class_def(name);\n                    }\n                    strip_first = self.static.indexOf(name) === -1;\n                    if (stmt.decorators && stmt.decorators.length) {\n                        decorate(stmt.decorators, output, function() {\n                            function_definition(stmt, output, false, strip_first);\n                        });\n                    } else {\n                        function_definition(stmt, output, false, strip_first);\n                    }\n                    if (!is_property) {\n                        output.semicolon();\n                        output.newline();\n                    }\n                };\n                function define_default_method(name, body) {\n                    class_def(name);\n                    output.spaced(\"function\", name, \"()\", \"\");\n                    output.with_block(function() {\n                        [output.indent(), body()];\n                    });\n                    output.end_statement();\n                }\n                function write_constructor() {\n                    output.print(\"function\");\n                    output.space();\n                    self.name.print(output);\n                    output.print(\"()\");\n                    output.space();\n                    output.with_block(function() {\n                        bind_methods(self.bound, output);\n                        output.indent();\n                        output.spaced(\"if\", \"(this._$rapyd$_object_id\", \"===\", \"undefined)\", \"Object.defineProperty(this,\", \"\\\"_$rapyd$_object_id\\\",\", \"{\\\"value\\\":++_$rapyd$_object_counter})\");\n                        output.end_statement();\n                        output.indent();\n                        self.name.print(output);\n                        output.print(\".prototype.__init__.apply\");\n                        output.with_parens(function() {\n                            output.print(\"this\");\n                            output.comma();\n                            output.print(\"arguments\");\n                        });\n                        output.end_statement();\n                    });\n                }\n                if (self.decorators && self.decorators.length) {\n                    output.print(\"var \");\n                    output.assign(self.name);\n                    decorate(self.decorators, output, write_constructor);\n                    output.semicolon();\n                } else {\n                    write_constructor();\n                }\n                output.newline();\n                if (self.parent) {\n                    output.indent();\n                    output.print(\"_$rapyd$_extends\");\n                    output.with_parens(function() {\n                        self.name.print(output);\n                        output.comma();\n                        self.parent.print(output);\n                    });\n                    output.semicolon();\n                    output.newline();\n                }\n                property_names = Object.keys(self.dynamic_properties);\n                if (property_names.length) {\n                    output.indent();\n                    output.print(\"Object.defineProperties\");\n                    output.with_parens(function() {\n                        [self.name.print(output), output.print(\".prototype\"), output.comma(), output.space(), \n                        output.with_block(function() {\n                            var prop, name;\n                            var _$rapyd$_Iter75 = _$rapyd$_Iterable(property_names);\n                            for (var _$rapyd$_Index75 = 0; _$rapyd$_Index75 < _$rapyd$_Iter75.length; _$rapyd$_Index75++) {\n                                name = _$rapyd$_Iter75[_$rapyd$_Index75];\n                                prop = self.dynamic_properties[name];\n                                [output.indent(), output.print(JSON.stringify(name) + \":\"), output.space()];\n                                output.with_block(function() {\n                                    [output.indent(), output.print(\"\\\"enumerable\\\":\"), output.space(), output.print(\"true\"), \n                                    output.comma(), output.newline()];\n                                    if (prop.getter) {\n                                        [output.indent(), output.print(\"\\\"get\\\":\"), output.space()];\n                                        [define_method(prop.getter, true), output.comma(), output.newline()];\n                                    }\n                                    [output.indent(), output.print(\"\\\"set\\\":\"), output.space()];\n                                    if (prop.setter) {\n                                        [define_method(prop.setter, true), output.newline()];\n                                    } else {\n                                        [output.spaced(\"function\", \"()\", \"{\", \"throw new AttributeError(\\\"can't set attribute\\\")\", \"}\"), \n                                        output.newline()];\n                                    }\n                                });\n                                [output.comma(), output.newline()];\n                            }\n                        })];\n                    });\n                    output.end_statement();\n                }\n                if (!self.init) {\n                    define_default_method(\"__init__\", function() {\n                        if (self.parent) {\n                            self.parent.print(output);\n                            output.spaced(\".prototype.__init__\", \"&&\");\n                            [output.space(), self.parent.print(output)];\n                            output.print(\".prototype.__init__.apply\");\n                            output.with_parens(function() {\n                                output.print(\"this\");\n                                output.comma();\n                                output.print(\"arguments\");\n                            });\n                            output.end_statement();\n                        }\n                    });\n                }\n                defined_methods = {};\n                self.body.forEach(function(stmt, i) {\n                    if (stmt instanceof AST_Method) {\n                        if (stmt.is_getter || stmt.is_setter) {\n                            return;\n                        }\n                        define_method(stmt);\n                        defined_methods[stmt.name.name] = true;\n                        if (stmt.name.name === \"__iter__\") {\n                            class_def(\"_$rapyd$_iterator_symbol\", true);\n                            self.name.print(output);\n                            output.print(\".prototype.\" + stmt.name.name);\n                            output.end_statement();\n                        }\n                    } else if (stmt instanceof AST_Class) {\n                        console.error(\"Nested classes aren't supported yet\");\n                    }\n                });\n                if (!defined_methods[\"__repr__\"]) {\n                    define_default_method(\"__repr__\", function() {\n                        output.spaced(\"return\", \"\\\"<\\\"\", \"+\", \"__name__\", \"+\", \"\\\".\\\"\", \"+\", \"\\\"\");\n                        self.name.print(output);\n                        output.spaced(\"\\\"\", \"+\", \"\\\" #\\\"\", \"+\", \"this._$rapyd$_object_id\", \"+\", \"\\\">\\\"\");\n                        output.end_statement();\n                    });\n                }\n                if (!defined_methods[\"__str__\"]) {\n                    define_default_method(\"__str__\", function() {\n                        output.spaced(\"return\", \"this.__repr__()\");\n                        output.end_statement();\n                    });\n                }\n                self.statements.forEach(function(stmt) {\n                    if (!(stmt instanceof AST_Method)) {\n                        output.indent();\n                        stmt.print(output);\n                        output.newline();\n                    }\n                });\n            });\n            DEFPRINT(AST_Class, function(self, output) {\n                self._do_print(output);\n            });\n            AST_Exit.DEFMETHOD(\"_do_print\", function(output, kind) {\n                var self;\n                self = this;\n                output.print(kind);\n                if (self.value) {\n                    output.space();\n                    self.value.print(output);\n                }\n                output.semicolon();\n            });\n            DEFPRINT(AST_Yield, function(self, output) {\n                self._do_print(output, \"yield\" + ((self.is_yield_from) ? \"*\" : \"\"));\n            });\n            DEFPRINT(AST_Return, function(self, output) {\n                self._do_print(output, \"return\");\n            });\n            DEFPRINT(AST_Throw, function(self, output) {\n                self._do_print(output, \"throw\");\n            });\n            AST_LoopControl.DEFMETHOD(\"_do_print\", function(output, kind) {\n                output.print(kind);\n                if (this.label) {\n                    output.space();\n                    this.label.print(output);\n                }\n                output.semicolon();\n            });\n            DEFPRINT(AST_Break, function(self, output) {\n                self._do_print(output, \"break\");\n            });\n            DEFPRINT(AST_Continue, function(self, output) {\n                self._do_print(output, \"continue\");\n            });\n            function make_then(self, output) {\n                var b;\n                if (output.option(\"bracketize\")) {\n                    make_block(self.body, output);\n                    return;\n                }\n                if (!self.body) {\n                    return output.force_semicolon();\n                }\n                if (self.body instanceof AST_Do && output.option(\"ie_proof\")) {\n                    make_block(self.body, output);\n                    return;\n                }\n                b = self.body;\n                while (true) {\n                    if (b instanceof AST_If) {\n                        if (!b.alternative) {\n                            make_block(self.body, output);\n                            return;\n                        }\n                        b = b.alternative;\n                    } else if (b instanceof AST_StatementWithBody) {\n                        b = b.body;\n                    } else {\n                        break;\n                    }\n                }\n                force_statement(self.body, output);\n            }\n            DEFPRINT(AST_If, function(self, output) {\n                output.print(\"if\");\n                output.space();\n                output.with_parens(function() {\n                    self.condition.print(output);\n                });\n                output.space();\n                if (self.alternative) {\n                    make_then(self, output);\n                    output.space();\n                    output.print(\"else\");\n                    output.space();\n                    force_statement(self.alternative, output);\n                } else {\n                    self._do_print_body(output);\n                }\n            });\n            DEFPRINT(AST_Try, function(self, output) {\n                output.print(\"try\");\n                output.space();\n                print_bracketed(self, output);\n                if (self.bcatch) {\n                    output.space();\n                    self.bcatch.print(output);\n                }\n                if (self.bfinally) {\n                    output.space();\n                    self.bfinally.print(output);\n                }\n            });\n            DEFPRINT(AST_Catch, function(self, output) {\n                output.print(\"catch\");\n                output.space();\n                output.with_parens(function() {\n                    output.print(\"_$rapyd$_Exception\");\n                });\n                output.space();\n                if (self.body.length > 1 || self.body[0].errors.length) {\n                    output.with_block(function() {\n                        var no_default;\n                        output.indent();\n                        no_default = true;\n                        self.body.forEach(function(exception, i) {\n                            if (i) {\n                                output.print(\"else \");\n                            }\n                            if (exception.errors.length) {\n                                output.print(\"if\");\n                                output.space();\n                                output.with_parens(function() {\n                                    exception.errors.forEach(function(err, i) {\n                                        if (i) {\n                                            output.newline();\n                                            output.indent();\n                                            output.print(\"||\");\n                                            output.space();\n                                        }\n                                        output.print(\"_$rapyd$_Exception\");\n                                        output.space();\n                                        output.print(\"instanceof\");\n                                        output.space();\n                                        err.print(output);\n                                    });\n                                });\n                                output.space();\n                            } else {\n                                no_default = false;\n                            }\n                            print_bracketed(exception, output, true);\n                            output.space();\n                        });\n                        if (no_default) {\n                            output.print(\"else\");\n                            output.space();\n                            output.with_block(function() {\n                                output.indent();\n                                output.print(\"throw\");\n                                output.space();\n                                output.print(\"_$rapyd$_Exception\");\n                                output.semicolon();\n                                output.newline();\n                            });\n                        }\n                        output.newline();\n                    });\n                } else {\n                    print_bracketed(self.body[0], output, true);\n                }\n            });\n            DEFPRINT(AST_Finally, function(self, output) {\n                output.print(\"finally\");\n                output.space();\n                print_bracketed(self, output);\n            });\n            AST_Definitions.DEFMETHOD(\"_do_print\", function(output, kind) {\n                var p, in_for, avoid_semicolon;\n                output.print(kind);\n                output.space();\n                this.definitions.forEach(function(def_, i) {\n                    if (i) {\n                        output.comma();\n                    }\n                    def_.print(output);\n                });\n                p = output.parent();\n                in_for = p instanceof AST_ForIn;\n                avoid_semicolon = in_for && p.init === this;\n                if (!avoid_semicolon) {\n                    output.semicolon();\n                }\n            });\n            DEFPRINT(AST_Var, function(self, output) {\n                self._do_print(output, \"var\");\n            });\n            DEFPRINT(AST_Const, function(self, output) {\n                self._do_print(output, \"const\");\n            });\n            function parenthesize_for_noin(node, output, noin) {\n                if (!noin) {\n                    node.print(output);\n                } else {\n                    try {\n                        node.walk(new TreeWalker(function(node) {\n                            if (node instanceof AST_Binary && node.operator === \"in\") {\n                                throw output;\n                            }\n                        }));\n                        node.print(output);\n                    } catch (_$rapyd$_Exception) {\n                        var ex = _$rapyd$_Exception;\n                        if (ex !== output) {\n                            throw ex;\n                        }\n                        node.print(output, true);\n                    }\n                }\n            }\n            DEFPRINT(AST_VarDef, function(self, output) {\n                var p, noin;\n                self.name.print(output);\n                if (self.value) {\n                    output.assign(\"\");\n                    p = output.parent(1);\n                    noin = p instanceof AST_ForIn;\n                    parenthesize_for_noin(self.value, output, noin);\n                }\n            });\n            DEFPRINT(AST_BaseCall, function(self, output) {\n                var has_kwarg_items, has_kwarg_formals, has_kwargs, output_kwargs, obj;\n                if (self instanceof AST_ClassCall) {\n                    if (self.static) {\n                        self.class.print(output);\n                        output.print(\".\");\n                        output.print(self.method);\n                    } else {\n                        self.class.print(output);\n                        output.print(\".prototype.\");\n                        output.print(self.method);\n                        output.print(\".call\");\n                    }\n                } else {\n                    self.expression.print(output);\n                }\n                if (self instanceof AST_New && no_constructor_parens(self, output)) {\n                    return;\n                }\n                has_kwarg_items = self.args.kwarg_items && self.args.kwarg_items.length;\n                has_kwarg_formals = self.args.kwargs && self.args.kwargs.length;\n                has_kwargs = has_kwarg_items || has_kwarg_formals;\n                output_kwargs = function() {\n                    output.print(\"_$rapyd$_desugar_kwargs(\");\n                    if (has_kwarg_items) {\n                        self.args.kwarg_items.forEach(function(kwname, i) {\n                            if (i > 0) {\n                                output.print(\",\");\n                                output.space();\n                            }\n                            kwname.print(output);\n                        });\n                        if (has_kwarg_formals) {\n                            output.print(\",\");\n                            output.space();\n                        }\n                    }\n                    if (has_kwarg_formals) {\n                        output.print(\"{\");\n                        self.args.kwargs.forEach(function(pair, i) {\n                            if (i) {\n                                output.comma();\n                            }\n                            pair[0].print(output);\n                            output.print(\":\");\n                            output.space();\n                            pair[1].print(output);\n                        });\n                        output.print(\"}\");\n                    }\n                    output.print(\")\");\n                };\n                if (self.args.starargs) {\n                    if (self instanceof AST_New) {\n                        obj = \"_$rapyd$_new_temp\";\n                    } else {\n                        obj = (self.expression.expression) ? self.expression.expression : \"this\";\n                    }\n                    output.print(\".apply\");\n                    output.with_parens(function() {\n                        var i, expr, is_first;\n                        if (typeof obj === \"string\") {\n                            output.print(obj);\n                        } else {\n                            obj.print(output);\n                        }\n                        output.comma();\n                        i = 0;\n                        while (i < self.args.length) {\n                            expr = self.args[i];\n                            is_first = i === 0;\n                            if (!is_first) {\n                                output.print(\".concat(\");\n                            }\n                            if (expr.is_array) {\n                                expr.print(output);\n                                i += 1;\n                            } else {\n                                output.print(\"[\");\n                                while (i < self.args.length && !self.args[i].is_array) {\n                                    self.args[i].print(output);\n                                    if (i + 1 < self.args.length && !self.args[i + 1].is_array) {\n                                        output.print(\",\");\n                                        output.space();\n                                    }\n                                    i += 1;\n                                }\n                                output.print(\"]\");\n                            }\n                            if (!is_first) {\n                                output.print(\")\");\n                            }\n                        }\n                        if (has_kwargs) {\n                            if (self.args.length) {\n                                output.print(\".concat(\");\n                            }\n                            output.print(\"[\");\n                            output_kwargs();\n                            output.print(\"]\");\n                            if (self.args.length) {\n                                output.print(\")\");\n                            }\n                        }\n                    });\n                } else {\n                    output.with_parens(function() {\n                        self.args.forEach(function(expr, i) {\n                            if (i) {\n                                output.comma();\n                            }\n                            expr.print(output);\n                        });\n                        if (has_kwargs) {\n                            if (self.args.length) {\n                                output.print(\",\");\n                                output.space();\n                            }\n                            output_kwargs();\n                        }\n                    });\n                }\n            });\n            DEFPRINT(AST_New, function(self, output) {\n                if (self.args.starargs) {\n                    output.with_parens(function() {\n                        output.print(\"function()\");\n                        output.with_block(function() {\n                            output.indent();\n                            output.print(\"var _$rapyd$_new_temp = Object.create(\");\n                            self.expression.print(output);\n                            output.print(\")\");\n                            [output.end_statement(), output.indent()];\n                            AST_BaseCall.prototype._codegen(self, output);\n                            [output.end_statement(), output.indent()];\n                            output.print(\"return _$rapyd$_new_temp\");\n                            output.end_statement();\n                        });\n                    });\n                    output.print(\"()\");\n                } else {\n                    output.print(\"new\");\n                    output.space();\n                    AST_BaseCall.prototype._codegen(self, output);\n                }\n            });\n            AST_Seq.DEFMETHOD(\"_do_print\", function(output) {\n                var self, p, print_seq;\n                self = this;\n                p = output.parent();\n                print_seq = function() {\n                    self.car.print(output);\n                    if (self.cdr) {\n                        output.comma();\n                        if (output.should_break()) {\n                            output.newline();\n                            output.indent();\n                        }\n                        self.cdr.print(output);\n                    }\n                };\n                if (p instanceof AST_Binary || p instanceof AST_Return || p instanceof AST_Array || p instanceof AST_BaseCall || p instanceof AST_SimpleStatement) {\n                    output.with_square(print_seq);\n                } else {\n                    print_seq();\n                }\n            });\n            DEFPRINT(AST_Seq, function(self, output) {\n                self._do_print(output);\n            });\n            DEFPRINT(AST_Dot, function(self, output) {\n                var expr;\n                expr = self.expression;\n                expr.print(output);\n                if (expr instanceof AST_Number && expr.getValue() >= 0) {\n                    if (!/[xa-f.]/i.test(output.last())) {\n                        output.print(\".\");\n                    }\n                }\n                output.print(\".\");\n                output.add_mapping(self.end);\n                output.print_name(self.property);\n            });\n            DEFPRINT(AST_Sub, function(self, output) {\n                self.expression.print(output);\n                output.print(\"[\");\n                if (self.property instanceof AST_Unary && self.property.operator === \"-\" && self.property.expression instanceof AST_Number) {\n                    self.expression.print(output);\n                    output.print(\".length\");\n                }\n                self.property.print(output);\n                output.print(\"]\");\n            });\n            DEFPRINT(AST_ItemAccess, function(self, output) {\n                self.expression.print(output);\n                output.print(\".__\" + ((self.assignment) ? \"setitem\" : \"getitem\") + \"__\");\n                output.with_parens(function() {\n                    self.property.print(output);\n                    if (self.assignment) {\n                        output.comma();\n                        self.assignment.print(output);\n                    }\n                });\n            });\n            DEFPRINT(AST_Splice, function(self, output) {\n                output.print(\"[].splice.apply\");\n                output.with_parens(function() {\n                    self.expression.print(output);\n                    output.comma();\n                    output.with_square(function() {\n                        self.property.print(output);\n                        output.comma();\n                        self.property2.print(output);\n                        output.print(\"-\");\n                        self.property.print(output);\n                    });\n                    output.print(\".concat\");\n                    output.with_parens(function() {\n                        self.assignment.print(output);\n                    });\n                });\n            });\n            DEFPRINT(AST_UnaryPrefix, function(self, output) {\n                var op;\n                op = self.operator;\n                output.print(op);\n                if (/^[a-z]/i.test(op)) {\n                    output.space();\n                }\n                self.expression.print(output);\n            });\n            DEFPRINT(AST_UnaryPostfix, function(self, output) {\n                self.expression.print(output);\n                output.print(self.operator);\n            });\n            function write_instanceof(left, right, output) {\n                function single(left, right) {\n                    if (right.name === \"Array\" || right.name === \"list\") {\n                        output.print(\"Array.isArray\");\n                        output.with_parens(function() {\n                            left.print(output);\n                        });\n                    } else {\n                        output.spaced(left, \"instanceof\", right);\n                    }\n                }\n                if (right instanceof AST_Seq) {\n                    right = new AST_Array({\n                        \"elements\": right.to_array()\n                    });\n                }\n                if (right instanceof AST_Array) {\n                    output.with_parens(function() {\n                        right.elements.forEach(function(right, i, arr) {\n                            single(left, right);\n                            if (arr.length > 1 && i < arr.length - 1) {\n                                [output.space(), output.print(\"||\"), output.space()];\n                            }\n                        });\n                    });\n                } else {\n                    single(left, right);\n                }\n            }\n            function write_smart_equality(self, output) {\n                function is_ok(x) {\n                    return !((x instanceof AST_Array || x instanceof AST_Set || x instanceof AST_Object || x instanceof AST_Statement || x instanceof AST_Binary || x instanceof AST_Conditional || x instanceof AST_BaseCall));\n                }\n                if (is_ok(self.left) && is_ok(self.right)) {\n                    if (self.operator === \"==\") {\n                        output.print(\"(\");\n                        output.spaced(self.left, \"===\", self.right, \"||\", \"typeof\", self.left, \"===\", \"\\\"object\\\"\", \"&&\", \"_$rapyd$_equals(\");\n                        [self.left.print(output), output.print(\",\"), output.space(), self.right.print(output), \n                        output.print(\"))\")];\n                    } else {\n                        output.print(\"(\");\n                        output.spaced(self.left, \"!==\", self.right, \"&&\", \"(typeof\", self.left, \"!==\", \"\\\"object\\\"\", \"||\", \"_$rapyd$_not_equals(\");\n                        [self.left.print(output), output.print(\",\"), output.space(), self.right.print(output), \n                        output.print(\")))\")];\n                    }\n                } else {\n                    output.print(\"_$rapyd$_\" + ((self.operator === \"==\") ? \"equals(\" : \"not_equals(\"));\n                    [self.left.print(output), output.print(\",\"), output.space(), self.right.print(output), \n                    output.print(\")\")];\n                }\n            }\n            DEFPRINT(AST_Binary, function(self, output) {\n                var comparators, function_ops, leftvar;\n                comparators = {\n                    \"<\": true,\n                    \">\": true,\n                    \"<=\": true,\n                    \">=\": true,\n                    \"==\": true,\n                    \"!=\": true\n                };\n                function_ops = {\n                    \"in\": \"_$rapyd$_in\",\n                    \"**\": \"Math.pow\"\n                };\n                if (_$rapyd$_in(self.operator, function_ops)) {\n                    output.print(function_ops[self.operator]);\n                    output.with_parens(function() {\n                        self.left.print(output);\n                        output.comma();\n                        self.right.print(output);\n                    });\n                } else if (comparators[self.operator] && self.left instanceof AST_Binary && comparators[self.left.operator]) {\n                    if (self.left.right instanceof AST_Symbol) {\n                        self.left.print(output);\n                        leftvar = self.left.right.name;\n                    } else {\n                        self.left.left.print(output);\n                        output.space();\n                        output.print(self.left.operator);\n                        output.space();\n                        output.with_parens(function() {\n                            output.assign(\"_$rapyd$_cond_temp\");\n                            self.left.right.print(output);\n                            leftvar = \"_$rapyd$_cond_temp\";\n                        });\n                    }\n                    output.space();\n                    output.print(\"&&\");\n                    output.space();\n                    output.print(leftvar);\n                    output.space();\n                    output.print(self.operator);\n                    output.space();\n                    self.right.print(output);\n                } else if (self.operator === \"//\") {\n                    output.print(\"Math.floor\");\n                    output.with_parens(function() {\n                        self.left.print(output);\n                        output.space();\n                        output.print(\"/\");\n                        output.space();\n                        self.right.print(output);\n                    });\n                } else if (self.operator === \"==\" || self.operator === \"!=\") {\n                    write_smart_equality(self, output);\n                } else if (self.operator === \"instanceof\") {\n                    write_instanceof(self.left, self.right, output);\n                } else {\n                    output.spaced(self.left, self.operator, self.right);\n                }\n            });\n            function print_assignment(self, output) {\n                var flattened, left, flat;\n                flattened = false;\n                left = self.left;\n                if (left instanceof AST_Seq) {\n                    left = new AST_Array({\n                        \"elements\": [left.car, left.cdr]\n                    });\n                }\n                if (left instanceof AST_Array) {\n                    flat = left.flatten();\n                    flattened = flat.length > left.elements.length;\n                    output.print(\"_$rapyd$_unpack\");\n                } else {\n                    left.print(output);\n                }\n                output.space();\n                output.print(self.operator);\n                output.space();\n                if (flattened) {\n                    output.print(\"_$rapyd$_flatten\");\n                    output.with_parens(function() {\n                        self.right.print(output);\n                    });\n                } else {\n                    self.right.print(output);\n                }\n                if (left instanceof AST_Array) {\n                    output.semicolon();\n                    output.newline();\n                    unpack_tuple(flat, output, true);\n                }\n            }\n            DEFPRINT(AST_Assign, function(self, output) {\n                var _$rapyd$_unpack, left_hand_sides, rhs, temp_rhs, lhs;\n                if (self.operator === \"//=\") {\n                    output.assign(self.left);\n                    output.print(\"Math.floor\");\n                    output.with_parens(function() {\n                        self.left.print(output);\n                        output.space();\n                        output.print(\"/\");\n                        output.space();\n                        self.right.print(output);\n                    });\n                    return;\n                }\n                if (self.operator === \"=\" && self.is_chained()) {\n                    _$rapyd$_unpack = self.traverse_chain();\n                    left_hand_sides = _$rapyd$_unpack[0];\n                    rhs = _$rapyd$_unpack[1];\n                    temp_rhs = new AST_SymbolRef({\n                        \"name\": \"_$rapyd$_chain_assign_temp\"\n                    });\n                    print_assignment(new AST_Assign({\n                        \"left\": temp_rhs,\n                        \"operator\": \"=\",\n                        \"right\": rhs\n                    }), output);\n                    [output.end_statement(), output.indent()];\n                    var _$rapyd$_Iter76 = _$rapyd$_Iterable(left_hand_sides);\n                    for (var _$rapyd$_Index76 = 0; _$rapyd$_Index76 < _$rapyd$_Iter76.length; _$rapyd$_Index76++) {\n                        lhs = _$rapyd$_Iter76[_$rapyd$_Index76];\n                        print_assignment(new AST_Assign({\n                            \"left\": lhs,\n                            \"right\": temp_rhs,\n                            \"operator\": self.operator\n                        }), output);\n                        output.end_statement();\n                        if (lhs !== left_hand_sides[left_hand_sides.length-1]) {\n                            output.indent();\n                        }\n                    }\n                } else {\n                    print_assignment(self, output);\n                }\n            });\n            function write_conditional(output, condition, consequent, alternative) {\n                output.with_parens(function() {\n                    condition.print(output);\n                });\n                output.space();\n                output.print(\"?\");\n                output.space();\n                consequent.print(output);\n                output.space();\n                output.colon();\n                alternative.print(output);\n            }\n            DEFPRINT(AST_Conditional, function(self, output) {\n                write_conditional(output, self.condition, self.consequent, self.alternative);\n            });\n            DEFPRINT(AST_Array, function(self, output) {\n                output.print(\"_$rapyd$_list_decorate\");\n                output.with_parens(function() {\n                    output.with_square(function() {\n                        var a, len_;\n                        a = self.elements;\n                        len_ = a.length;\n                        if (len_ > 0) {\n                            output.space();\n                        }\n                        a.forEach(function(exp, i) {\n                            if (i) {\n                                output.comma();\n                            }\n                            exp.print(output);\n                        });\n                        if (len_ > 0) {\n                            output.space();\n                        }\n                    });\n                });\n            });\n            function write_obj_literal(self, output) {\n                output.with_parens(function() {\n                    output.print(\"function()\");\n                    output.with_block(function() {\n                        output.indent();\n                        if (self.is_pydict) {\n                            output.spaced.apply(output, \"var _$rapyd$_d = _$rapyd$_dict()\".split(\" \"));\n                        } else {\n                            output.spaced.apply(output, \"var _$rapyd$_d = {}\".split(\" \"));\n                        }\n                        output.end_statement();\n                        self.properties.forEach(function(prop, i) {\n                            output.indent();\n                            if (self.is_pydict) {\n                                output.print(\"_$rapyd$_d.set\");\n                                output.with_parens(function() {\n                                    prop.key.print(output);\n                                    [output.print(\",\"), output.space()];\n                                    prop.value.print(output);\n                                });\n                            } else {\n                                output.print(\"_$rapyd$_d\");\n                                output.with_square(function() {\n                                    prop.key.print(output);\n                                });\n                                [output.space(), output.print(\"=\"), output.space()];\n                                prop.value.print(output);\n                            }\n                            output.end_statement();\n                        });\n                        output.indent();\n                        output.spaced(\"return\", \"_$rapyd$_d\");\n                        output.end_statement();\n                    });\n                });\n                output.print(\"()\");\n            }\n            DEFPRINT(AST_ExpressiveObject, write_obj_literal);\n            DEFPRINT(AST_Object, function(self, output) {\n                if (self.is_pydict) {\n                    if (self.properties.length > 0) {\n                        write_obj_literal(self, output);\n                    } else {\n                        output.print(\"_$rapyd$_dict()\");\n                    }\n                } else {\n                    if (self.properties.length > 0) {\n                        output.with_block(function() {\n                            self.properties.forEach(function(prop, i) {\n                                if (i) {\n                                    output.print(\",\");\n                                    output.newline();\n                                }\n                                output.indent();\n                                prop.print(output);\n                            });\n                            output.newline();\n                        });\n                    } else {\n                        output.print(\"{}\");\n                    }\n                }\n            });\n            DEFPRINT(AST_ObjectKeyVal, function(self, output) {\n                self.key.print(output);\n                output.colon();\n                self.value.print(output);\n            });\n            DEFPRINT(AST_Set, function(self, output) {\n                if (self.items.length === 0) {\n                    output.print(\"_$rapyd$_set()\");\n                    return;\n                }\n                output.with_parens(function() {\n                    output.print(\"function()\");\n                    output.with_block(function() {\n                        output.indent();\n                        output.spaced.apply(output, \"var s = _$rapyd$_set()\".split(\" \"));\n                        output.end_statement();\n                        self.items.forEach(function(item, i) {\n                            output.indent();\n                            output.print(\"s.jsset.add\");\n                            output.with_parens(function() {\n                                item.value.print(output);\n                            });\n                            output.end_statement();\n                        });\n                        output.indent();\n                        output.spaced(\"return\", \"s\");\n                        output.end_statement();\n                    });\n                });\n                output.print(\"()\");\n            });\n            AST_Symbol.DEFMETHOD(\"definition\", function() {\n                return this.thedef;\n            });\n            DEFPRINT(AST_Symbol, function(self, output) {\n                var def_;\n                def_ = self.definition();\n                output.print_name((def_) ? def_.mangled_name || def_.name : self.name);\n            });\n            DEFPRINT(AST_Undefined, function(self, output) {\n                output.print(\"void 0\");\n            });\n            DEFPRINT(AST_Hole, noop);\n            DEFPRINT(AST_Infinity, function(self, output) {\n                output.print(\"1/0\");\n            });\n            DEFPRINT(AST_NaN, function(self, output) {\n                output.print(\"0/0\");\n            });\n            DEFPRINT(AST_This, function(self, output) {\n                output.print(\"this\");\n            });\n            DEFPRINT(AST_Constant, function(self, output) {\n                output.print(self.getValue());\n            });\n            DEFPRINT(AST_String, function(self, output) {\n                output.print_string(self.getValue());\n            });\n            DEFPRINT(AST_Verbatim, function(self, output) {\n                output.print(self.getValue());\n            });\n            DEFPRINT(AST_Number, function(self, output) {\n                output.print(make_num(self.getValue()));\n            });\n            DEFPRINT(AST_RegExp, function(self, output) {\n                var str_, p;\n                str_ = self.getValue().toString();\n                if (output.option(\"ascii_only\")) {\n                    str_ = output.to_ascii(str_);\n                }\n                output.print(str_);\n                p = output.parent();\n                if (p instanceof AST_Binary && /^in/.test(p.operator) && p.left === self) {\n                    output.print(\" \");\n                }\n            });\n            function force_statement(stat, output) {\n                if (output.option(\"bracketize\")) {\n                    if (!stat || stat instanceof AST_EmptyStatement) {\n                        output.print(\"{}\");\n                    } else if (stat instanceof AST_BlockStatement) {\n                        stat.print(output);\n                    } else {\n                        output.with_block(function() {\n                            output.indent();\n                            stat.print(output);\n                            output.newline();\n                        });\n                    }\n                } else {\n                    if (!stat || stat instanceof AST_EmptyStatement) {\n                        output.force_semicolon();\n                    } else {\n                        stat.print(output);\n                    }\n                }\n            }\n            function first_in_statement(output) {\n                var a, i, node, p;\n                a = output.stack();\n                i = a.length;\n                node = a[i -= 1];\n                p = a[i -= 1];\n                while (i > 0) {\n                    if (p instanceof AST_Statement && p.body === node) {\n                        return true;\n                    }\n                    if (p instanceof AST_Seq && p.car === node || p instanceof AST_BaseCall && p.expression === node || p instanceof AST_Dot && p.expression === node || p instanceof AST_Sub && p.expression === node || p instanceof AST_ItemAccess && p.expression === node || p instanceof AST_Conditional && p.condition === node || p instanceof AST_Binary && p.left === node || p instanceof AST_UnaryPostfix && p.expression === node) {\n                        node = p;\n                        p = a[i -= 1];\n                    } else {\n                        return false;\n                    }\n                }\n            }\n            function no_constructor_parens(self, output) {\n                return self.args.length === 0 && !output.option(\"beautify\");\n            }\n            function best_of(a) {\n                var best, len_, i;\n                best = a[0];\n                len_ = best.length;\n                for (var _$rapyd$_Index77 = 1; _$rapyd$_Index77 < a.length; _$rapyd$_Index77++) {\n                    i = _$rapyd$_Index77;\n                    if (a[i].length < len_) {\n                        best = a[i];\n                        len_ = best.length;\n                    }\n                }\n                return best;\n            }\n            function make_num(num) {\n                var str_, a, m;\n                str_ = num.toString(10);\n                a = _$rapyd$_list_decorate([ str_.replace(/^0\\./, \".\").replace(\"e+\", \"e\") ]);\n                m = null;\n                if (Math.floor(num) === num) {\n                    if (num >= 0) {\n                        a.push(\"0x\" + num.toString(16).toLowerCase(), \"0\" + num.toString(8));\n                    } else {\n                        a.push(\"-0x\" + (-num).toString(16).toLowerCase(), \"-0\" + (-num).toString(8));\n                    }\n                    if (m = /^(.*?)(0+)$/.exec(num)) {\n                        a.push(m[1] + \"e\" + m[2].length);\n                    }\n                } else if (m = /^0?\\.(0+)(.*)$/.exec(num)) {\n                    a.push(m[2] + \"e-\" + (m[1].length + m[2].length), str_.substr(str_.indexOf(\".\")));\n                }\n                return best_of(a);\n            }\n            function make_block(stmt, output) {\n                if (stmt instanceof AST_BlockStatement) {\n                    stmt.print(output);\n                    return;\n                }\n                output.with_block(function() {\n                    output.indent();\n                    stmt.print(output);\n                    output.newline();\n                });\n            }\n            function DEFMAP(nodetype, generator) {\n                nodetype.DEFMETHOD(\"add_source_map\", function(stream) {\n                    generator(this, stream);\n                });\n            }\n            DEFMAP(AST_Node, noop);\n            function basic_sourcemap_gen(self, output) {\n                output.add_mapping(self.start);\n            }\n            DEFMAP(AST_Directive, basic_sourcemap_gen);\n            DEFMAP(AST_Debugger, basic_sourcemap_gen);\n            DEFMAP(AST_Symbol, basic_sourcemap_gen);\n            DEFMAP(AST_Jump, basic_sourcemap_gen);\n            DEFMAP(AST_StatementWithBody, basic_sourcemap_gen);\n            DEFMAP(AST_Lambda, basic_sourcemap_gen);\n            DEFMAP(AST_BlockStatement, basic_sourcemap_gen);\n            DEFMAP(AST_Toplevel, noop);\n            DEFMAP(AST_New, basic_sourcemap_gen);\n            DEFMAP(AST_Try, basic_sourcemap_gen);\n            DEFMAP(AST_Catch, basic_sourcemap_gen);\n            DEFMAP(AST_Finally, basic_sourcemap_gen);\n            DEFMAP(AST_Definitions, basic_sourcemap_gen);\n            DEFMAP(AST_Constant, basic_sourcemap_gen);\n            DEFMAP(AST_ObjectProperty, function(self, output) {\n                output.add_mapping(self.start, self.key);\n            });\n        }\n        codegen();\n        _$rapyd$_modules[\"output\"][\"DANGEROUS\"] = DANGEROUS;\n\n        _$rapyd$_modules[\"output\"][\"OutputStream\"] = OutputStream;\n\n        _$rapyd$_modules[\"output\"][\"codegen\"] = codegen;\n    })();\n\n    (function(){\n\n        var __name__ = \"__main__\";\n\n\n        var ast, ast_node;\n        var DefaultsError = _$rapyd$_modules[\"utils\"].DefaultsError;\n        var string_template = _$rapyd$_modules[\"utils\"].string_template;\n        \n        var ImportError = _$rapyd$_modules[\"errors\"].ImportError;\n        var SyntaxError = _$rapyd$_modules[\"errors\"].SyntaxError;\n        \n        var ALL_KEYWORDS = _$rapyd$_modules[\"tokenizer\"].ALL_KEYWORDS;\n        var IDENTIFIER_PAT = _$rapyd$_modules[\"tokenizer\"].IDENTIFIER_PAT;\n        var tokenizer = _$rapyd$_modules[\"tokenizer\"].tokenizer;\n        \n        var parse = _$rapyd$_modules[\"parse\"].parse;\n        var NATIVE_CLASSES = _$rapyd$_modules[\"parse\"].NATIVE_CLASSES;\n        var compile_time_decorators = _$rapyd$_modules[\"parse\"].compile_time_decorators;\n        \n        var OutputStream = _$rapyd$_modules[\"output\"].OutputStream;\n        \n        if (typeof exports === \"object\") {\n            exports.DefaultsError = DefaultsError;\n            exports.parse = parse;\n            exports.compile_time_decorators = compile_time_decorators;\n            exports.OutputStream = OutputStream;\n            exports.string_template = string_template;\n            exports.ALL_KEYWORDS = ALL_KEYWORDS;\n            exports.IDENTIFIER_PAT = IDENTIFIER_PAT;\n            exports.NATIVE_CLASSES = NATIVE_CLASSES;\n            exports.ImportError = ImportError;\n            exports.SyntaxError = SyntaxError;\n            exports.tokenizer = tokenizer;\n            ast = _$rapyd$_modules[\"ast\"];\n            var _$rapyd$_Iter78 = _$rapyd$_Iterable(ast);\n            for (var _$rapyd$_Index78 = 0; _$rapyd$_Index78 < _$rapyd$_Iter78.length; _$rapyd$_Index78++) {\n                ast_node = _$rapyd$_Iter78[_$rapyd$_Index78];\n                if (ast_node.substr(0, 4) === \"AST_\") {\n                    exports[ast_node] = ast[ast_node];\n                }\n            }\n        }\n    })();\n})();","baselib-plain-pretty.js":"var _$rapyd$_iterator_symbol = (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") ? Symbol.iterator : \"iterator-Symbol-5d0927e5554349048cf0e3762a228256\";\nvar _$rapyd$_kwargs_symbol = (typeof Symbol === \"function\") ? Symbol(\"kwargs-object\") : \"kwargs-object-Symbol-5d0927e5554349048cf0e3762a228256\";\nvar _$rapyd$_cond_temp;\nvar _$rapyd$_object_counter = 0;\nvar abs = (function abs() {\n            return Math.abs;\n        })();\nvar max = (function max() {\n            return Math.max;\n        })();\nvar min = (function min() {\n            return Math.min;\n        })();\nfunction dir(item) {\n            var arr;\n            arr = _$rapyd$_list_decorate([]);\n            for (var i in item) {\n                arr.push(i);\n            }\n            return arr;\n        };\nfunction ord(x) {\n            var ans, second;\n            ans = x.charCodeAt(0);\n            if (55296 <= ans && ans <= 56319) {\n                second = x.charCodeAt(1);\n                if (56320 <= second && second <= 57343) {\n                    return (ans - 55296) * 1024 + second - 56320 + 65536;\n                }\n                throw new TypeError(\"string is missing the low surrogate char\");\n            }\n            return ans;\n        };\nfunction chr(code) {\n            if (code <= 65535) {\n                return String.fromCharCode(code);\n            }\n            code -= 65536;\n            return String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n        };\nfunction bin(x) {\n            var ans;\n            if (typeof x !== \"number\" || x % 1 !== 0) {\n                throw new TypeError(\"integer required\");\n            }\n            ans = x.toString(2);\n            if (ans[0] === \"-\") {\n                ans = \"-\" + \"0b\" + ans.slice(1);\n            } else {\n                ans = \"0b\" + ans;\n            }\n            return ans;\n        };\nfunction hex(x) {\n            var ans;\n            if (typeof x !== \"number\" || x % 1 !== 0) {\n                throw new TypeError(\"integer required\");\n            }\n            ans = x.toString(16);\n            if (ans[0] === \"-\") {\n                ans = \"-\" + \"0x\" + ans.slice(1);\n            } else {\n                ans = \"0x\" + ans;\n            }\n            return ans;\n        };\nfunction callable(x) {\n            return typeof x === \"function\";\n        };\nfunction enumerate(iterable) {\n            var ans, iterator;\n            if (_$rapyd$_arraylike(iterable)) {\n                ans = {\n                    \"_i\": -1,\n                    \"next\": function() {\n                        this._i += 1;\n                        if (this._i < iterable.length) {\n                            return {\n                                \"done\": false,\n                                \"value\": _$rapyd$_list_decorate([ this._i, iterable[this._i] ])\n                            };\n                        }\n                        return {\n                            \"done\": true\n                        };\n                    }\n                };\n                ans[_$rapyd$_iterator_symbol] = function() {\n                    return this;\n                };\n                return ans;\n            }\n            if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n                iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n                ans = {\n                    \"_iterator\": iterator,\n                    \"_i\": -1,\n                    \"next\": function() {\n                        var r;\n                        r = this._iterator.next();\n                        if (r.done) {\n                            return {\n                                \"done\": true\n                            };\n                        }\n                        this._i += 1;\n                        return {\n                            \"done\": false,\n                            \"value\": _$rapyd$_list_decorate([ this._i, r.value ])\n                        };\n                    }\n                };\n                ans[_$rapyd$_iterator_symbol] = function() {\n                    return this;\n                };\n                return ans;\n            }\n            return enumerate(Object.keys(iterable));\n        };\nfunction iter(iterable) {\n            var ans;\n            if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n                return (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n            }\n            if (_$rapyd$_arraylike(iterable)) {\n                ans = {\n                    \"_i\": -1,\n                    \"next\": function() {\n                        this._i += 1;\n                        if (this._i < iterable.length) {\n                            return {\n                                \"done\": false,\n                                \"value\": iterable[this._i]\n                            };\n                        }\n                        return {\n                            \"done\": true\n                        };\n                    }\n                };\n                ans[_$rapyd$_iterator_symbol] = function() {\n                    return this;\n                };\n                return ans;\n            }\n            return iter(Object.keys(iterable));\n        };\nfunction _$rapyd$_extends(child, parent) {\n            child.prototype = Object.create(parent.prototype);\n            child.prototype.constructor = child;\n        };\nfunction _$rapyd$_flatten(arr) {\n            var ans, value;\n            ans = _$rapyd$_list_decorate([]);\n            for (var i=0; i<arr.length; i++) {\n                value = arr[i];\n                if (Array.isArray(value)) {\n                    ans = ans.concat(_$rapyd$_flatten(value));\n                } else {\n                    ans.push(value);\n                }\n            }\n            return ans;\n        };\nvar _$rapyd$_in = (function _$rapyd$_in() {\n            if (typeof Map === \"function\" && typeof Set === \"function\") {\n                return function(val, arr) {\n                    if (typeof arr === \"string\") {\n                        return arr.indexOf(val) !== -1;\n                    }\n                    if (typeof arr.__contains__ === \"function\") {\n                        return arr.__contains__(val);\n                    }\n                    if ((arr instanceof Map || arr instanceof Set)) {\n                        return arr.has(val);\n                    }\n                    if (_$rapyd$_arraylike(arr)) {\n                        return _$rapyd$_list_contains.call(arr, val);\n                    }\n                    return Object.prototype.hasOwnProperty.call(arr, val);\n                };\n            }\n            return function(val, arr) {\n                if (typeof arr === \"string\") {\n                    return arr.indexOf(val) !== -1;\n                }\n                if (typeof arr.__contains__ === \"function\") {\n                    return arr.__contains__(val);\n                }\n                if (_$rapyd$_arraylike(arr)) {\n                    return _$rapyd$_list_contains.call(arr, val);\n                }\n                return Object.prototype.hasOwnProperty.call(arr, val);\n            };\n        })();\nfunction _$rapyd$_Iterable(iterable) {\n            var iterator, ans, result;\n            if (_$rapyd$_arraylike(iterable)) {\n                return iterable;\n            }\n            if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n                iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n                ans = _$rapyd$_list_decorate([]);\n                result = iterator.next();\n                while (!result.done) {\n                    ans.push(result.value);\n                    result = iterator.next();\n                }\n                return ans;\n            }\n            return Object.keys(iterable);\n        };\nvar len = (function _$rapyd$_len() {\n            if (typeof Set === \"function\" && typeof Map === \"function\") {\n                return function(obj) {\n                    if (_$rapyd$_arraylike(obj)) {\n                        return obj.length;\n                    }\n                    if (obj instanceof Set || obj instanceof Map) {\n                        return obj.size;\n                    }\n                    if (typeof obj.__len__ === \"function\") {\n                        return obj.__len__();\n                    }\n                    return Object.keys(obj).length;\n                };\n            }\n            return function(obj) {\n                if (_$rapyd$_arraylike(obj)) {\n                    return obj.length;\n                }\n                if (typeof obj.__len__ === \"function\") {\n                    return obj.__len__();\n                }\n                return Object.keys(obj).length;\n            };\n        })();\nfunction range(start, stop, step) {\n            var length;\n            if (arguments.length <= 1) {\n                stop = start || 0;\n                start = 0;\n            }\n            step = arguments[2] || 1;\n            length = Math.max(Math.ceil((stop - start) / step), 0);\n            return (function(){\n                var _$rapyd$_d = {};\n                _$rapyd$_d[_$rapyd$_iterator_symbol] = function() {\n                    return this;\n                };\n                _$rapyd$_d[\"_i\"] = start - step;\n                _$rapyd$_d[\"_idx\"] = -1;\n                _$rapyd$_d[\"next\"] = function() {\n                    this._i += step;\n                    this._idx += 1;\n                    if (this._idx >= length) {\n                        return {\n                            \"done\": true\n                        };\n                    }\n                    return {\n                        \"done\": false,\n                        \"value\": this._i\n                    };\n                };\n                return _$rapyd$_d;\n            })();\n        };\nfunction reversed(iterable) {\n            var ans;\n            if (_$rapyd$_arraylike(iterable)) {\n                ans = {\n                    \"_i\": iterable.length,\n                    \"next\": function() {\n                        this._i -= 1;\n                        if (this._i > -1) {\n                            return {\n                                \"done\": false,\n                                \"value\": iterable[this._i]\n                            };\n                        }\n                        return {\n                            \"done\": true\n                        };\n                    }\n                };\n                ans[_$rapyd$_iterator_symbol] = function() {\n                    return this;\n                };\n                return ans;\n            }\n            throw new TypeError(\"reversed() can only be called on arrays or strings\");\n        };\nfunction getattr(obj, name, defval) {\n            var ret;\n            try {\n                ret = obj[name];\n            } catch (_$rapyd$_Exception) {\n                if (_$rapyd$_Exception instanceof TypeError) {\n                    if (defval === undefined) {\n                        throw new AttributeError(\"The attribute \" + name + \" is not present\");\n                    }\n                    return defval;\n                } else {\n                    throw _$rapyd$_Exception;\n                }\n            }\n            if (ret === undefined && !(name in obj)) {\n                if (defval === undefined) {\n                    throw new AttributeError(\"The attribute \" + name + \" is not present\");\n                }\n                ret = defval;\n            }\n            return ret;\n        };\nfunction setattr(obj, name, value) {\n            obj[name] = value;\n        };\nfunction hasattr(obj, name) {\n            return name in obj;\n        };\nvar _$rapyd$_desugar_kwargs = (function _$rapyd$_desugar_kwargs() {\n            if (typeof Object.assign === \"function\") {\n                return function() {\n                    var ans;\n                    ans = {};\n                    ans[_$rapyd$_kwargs_symbol] = true;\n                    for (var i = 0; i < arguments.length; i++) {\n                        Object.assign(ans, arguments[i]);\n                    }\n                    return ans;\n                };\n            }\n            return function() {\n                var ans, keys;\n                ans = {};\n                ans[_$rapyd$_kwargs_symbol] = true;\n                for (var i = 0; i < arguments.length; i++) {\n                    keys = Object.keys(arguments[i]);\n                    for (var j = 0; j < keys.length; j++) {\n                        ans[keys[j]] = arguments[i][keys[j]];\n                    }\n                }\n                return ans;\n            };\n        })();\nfunction _$rapyd$_bool(val) {\n    return !!val;\n}\nfunction _$rapyd$_bind(fn, thisArg) {\n    var ret;\n    if (fn.orig) {\n        fn = fn.orig;\n    }\n    if (thisArg === false) {\n        return fn;\n    }\n    ret = function() {\n        return fn.apply(thisArg, arguments);\n    };\n    ret.orig = fn;\n    return ret;\n}\nfunction _$rapyd$_rebind_all(thisArg, rebind) {\n    if (typeof rebind === \"undefined\") {\n        rebind = true;\n    }\n    for (var p in thisArg) {\n        if (thisArg[p] && thisArg[p].orig) {\n            if (rebind) {\n                thisArg[p] = _$rapyd$_bind(thisArg[p], thisArg);\n            } else {\n                thisArg[p] = thisArg[p].orig;\n            }\n        }\n    }\n}\nfunction _$rapyd$_eslice(arr, step, start, end) {\n    var isString;\n    arr = arr.slice(0);\n    if (typeof arr === \"string\" || arr instanceof String) {\n        isString = true;\n        arr = arr.split(\"\");\n    }\n    if (step < 0) {\n        step = -step;\n        arr.reverse();\n        if (typeof start !== \"undefined\") {\n            start = arr.length - start - 1;\n        }\n        if (typeof end !== \"undefined\") {\n            end = arr.length - end - 1;\n        }\n    }\n    if (typeof start === \"undefined\") {\n        start = 0;\n    }\n    if (typeof end === \"undefined\") {\n        end = arr.length;\n    }\n    arr = arr.slice(start, end).filter(function(e, i) {\n        return i % step === 0;\n    });\n    return (isString) ? arr.join(\"\") : arr;\n}\nfunction _$rapyd$_mixin(target, source, overwrite) {\n    for (var i in source) {\n        if (source.hasOwnProperty(i) && overwrite || typeof target[i] === \"undefined\") {\n            target[i] = source[i];\n        }\n    }\n}\nfunction _$rapyd$_print() {\n    var parts;\n    if (typeof console === \"object\") {\n        parts = [];\n        for (var i = 0; i < arguments.length; i++) {\n            parts.push(_$rapyd$_str(arguments[i]));\n        }\n        console.log(parts.join(\" \"));\n    }\n}\nfunction _$rapyd$_int(val, base) {\n    var ans;\n    ans = parseInt(val, base || 10);\n    if (isNaN(ans)) {\n        throw new ValueError(\"Invalid literal for int with base \" + (base || 10) + \": \" + val);\n    }\n    return ans;\n}\nfunction _$rapyd$_float() {\n    var ans;\n    ans = parseFloat.apply(null, arguments);\n    if (isNaN(ans)) {\n        throw new ValueError(\"Could not convert string to float: \" + arguments[0]);\n    }\n    return ans;\n}\nfunction _$rapyd$_arraylike_creator() {\n    var names;\n    if (typeof HTMLCollection === \"function\") {\n        names = [\"[object HTMLCollection]\", \"[object NodeList]\", \"[object NamedNodeMap]\"];\n        return function(x) {\n            if (Array.isArray(x) || typeof x === \"string\" || names.indexOf(Object.prototype.toString.call(x)) > -1) {\n                return true;\n            }\n            return false;\n        };\n    }\n    return function(x) {\n        if (Array.isArray(x) || typeof x === \"string\") {\n            return true;\n        }\n        return false;\n    };\n}\nfunction options_object(f) {\n    return function() {\n        if (typeof arguments[arguments.length - 1] === \"object\") {\n            arguments[arguments.length - 1][_$rapyd$_kwargs_symbol] = true;\n        }\n        return f.apply(this, arguments);\n    };\n}\nfunction _$rapyd$_id(x) {\n    return x._$rapyd$_object_id;\n}\nvar bool = _$rapyd$_bool, bind = _$rapyd$_bind, rebind_all = _$rapyd$_rebind_all;\nvar float = _$rapyd$_float, int = _$rapyd$_int, arraylike = _$rapyd$_arraylike_creator(), _$rapyd$_arraylike = arraylike;\nvar mixin = _$rapyd$_mixin, print = _$rapyd$_print, eslice = _$rapyd$_eslice, id = _$rapyd$_id;;\nvar _$rapyd$_chain_assign_temp;\nfunction _$rapyd$_equals(a, b) {\n    var _$rapyd$_unpack, akeys, bkeys, key;\n    if (a === b) {\n        return true;\n    }\n    if (a && typeof a.__eq__ === \"function\") {\n        return a.__eq__(b);\n    }\n    if (b && typeof b.__eq__ === \"function\") {\n        return b.__eq__(a);\n    }\n    if (_$rapyd$_arraylike(a) && _$rapyd$_arraylike(b)) {\n        if ((a.length !== b.length && (typeof a.length !== \"object\" || _$rapyd$_not_equals(a.length, b.length)))) {\n            return false;\n        }\n        for (var i=0; i < a.length; i++) {\n            if (!((a[i] === b[i] || typeof a[i] === \"object\" && _$rapyd$_equals(a[i], b[i])))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (a && b && a.constructor === b.constructor && a.constructor === Object) {\n        _$rapyd$_unpack = [Object.keys(a), Object.keys(b)];\n        akeys = _$rapyd$_unpack[0];\n        bkeys = _$rapyd$_unpack[1];\n        if (akeys.length !== bkeys.length) {\n            return false;\n        }\n        for (var i=0; i < akeys.length; i++) {\n            key = akeys[i];\n            if (!((a[key] === b[key] || typeof a[key] === \"object\" && _$rapyd$_equals(a[key], b[key])))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nfunction _$rapyd$_not_equals(a, b) {\n    if (a === b) {\n        return false;\n    }\n    if (a && typeof a.__ne__ === \"function\") {\n        return a.__ne__(b);\n    }\n    if (b && typeof b.__ne__ === \"function\") {\n        return b.__ne__(a);\n    }\n    return !_$rapyd$_equals(a, b);\n}\nvar equals = _$rapyd$_equals;;\nfunction _$rapyd$_list_extend(iterable) {\n    var start, iterator, result;\n    if (Array.isArray(iterable) || typeof iterable === \"string\") {\n        start = this.length;\n        this.length += iterable.length;\n        for (var i = 0; i < iterable.length; i++) {\n            this[start + i] = iterable[i];\n        }\n    } else {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n        result = iterator.next();\n        while (!result.done) {\n            this.push(result.value);\n            result = iterator.next();\n        }\n    }\n}\nfunction _$rapyd$_list_index(val, start, stop) {\n    var idx;\n    start = start || 0;\n    if (start < 0) {\n        start = this.length + start;\n    }\n    if (start < 0) {\n        throw new ValueError(val + \" is not in list\");\n    }\n    if (stop === undefined) {\n        idx = this.indexOf(val, start);\n        if (idx === -1) {\n            throw new ValueError(val + \" is not in list\");\n        }\n        return idx;\n    }\n    if (stop < 0) {\n        stop = this.length + stop;\n    }\n    for (var i = start; i < stop; i++) {\n        if ((this[i] === val || typeof this[i] === \"object\" && _$rapyd$_equals(this[i], val))) {\n            return i;\n        }\n    }\n    throw new ValueError(val + \" is not in list\");\n}\nfunction _$rapyd$_list_pop(index) {\n    var ans;\n    if (this.length === 0) {\n        throw new IndexError(\"list is empty\");\n    }\n    ans = this.splice(index, 1);\n    if (!ans.length) {\n        throw new IndexError(\"pop index out of range\");\n    }\n    return ans[0];\n}\nfunction _$rapyd$_list_remove(value) {\n    var idx;\n    idx = this.indexOf(value);\n    if (idx === -1) {\n        throw new ValueError(value + \" not in list\");\n    }\n    this.splice(idx, 1);\n}\nfunction _$rapyd$_list_to_string() {\n    return \"[\" + this.join(\", \") + \"]\";\n}\nfunction _$rapyd$_list_insert(index, val) {\n    if (index < 0) {\n        index += this.length;\n    }\n    index = min(this.length, max(index, 0));\n    if (index === 0) {\n        this.unshift(val);\n        return;\n    }\n    for (var i = this.length; i > index; i--) {\n        this[i] = this[i - 1];\n    }\n    this[index] = val;\n}\nfunction _$rapyd$_list_copy() {\n    return _$rapyd$_list_constructor(this);\n}\nfunction _$rapyd$_list_clear() {\n    this.length = 0;\n}\nfunction _$rapyd$_list_as_array() {\n    return Array.prototype.slice.call(this);\n}\nfunction _$rapyd$_list_count(value) {\n    return this.reduce(function(n, val) {\n        return n + (val === value);\n    }, 0);\n}\nfunction _$rapyd$_list_sort_key(value) {\n    var t;\n    t = typeof value;\n    if (t === \"string\" || t === \"number\") {\n        return value;\n    }\n    return value.toString();\n}\nfunction _$rapyd$_list_sort_cmp(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nfunction _$rapyd$_list_sort() {\n    var key = (arguments[0] === undefined || ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? (null) : arguments[0];\n    var reverse = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? (false) : arguments[1];\n    var _$rapyd$_kwargs_obj = arguments[arguments.length-1];\n    if (_$rapyd$_kwargs_obj === null || typeof _$rapyd$_kwargs_obj !== \"object\" || _$rapyd$_kwargs_obj [_$rapyd$_kwargs_symbol] !== true) _$rapyd$_kwargs_obj = {};\n    if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"key\")){\n        key = _$rapyd$_kwargs_obj.key;\n    }\n    if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"reverse\")){\n        reverse = _$rapyd$_kwargs_obj.reverse;\n    }\n    var mult, keymap, k;\n    key = key || _$rapyd$_list_sort_key;\n    mult = (reverse) ? -1 : 1;\n    keymap = dict();\n    for (var i=0; i < this.length; i++) {\n        k = this[i];\n        keymap.set(k, key(k));\n    }\n    this.sort(function(a, b) {\n        return mult * _$rapyd$_list_sort_cmp(keymap.get(a), keymap.get(b));\n    });\n}\nfunction _$rapyd$_list_concat() {\n    var ans;\n    ans = Array.prototype.concat.apply(this, arguments);\n    _$rapyd$_list_decorate(ans);\n    return ans;\n}\nfunction _$rapyd$_list_slice() {\n    var ans;\n    ans = Array.prototype.slice.apply(this, arguments);\n    _$rapyd$_list_decorate(ans);\n    return ans;\n}\nfunction _$rapyd$_list_iterator(value) {\n    var self;\n    self = this;\n    return {\n        \"_i\": -1,\n        \"_list\": self,\n        \"next\": function() {\n            this._i += 1;\n            if (this._i >= this._list.length) {\n                return {\n                    \"done\": true\n                };\n            }\n            return {\n                \"done\": false,\n                \"value\": this._list[this._i]\n            };\n        }\n    };\n}\nfunction _$rapyd$_list_len() {\n    return this.length;\n}\nfunction _$rapyd$_list_contains(val) {\n    for (var i = 0; i < this.length; i++) {\n        if ((this[i] === val || typeof this[i] === \"object\" && _$rapyd$_equals(this[i], val))) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction _$rapyd$_list_eq(other) {\n    if (!_$rapyd$_arraylike(other)) {\n        return false;\n    }\n    if ((this.length !== other.length && (typeof this.length !== \"object\" || _$rapyd$_not_equals(this.length, other.length)))) {\n        return false;\n    }\n    for (var i = 0; i < this.length; i++) {\n        if (!((this[i] === other[i] || typeof this[i] === \"object\" && _$rapyd$_equals(this[i], other[i])))) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction _$rapyd$_list_decorate(ans) {\n    ans.append = Array.prototype.push;\n    ans.toString = _$rapyd$_list_to_string;\n    ans.inspect = _$rapyd$_list_to_string;\n    ans.extend = _$rapyd$_list_extend;\n    ans.index = _$rapyd$_list_index;\n    ans.pypop = _$rapyd$_list_pop;\n    ans.remove = _$rapyd$_list_remove;\n    ans.insert = _$rapyd$_list_insert;\n    ans.copy = _$rapyd$_list_copy;\n    ans.clear = _$rapyd$_list_clear;\n    ans.count = _$rapyd$_list_count;\n    ans.concat = _$rapyd$_list_concat;\n    ans.pysort = _$rapyd$_list_sort;\n    ans.slice = _$rapyd$_list_slice;\n    ans.as_array = _$rapyd$_list_as_array;\n    ans.__len__ = _$rapyd$_list_len;\n    ans.__contains__ = _$rapyd$_list_contains;\n    ans.__eq__ = _$rapyd$_list_eq;\n    ans.constructor = _$rapyd$_list_constructor;\n    if (typeof ans[_$rapyd$_iterator_symbol] !== \"function\") {\n        ans[_$rapyd$_iterator_symbol] = _$rapyd$_list_iterator;\n    }\n    return ans;\n}\nfunction _$rapyd$_list_constructor(iterable) {\n    var ans, iterator, result;\n    if (iterable === undefined) {\n        ans = [];\n    } else if (_$rapyd$_arraylike(iterable)) {\n        ans = new Array(iterable.length);\n        for (var i = 0; i < iterable.length; i++) {\n            ans[i] = iterable[i];\n        }\n    } else if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n        ans = _$rapyd$_list_decorate([]);\n        result = iterator.next();\n        while (!result.done) {\n            ans.push(result.value);\n            result = iterator.next();\n        }\n    } else if (typeof iterable === \"number\") {\n        ans = new Array(iterable);\n    } else {\n        ans = Object.keys(iterable);\n    }\n    return _$rapyd$_list_decorate(ans);\n}\n_$rapyd$_list_constructor.__name__ = \"list\";\nvar list = _$rapyd$_list_constructor, list_wrap = _$rapyd$_list_decorate;\nfunction sorted() {\n    var iterable = ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true) ? undefined : arguments[0];\n    var key = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? (null) : arguments[1];\n    var reverse = (arguments[2] === undefined || ( 2 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? (false) : arguments[2];\n    var _$rapyd$_kwargs_obj = arguments[arguments.length-1];\n    if (_$rapyd$_kwargs_obj === null || typeof _$rapyd$_kwargs_obj !== \"object\" || _$rapyd$_kwargs_obj [_$rapyd$_kwargs_symbol] !== true) _$rapyd$_kwargs_obj = {};\n    if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"key\")){\n        key = _$rapyd$_kwargs_obj.key;\n    }\n    if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"reverse\")){\n        reverse = _$rapyd$_kwargs_obj.reverse;\n    }\n    var ans;\n    ans = _$rapyd$_list_constructor(iterable);\n    ans.pysort(key, reverse);\n    return ans;\n}\nvar _$rapyd$_global_object_id = 0, _$rapyd$_set_implementation;\nfunction _$rapyd$_set_keyfor(x) {\n    var t, ans;\n    t = typeof x;\n    if (t === \"string\" || t === \"number\" || t === \"boolean\") {\n        return \"_\" + t[0] + x;\n    }\n    if (x === null) {\n        return \"__!@#$0\";\n    }\n    ans = x._$rapyd$_hash_key_prop;\n    if (ans === undefined) {\n        ans = \"_!@#$\" + (++_$rapyd$_global_object_id);\n        Object.defineProperty(x, \"_$rapyd$_hash_key_prop\", {\n            \"value\": ans\n        });\n    }\n    return ans;\n}\nfunction _$rapyd$_set_polyfill() {\n    this._store = {};\n    this.size = 0;\n}\n_$rapyd$_set_polyfill.prototype.add = function(x) {\n    var key;\n    key = _$rapyd$_set_keyfor(x);\n    if (!Object.hasOwnProperty.call(this._store, key)) {\n        this.size += 1;\n        this._store[key] = x;\n    }\n    return this;\n};\n_$rapyd$_set_polyfill.prototype.clear = function(x) {\n    this._store = {};\n    this.size = 0;\n};\n_$rapyd$_set_polyfill.prototype.delete = function(x) {\n    var key;\n    key = _$rapyd$_set_keyfor(x);\n    if (Object.hasOwnProperty.call(this._store, key)) {\n        this.size -= 1;\n        delete this._store[key];\n        return true;\n    }\n    return false;\n};\n_$rapyd$_set_polyfill.prototype.has = function(x) {\n    return Object.hasOwnProperty.call(this._store, _$rapyd$_set_keyfor(x));\n};\n_$rapyd$_set_polyfill.prototype.values = function(x) {\n    var keys, s;\n    keys = Object.keys(this._store);\n    s = this._store;\n    return (function(){\n        var _$rapyd$_d = {};\n        _$rapyd$_d[\"_keys\"] = keys;\n        _$rapyd$_d[\"_i\"] = -1;\n        _$rapyd$_d[\"_s\"] = s;\n        _$rapyd$_d[_$rapyd$_iterator_symbol] = function() {\n            return this;\n        };\n        _$rapyd$_d[\"next\"] = function() {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {\n                    \"done\": true\n                };\n            }\n            return {\n                \"done\": false,\n                \"value\": s[this._keys[this._i]]\n            };\n        };\n        return _$rapyd$_d;\n    })();\n};\nif (typeof Set !== \"function\" || typeof Set.prototype.delete !== \"function\") {\n    _$rapyd$_set_implementation = _$rapyd$_set_polyfill;\n} else {\n    _$rapyd$_set_implementation = Set;\n}\nfunction _$rapyd$_set(iterable) {\n    var ans, s, iterator, result, keys;\n    if (this instanceof _$rapyd$_set) {\n        this.jsset = new _$rapyd$_set_implementation();\n        ans = this;\n        if (iterable === undefined) {\n            return ans;\n        }\n        s = ans.jsset;\n        if (_$rapyd$_arraylike(iterable)) {\n            for (var i = 0; i < iterable.length; i++) {\n                s.add(iterable[i]);\n            }\n        } else if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n            iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n            result = iterator.next();\n            while (!result.done) {\n                s.add(result.value);\n                result = iterator.next();\n            }\n        } else {\n            keys = Object.keys(iterable);\n            for (var i=0; i < keys.length; i++) {\n                s.add(keys[i]);\n            }\n        }\n        return ans;\n    } else {\n        return new _$rapyd$_set(iterable);\n    }\n}\n_$rapyd$_set.prototype.__name__ = \"set\";\nObject.defineProperties(_$rapyd$_set.prototype, {\n    \"length\": {\n        \"get\": function() {\n            return this.jsset.size;\n        }\n    },\n    \"size\": {\n        \"get\": function() {\n            return this.jsset.size;\n        }\n    }\n});\n_$rapyd$_set.prototype.__len__ = function() {\n    return this.jsset.size;\n};\n_$rapyd$_chain_assign_temp = function(x) {\n    return this.jsset.has(x);\n};\n_$rapyd$_set.prototype.has = _$rapyd$_chain_assign_temp;\n_$rapyd$_set.prototype.__contains__ = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_set.prototype.add = function(x) {\n    this.jsset.add(x);\n};\n_$rapyd$_set.prototype.clear = function() {\n    this.jsset.clear();\n};\n_$rapyd$_set.prototype.copy = function() {\n    return _$rapyd$_set(this);\n};\n_$rapyd$_set.prototype.discard = function(x) {\n    this.jsset.delete(x);\n};\n_$rapyd$_set.prototype[_$rapyd$_iterator_symbol] = function() {\n    return this.jsset.values();\n};\n_$rapyd$_set.prototype.difference = function() {\n    var ans, s, iterator, r, x, has;\n    ans = new _$rapyd$_set();\n    s = ans.jsset;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        has = false;\n        for (var i = 0; i < arguments.length; i++) {\n            if (arguments[i].has(x)) {\n                has = true;\n                break;\n            }\n        }\n        if (!has) {\n            s.add(x);\n        }\n        r = iterator.next();\n    }\n    return ans;\n};\n_$rapyd$_set.prototype.difference_update = function() {\n    var s, remove, iterator, r, x;\n    s = this.jsset;\n    remove = [];\n    iterator = s.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        for (var i = 0; i < arguments.length; i++) {\n            if (arguments[i].has(x)) {\n                remove.push(x);\n                break;\n            }\n        }\n        r = iterator.next();\n    }\n    for (var i = 0; i < remove.length; i++) {\n        s.delete(remove[i]);\n    }\n};\n_$rapyd$_set.prototype.intersection = function() {\n    var ans, s, iterator, r, x, has;\n    ans = new _$rapyd$_set();\n    s = ans.jsset;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        has = true;\n        for (var i = 0; i < arguments.length; i++) {\n            if (!arguments[i].has(x)) {\n                has = false;\n                break;\n            }\n        }\n        if (has) {\n            s.add(x);\n        }\n        r = iterator.next();\n    }\n    return ans;\n};\n_$rapyd$_set.prototype.intersection_update = function() {\n    var s, remove, iterator, r, x;\n    s = this.jsset;\n    remove = [];\n    iterator = s.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        for (var i = 0; i < arguments.length; i++) {\n            if (!arguments[i].has(x)) {\n                remove.push(x);\n                break;\n            }\n        }\n        r = iterator.next();\n    }\n    for (var i = 0; i < remove.length; i++) {\n        s.delete(remove[i]);\n    }\n};\n_$rapyd$_set.prototype.isdisjoint = function(other) {\n    var iterator, r, x;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        if (other.has(x)) {\n            return false;\n        }\n        r = iterator.next();\n    }\n    return true;\n};\n_$rapyd$_set.prototype.issubset = function(other) {\n    var iterator, r, x;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        if (!other.has(x)) {\n            return false;\n        }\n        r = iterator.next();\n    }\n    return true;\n};\n_$rapyd$_set.prototype.issuperset = function(other) {\n    var s, iterator, r, x;\n    s = this.jsset;\n    iterator = other.jsset.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        if (!s.has(x)) {\n            return false;\n        }\n        r = iterator.next();\n    }\n    return true;\n};\n_$rapyd$_set.prototype.pop = function() {\n    var iterator, r;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    if (r.done) {\n        throw new KeyError(\"pop from an empty set\");\n    }\n    this.jsset.delete(r.value);\n    return r.value;\n};\n_$rapyd$_set.prototype.remove = function(x) {\n    if (!this.jsset.delete(x)) {\n        throw new KeyError(x.toString());\n    }\n};\n_$rapyd$_set.prototype.symmetric_difference = function(other) {\n    return this.union(other).difference(this.intersection(other));\n};\n_$rapyd$_set.prototype.symmetric_difference_update = function(other) {\n    var common;\n    common = this.intersection(other);\n    this.update(other);\n    this.difference_update(common);\n};\n_$rapyd$_set.prototype.union = function() {\n    var ans;\n    ans = _$rapyd$_set(this);\n    ans.update.apply(ans, arguments);\n    return ans;\n};\n_$rapyd$_set.prototype.update = function() {\n    var s, iterator, r;\n    s = this.jsset;\n    for (var i=0; i < arguments.length; i++) {\n        iterator = arguments[i][_$rapyd$_iterator_symbol]();\n        r = iterator.next();\n        while (!r.done) {\n            s.add(r.value);\n            r = iterator.next();\n        }\n    }\n};\n_$rapyd$_chain_assign_temp = function() {\n    return \"{\" + list(this).join(\", \") + \"}\";\n};\n_$rapyd$_set.prototype.toString = _$rapyd$_chain_assign_temp;\n_$rapyd$_set.prototype.inspect = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_set.prototype.__eq__ = function(other) {\n    var iterator, r;\n    if (!(other instanceof this.constructor)) {\n        return false;\n    }\n    if (other.size !== this.size) {\n        return false;\n    }\n    if (other.size === 0) {\n        return true;\n    }\n    iterator = other[_$rapyd$_iterator_symbol]();\n    r = iterator.next();\n    while (!r.done) {\n        if (!this.has(r.value)) {\n            return false;\n        }\n        r = iterator.next();\n    }\n    return true;\n};\nfunction _$rapyd$_set_wrap(x) {\n    var ans;\n    ans = new _$rapyd$_set();\n    ans.jsset = x;\n    return ans;\n}\nvar set = _$rapyd$_set, set_wrap = _$rapyd$_set_wrap;\nvar _$rapyd$_dict_implementation;\nfunction _$rapyd$_dict_polyfill() {\n    this._store = {};\n    this.size = 0;\n}\n_$rapyd$_dict_polyfill.prototype.set = function(x, value) {\n    var key;\n    key = _$rapyd$_set_keyfor(x);\n    if (!Object.hasOwnProperty.call(this._store, key)) {\n        this.size += 1;\n    }\n    this._store[key] = [x, value];\n    return this;\n};\n_$rapyd$_dict_polyfill.prototype.clear = function(x) {\n    this._store = {};\n    this.size = 0;\n};\n_$rapyd$_dict_polyfill.prototype.delete = function(x) {\n    var key;\n    key = _$rapyd$_set_keyfor(x);\n    if (Object.hasOwnProperty.call(this._store, key)) {\n        this.size -= 1;\n        delete this._store[key];\n        return true;\n    }\n    return false;\n};\n_$rapyd$_dict_polyfill.prototype.has = function(x) {\n    return Object.hasOwnProperty.call(this._store, _$rapyd$_set_keyfor(x));\n};\n_$rapyd$_dict_polyfill.prototype.get = function(x) {\n    try {\n        return this._store[_$rapyd$_set_keyfor(x)][1];\n    } catch (_$rapyd$_Exception) {\n        if (_$rapyd$_Exception instanceof TypeError) {\n            return undefined;\n        } else {\n            throw _$rapyd$_Exception;\n        }\n    }\n};\n_$rapyd$_dict_polyfill.prototype.values = function(x) {\n    var keys, s;\n    keys = Object.keys(this._store);\n    s = this._store;\n    return (function(){\n        var _$rapyd$_d = {};\n        _$rapyd$_d[\"_keys\"] = keys;\n        _$rapyd$_d[\"_i\"] = -1;\n        _$rapyd$_d[\"_s\"] = s;\n        _$rapyd$_d[_$rapyd$_iterator_symbol] = function() {\n            return this;\n        };\n        _$rapyd$_d[\"next\"] = function() {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {\n                    \"done\": true\n                };\n            }\n            return {\n                \"done\": false,\n                \"value\": s[this._keys[this._i]][1]\n            };\n        };\n        return _$rapyd$_d;\n    })();\n};\n_$rapyd$_dict_polyfill.prototype.keys = function(x) {\n    var keys, s;\n    keys = Object.keys(this._store);\n    s = this._store;\n    return (function(){\n        var _$rapyd$_d = {};\n        _$rapyd$_d[\"_keys\"] = keys;\n        _$rapyd$_d[\"_i\"] = -1;\n        _$rapyd$_d[\"_s\"] = s;\n        _$rapyd$_d[_$rapyd$_iterator_symbol] = function() {\n            return this;\n        };\n        _$rapyd$_d[\"next\"] = function() {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {\n                    \"done\": true\n                };\n            }\n            return {\n                \"done\": false,\n                \"value\": s[this._keys[this._i]][0]\n            };\n        };\n        return _$rapyd$_d;\n    })();\n};\n_$rapyd$_dict_polyfill.prototype.entries = function(x) {\n    var keys, s;\n    keys = Object.keys(this._store);\n    s = this._store;\n    return (function(){\n        var _$rapyd$_d = {};\n        _$rapyd$_d[\"_keys\"] = keys;\n        _$rapyd$_d[\"_i\"] = -1;\n        _$rapyd$_d[\"_s\"] = s;\n        _$rapyd$_d[_$rapyd$_iterator_symbol] = function() {\n            return this;\n        };\n        _$rapyd$_d[\"next\"] = function() {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {\n                    \"done\": true\n                };\n            }\n            return {\n                \"done\": false,\n                \"value\": s[this._keys[this._i]]\n            };\n        };\n        return _$rapyd$_d;\n    })();\n};\nif (typeof Map !== \"function\" || typeof Map.prototype.delete !== \"function\") {\n    _$rapyd$_dict_implementation = _$rapyd$_dict_polyfill;\n} else {\n    _$rapyd$_dict_implementation = Map;\n}\nfunction _$rapyd$_dict(iterable) {\n    if (this instanceof _$rapyd$_dict) {\n        this.jsmap = new _$rapyd$_dict_implementation();\n        if (iterable !== undefined) {\n            this.update(iterable);\n        }\n        return this;\n    } else {\n        return new _$rapyd$_dict(iterable);\n    }\n}\n_$rapyd$_dict.prototype.__name__ = \"dict\";\nObject.defineProperties(_$rapyd$_dict.prototype, {\n    \"length\": {\n        \"get\": function() {\n            return this.jsmap.size;\n        }\n    },\n    \"size\": {\n        \"get\": function() {\n            return this.jsmap.size;\n        }\n    }\n});\n_$rapyd$_dict.prototype.__len__ = function() {\n    return this.jsmap.size;\n};\n_$rapyd$_chain_assign_temp = function(x) {\n    return this.jsmap.has(x);\n};\n_$rapyd$_dict.prototype.has = _$rapyd$_chain_assign_temp;\n_$rapyd$_dict.prototype.__contains__ = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_chain_assign_temp = function(key, value) {\n    this.jsmap.set(key, value);\n};\n_$rapyd$_dict.prototype.set = _$rapyd$_chain_assign_temp;\n_$rapyd$_dict.prototype.__setitem__ = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_dict.prototype.clear = function() {\n    this.jsmap.clear();\n};\n_$rapyd$_dict.prototype.copy = function() {\n    return _$rapyd$_dict(this);\n};\n_$rapyd$_dict.prototype.keys = function() {\n    return this.jsmap.keys();\n};\n_$rapyd$_dict.prototype.values = function() {\n    return this.jsmap.values();\n};\n_$rapyd$_chain_assign_temp = function() {\n    return this.jsmap.entries();\n};\n_$rapyd$_dict.prototype.items = _$rapyd$_chain_assign_temp;\n_$rapyd$_dict.prototype.entries = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_dict.prototype[_$rapyd$_iterator_symbol] = function() {\n    return this.jsmap.keys();\n};\n_$rapyd$_dict.prototype.__getitem__ = function(key) {\n    var ans;\n    ans = this.jsmap.get(key);\n    if (ans === undefined && !this.jsmap.has(key)) {\n        throw new KeyError(key + \"\");\n    }\n    return ans;\n};\n_$rapyd$_dict.prototype.get = function(key, defval) {\n    var ans;\n    ans = this.jsmap.get(key);\n    if (ans === undefined && !this.jsmap.has(key)) {\n        return (defval === undefined) ? null : defval;\n    }\n    return ans;\n};\n_$rapyd$_dict.prototype.set_default = function(key, defval) {\n    var j;\n    j = this.jsmap;\n    if (!j.has(key)) {\n        j.set(key, defval);\n        return defval;\n    }\n    return j.get(key);\n};\n_$rapyd$_chain_assign_temp = function() {\n    var iterable = ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true) ? undefined : arguments[0];\n    var value = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? (null) : arguments[1];\n    var _$rapyd$_kwargs_obj = arguments[arguments.length-1];\n    if (_$rapyd$_kwargs_obj === null || typeof _$rapyd$_kwargs_obj !== \"object\" || _$rapyd$_kwargs_obj [_$rapyd$_kwargs_symbol] !== true) _$rapyd$_kwargs_obj = {};\n    if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"value\")){\n        value = _$rapyd$_kwargs_obj.value;\n    }\n    var ans, iterator, r;\n    ans = _$rapyd$_dict();\n    iterator = iter(iterable);\n    r = iterator.next();\n    while (!r.done) {\n        ans.set(r.value, value);\n        r = iterator.next();\n    }\n    return ans;\n};\n_$rapyd$_dict.fromkeys = _$rapyd$_chain_assign_temp;\n_$rapyd$_dict.prototype.fromkeys = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_dict.prototype.pop = function(key, defval) {\n    var ans;\n    ans = this.jsmap.get(key);\n    if (ans === undefined && !this.jsmap.has(key)) {\n        if (defval === undefined) {\n            throw new KeyError(key);\n        }\n        return defval;\n    }\n    this.jsmap.delete(key);\n    return ans;\n};\n_$rapyd$_dict.prototype.popitem = function() {\n    var r;\n    r = this.jsmap.entries().next();\n    if (r.done) {\n        throw new KeyError(\"dict is empty\");\n    }\n    this.jsmap.delete(r.value[0]);\n    return r.value;\n};\n_$rapyd$_dict.prototype.update = function() {\n    var m, iterable, iterator, result, keys;\n    if (arguments.length === 0) {\n        return;\n    }\n    m = this.jsmap;\n    iterable = arguments[0];\n    if (Array.isArray(iterable)) {\n        for (var i = 0; i < iterable.length; i++) {\n            m.set(iterable[i][0], iterable[i][1]);\n        }\n    } else if (iterable instanceof _$rapyd$_dict) {\n        iterator = iterable.items();\n        result = iterator.next();\n        while (!result.done) {\n            m.set(result.value[0], result.value[1]);\n            result = iterator.next();\n        }\n    } else if (typeof Map === \"function\" && iterable instanceof Map) {\n        iterator = iterable.entries();\n        result = iterator.next();\n        while (!result.done) {\n            m.set(result.value[0], result.value[1]);\n            result = iterator.next();\n        }\n    } else if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n        iterator = iterable[_$rapyd$_iterator_symbol]();\n        result = iterator.next();\n        while (!result.done) {\n            m.set(result.value[0], result.value[1]);\n            result = iterator.next();\n        }\n    } else {\n        keys = Object.keys(iterable);\n        for (var i=0; i < keys.length; i++) {\n            if (keys[i] !== _$rapyd$_iterator_symbol) {\n                m.set(keys[i], iterable[keys[i]]);\n            }\n        }\n    }\n    if (arguments.length > 1) {\n        _$rapyd$_dict.prototype.update.call(this, arguments[1]);\n    }\n};\n_$rapyd$_chain_assign_temp = function() {\n    var entries, iterator, r;\n    entries = [];\n    iterator = this.jsmap.entries();\n    r = iterator.next();\n    while (!r.done) {\n        entries.push(r.value[0] + \": \" + r.value[1]);\n        r = iterator.next();\n    }\n    return \"{\" + entries.join(\", \") + \"}\";\n};\n_$rapyd$_dict.prototype.toString = _$rapyd$_chain_assign_temp;\n_$rapyd$_dict.prototype.inspect = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_dict.prototype.__eq__ = function(other) {\n    var iterator, r, x;\n    if (!(other instanceof this.constructor)) {\n        return false;\n    }\n    if (other.size !== this.size) {\n        return false;\n    }\n    if (other.size === 0) {\n        return true;\n    }\n    iterator = other.items();\n    r = iterator.next();\n    while (!r.done) {\n        x = this.jsmap.get(r.value[0]);\n        if (x === undefined && !this.jsmap.has(r.value[0]) || x !== r.value[1]) {\n            return false;\n        }\n        r = iterator.next();\n    }\n    return true;\n};\n_$rapyd$_dict.prototype.as_object = function(other) {\n    var ans, iterator, r;\n    ans = {};\n    iterator = this.jsmap.entries();\n    r = iterator.next();\n    while (!r.done) {\n        ans[r.value[0]] = r.value[1];\n        r = iterator.next();\n    }\n    return ans;\n};\nfunction _$rapyd$_dict_wrap(x) {\n    var ans;\n    ans = new _$rapyd$_dict();\n    ans.jsmap = x;\n    return ans;\n}\nvar dict = _$rapyd$_dict, dict_wrap = _$rapyd$_dict_wrap;;\nvar Exception = Error;\nfunction AttributeError() {\n    if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n    AttributeError.prototype.__init__.apply(this, arguments);\n}\n_$rapyd$_extends(AttributeError, Error);\nAttributeError.prototype.__init__ = function __init__(msg) {\n    var self = this;\n    self.message = msg;\n    self.stack = new Error().stack;\n};\nAttributeError.prototype.__repr__ = function __repr__ () {\n    return \"<\" + __name__ + \".\" + \"AttributeError\" + \" #\" + this._$rapyd$_object_id + \">\";\n};\nAttributeError.prototype.__str__ = function __str__ () {\n    return this.__repr__();\n};\nAttributeError.prototype.name = \"AttributeError\";\n\nfunction IndexError() {\n    if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n    IndexError.prototype.__init__.apply(this, arguments);\n}\n_$rapyd$_extends(IndexError, Error);\nIndexError.prototype.__init__ = function __init__(msg) {\n    var self = this;\n    self.message = msg;\n    self.stack = new Error().stack;\n};\nIndexError.prototype.__repr__ = function __repr__ () {\n    return \"<\" + __name__ + \".\" + \"IndexError\" + \" #\" + this._$rapyd$_object_id + \">\";\n};\nIndexError.prototype.__str__ = function __str__ () {\n    return this.__repr__();\n};\nIndexError.prototype.name = \"IndexError\";\n\nfunction KeyError() {\n    if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n    KeyError.prototype.__init__.apply(this, arguments);\n}\n_$rapyd$_extends(KeyError, Error);\nKeyError.prototype.__init__ = function __init__(msg) {\n    var self = this;\n    self.message = msg;\n    self.stack = new Error().stack;\n};\nKeyError.prototype.__repr__ = function __repr__ () {\n    return \"<\" + __name__ + \".\" + \"KeyError\" + \" #\" + this._$rapyd$_object_id + \">\";\n};\nKeyError.prototype.__str__ = function __str__ () {\n    return this.__repr__();\n};\nKeyError.prototype.name = \"KeyError\";\n\nfunction ValueError() {\n    if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n    ValueError.prototype.__init__.apply(this, arguments);\n}\n_$rapyd$_extends(ValueError, Error);\nValueError.prototype.__init__ = function __init__(msg) {\n    var self = this;\n    self.message = msg;\n    self.stack = new Error().stack;\n};\nValueError.prototype.__repr__ = function __repr__ () {\n    return \"<\" + __name__ + \".\" + \"ValueError\" + \" #\" + this._$rapyd$_object_id + \">\";\n};\nValueError.prototype.__str__ = function __str__ () {\n    return this.__repr__();\n};\nValueError.prototype.name = \"ValueError\";\n;\nfunction sum(iterable, start) {\n    var ans, iterator, r;\n    if (Array.isArray(iterable)) {\n        return iterable.reduce(function(prev, cur) {\n            return prev + cur;\n        }, start || 0);\n    }\n    ans = start || 0;\n    iterator = iter(iterable);\n    r = iterator.next();\n    while (!r.done) {\n        ans += r.value;\n        r = iterator.next();\n    }\n    return ans;\n}\nfunction map() {\n    var func, iterators, args;\n    func = arguments[0];\n    iterators = new Array(arguments.length - 1);\n    args = new Array(arguments.length - 1);\n    for (var i = 1; i < arguments.length; i++) {\n        iterators[i - 1] = iter(arguments[i]);\n    }\n    return (function(){\n        var _$rapyd$_d = {};\n        _$rapyd$_d[\"_func\"] = func;\n        _$rapyd$_d[\"_iterators\"] = iterators;\n        _$rapyd$_d[\"_args\"] = args;\n        _$rapyd$_d[\"next\"] = function() {\n            var r;\n            for (var i = 0; i < this._iterators.length; i++) {\n                r = this._iterators[i].next();\n                if (r.done) {\n                    return {\n                        \"done\": true\n                    };\n                }\n                this._args[i] = r.value;\n            }\n            return {\n                \"done\": false,\n                \"value\": this._func.apply(undefined, this._args)\n            };\n        };\n        _$rapyd$_d[_$rapyd$_iterator_symbol] = function() {\n            return this;\n        };\n        return _$rapyd$_d;\n    })();\n}\nfunction filter(func_or_none, iterable) {\n    return (function(){\n        var _$rapyd$_d = {};\n        _$rapyd$_d[\"_iterator\"] = iter(iterable);\n        _$rapyd$_d[\"_func\"] = (func_or_none === null) ? bool : func_or_none;\n        _$rapyd$_d[\"next\"] = function() {\n            var r;\n            r = this._iterator.next();\n            while (!r.done) {\n                if (this._func(r.value)) {\n                    return r;\n                }\n                r = this._iterator.next();\n            }\n            return {\n                \"done\": true\n            };\n        };\n        _$rapyd$_d[_$rapyd$_iterator_symbol] = function() {\n            return this;\n        };\n        return _$rapyd$_d;\n    })();\n}\nfunction zip() {\n    var iterators;\n    iterators = new Array(arguments.length);\n    for (var i = 0; i < arguments.length; i++) {\n        iterators[i] = iter(arguments[i]);\n    }\n    return (function(){\n        var _$rapyd$_d = {};\n        _$rapyd$_d[\"_iterators\"] = iterators;\n        _$rapyd$_d[\"next\"] = function() {\n            var args, r;\n            args = new Array(this._iterators.length);\n            for (var i = 0; i < this._iterators.length; i++) {\n                r = this._iterators[i].next();\n                if (r.done) {\n                    return {\n                        \"done\": true\n                    };\n                }\n                args[i] = r.value;\n            }\n            return {\n                \"done\": false,\n                \"value\": args\n            };\n        };\n        _$rapyd$_d[_$rapyd$_iterator_symbol] = function() {\n            return this;\n        };\n        return _$rapyd$_d;\n    })();\n};\nfunction _$rapyd$_repr_js_builtin(x, as_array) {\n    var ans, b, keys, key;\n    ans = [];\n    b = \"{}\";\n    if (as_array) {\n        b = \"[]\";\n        for (var i = 0; i < x.length; i++) {\n            ans.push(_$rapyd$_repr(x[i]));\n        }\n    } else {\n        keys = Object.keys(x);\n        for (var k = 0; k < keys.length; k++) {\n            key = keys[k];\n            ans.push(JSON.stringify(key) + \":\" + _$rapyd$_repr(x[key]));\n        }\n    }\n    return b[0] + ans.join(\", \") + b[1];\n}\nfunction _$rapyd$_repr(x) {\n    var ans;\n    if (x === null) {\n        return \"None\";\n    }\n    if (x === undefined) {\n        return \"undefined\";\n    }\n    ans = x;\n    if (typeof x.__repr__ === \"function\") {\n        ans = x.__repr__();\n    } else if (x === true || x === false) {\n        ans = (x) ? \"True\" : \"False\";\n    } else if (Array.isArray(x)) {\n        ans = _$rapyd$_repr_js_builtin(x, true);\n    } else if (typeof x === \"function\") {\n        ans = x.toString();\n    } else {\n        ans = (typeof x.toString === \"function\") ? x.toString() : x;\n        if (ans === \"[object Object]\") {\n            return _$rapyd$_repr_js_builtin(x);\n        }\n        try {\n            ans = JSON.stringify(x);\n        } catch (_$rapyd$_Exception) {\n        }\n    }\n    return ans + \"\";\n}\nfunction _$rapyd$_str(x) {\n    var ans;\n    if (x === null) {\n        return \"None\";\n    }\n    if (x === undefined) {\n        return \"undefined\";\n    }\n    ans = x;\n    if (typeof x.__str__ === \"function\") {\n        ans = x.__str__();\n    } else if (typeof x.__repr__ === \"function\") {\n        ans = x.__repr__();\n    } else if (x === true || x === false) {\n        ans = (x) ? \"True\" : \"False\";\n    } else if (Array.isArray(x)) {\n        ans = _$rapyd$_repr_js_builtin(x, true);\n    } else if (typeof x.toString === \"function\") {\n        ans = x.toString();\n        if (ans === \"[object Object]\") {\n            ans = _$rapyd$_repr_js_builtin(x);\n        }\n    }\n    return ans + \"\";\n}\n_$rapyd$_str.format = function() {\n    var template, args, kwargs, explicit, implicit, _$rapyd$_chain_assign_temp, idx, ans, pos, in_brace, markup, ch;\n    template = arguments[0];\n    if (template === undefined) {\n        throw new TypeError(\"Template is required\");\n    }\n    args = Array.prototype.slice.call(arguments, 1);\n    kwargs = {};\n    if (args.length && args[args.length-1][_$rapyd$_kwargs_symbol] !== undefined) {\n        kwargs = args[args.length-1];\n        args = args.slice(0, -1);\n    }\n    _$rapyd$_chain_assign_temp = false;\n    explicit = _$rapyd$_chain_assign_temp;\n    implicit = _$rapyd$_chain_assign_temp;\n;\n    idx = 0;\n    if (_$rapyd$_str.format._template_resolve_pat === undefined) {\n        _$rapyd$_str.format._template_resolve_pat = /[.\\[]/;\n    }\n    function resolve(arg, object) {\n        var _$rapyd$_unpack, first, key, rest, ans;\n        if (!arg) {\n            return object;\n        }\n        _$rapyd$_unpack = [arg[0], arg.slice(1)];\n        first = _$rapyd$_unpack[0];\n        arg = _$rapyd$_unpack[1];\n        key = arg.split(_$rapyd$_str.format._template_resolve_pat, 1)[0];\n        rest = arg.slice(key.length);\n        ans = (first === \"[\") ? object[key.slice(0, -1)] : getattr(object, key);\n        if (ans === undefined) {\n            throw new KeyError((first === \"[\") ? key.slice(0, -1) : key);\n        }\n        return resolve(rest, ans);\n    }\n    function resolve_format_spec(format_spec) {\n        if (_$rapyd$_str.format._template_resolve_fs_pat === undefined) {\n            _$rapyd$_str.format._template_resolve_fs_pat = /[{]([a-zA-Z0-9_]+)[}]/g;\n        }\n        return format_spec.replace(_$rapyd$_str.format._template_resolve_fs_pat, function(match, key) {\n            if (!Object.prototype.hasOwnProperty.call(kwargs, key)) {\n                return \"\";\n            }\n            return \"\" + kwargs[key];\n        });\n    }\n    function apply_formatting(value, format_spec) {\n        var _$rapyd$_unpack, fill, align, sign, fhash, zeropad, width, comma, precision, ftype, is_numeric, is_int, lftype, code, exp, nval, is_positive, left, right;\n        if (format_spec.indexOf(\"{\") !== -1) {\n            format_spec = resolve_format_spec(format_spec);\n        }\n        if (_$rapyd$_str.format._template_format_pat === undefined) {\n            _$rapyd$_str.format._template_format_pat = /([^{}](?=[<>=^]))?([<>=^])?([-+\\x20])?(\\#)?(0)?(\\d+)?(,)?(?:\\.(\\d+))?([bcdeEfFgGnosxX%])?/;\n        }\n        try {\n            _$rapyd$_unpack = format_spec.match(_$rapyd$_str.format._template_format_pat).slice(1);\n            fill = _$rapyd$_unpack[0];\n            align = _$rapyd$_unpack[1];\n            sign = _$rapyd$_unpack[2];\n            fhash = _$rapyd$_unpack[3];\n            zeropad = _$rapyd$_unpack[4];\n            width = _$rapyd$_unpack[5];\n            comma = _$rapyd$_unpack[6];\n            precision = _$rapyd$_unpack[7];\n            ftype = _$rapyd$_unpack[8];\n        } catch (_$rapyd$_Exception) {\n            if (_$rapyd$_Exception instanceof TypeError) {\n                return value;\n            } else {\n                throw _$rapyd$_Exception;\n            }\n        }\n        if (zeropad) {\n            fill = fill || \"0\";\n            align = align || \"=\";\n        } else {\n            fill = fill || \" \";\n            align = align || \">\";\n        }\n        is_numeric = Number(value) === value;\n        is_int = is_numeric && value % 1 === 0;\n        precision = parseInt(precision, 10);\n        lftype = (ftype || \"\").toLowerCase();\n        if (ftype === \"n\") {\n            is_numeric = true;\n            if (is_int) {\n                if (comma) {\n                    throw new ValueError(\"Cannot specify ',' with 'n'\");\n                }\n                value = parseInt(value, 10).toLocaleString();\n            } else {\n                value = parseFloat(value).toLocaleString();\n            }\n        } else if (['b', 'c', 'd', 'o', 'x'].indexOf(lftype) !== -1) {\n            value = parseInt(value, 10);\n            is_numeric = true;\n            if (!isNaN(value)) {\n                if (ftype === \"b\") {\n                    value = (value >>> 0).toString(2);\n                    if (fhash) {\n                        value = \"0b\" + value;\n                    }\n                } else if (ftype === \"c\") {\n                    if (value > 65535) {\n                        code = value - 65536;\n                        value = String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n                    } else {\n                        value = String.fromCharCode(value);\n                    }\n                } else if (ftype === \"d\") {\n                    if (comma) {\n                        value = value.toLocaleString(\"en-US\");\n                    } else {\n                        value = value.toString(10);\n                    }\n                } else if (ftype === \"o\") {\n                    value = value.toString(8);\n                    if (fhash) {\n                        value = \"0o\" + value;\n                    }\n                } else if (lftype === \"x\") {\n                    value = value.toString(16);\n                    value = (ftype === \"x\") ? value.toLowerCase() : value.toUpperCase();\n                    if (fhash) {\n                        value = \"0x\" + value;\n                    }\n                }\n            }\n        } else if (['e','f','g','%'].indexOf(lftype) !== -1) {\n            is_numeric = true;\n            value = parseFloat(value);\n            if (lftype === \"e\") {\n                value = value.toExponential((isNaN(precision)) ? 6 : precision);\n                value = (ftype === \"E\") ? value.toUpperCase() : value.toLowerCase();\n            } else if (lftype === \"f\") {\n                value = value.toFixed((isNaN(precision)) ? 6 : precision);\n                value = (ftype === \"F\") ? value.toUpperCase() : value.toLowerCase();\n            } else if (ftype === \"%\") {\n                value *= 100;\n                value = value.toFixed((isNaN(precision)) ? 6 : precision) + \"%\";\n            } else if (lftype === \"g\") {\n                if (isNaN(precision)) {\n                    precision = 6;\n                }\n                precision = max(1, precision);\n                exp = parseInt(value.toExponential(precision - 1).toLowerCase().split(\"e\")[1], 10);\n                if (-4 <= exp && exp < precision) {\n                    value = value.toFixed(precision - 1 - exp);\n                } else {\n                    value = value.toExponential(precision - 1);\n                }\n                value = value.replace(/0+$/g, \"\");\n                if (value[value.length-1] === \".\") {\n                    value = value.slice(0, -1);\n                }\n                if (ftype === \"G\") {\n                    value = value.toUpperCase();\n                }\n            }\n        } else {\n            value += \"\";\n            if (!isNaN(precision)) {\n                value = value.slice(0, precision);\n            }\n        }\n        value += \"\";\n        if (is_numeric && sign) {\n            nval = Number(value);\n            is_positive = !isNaN(nval) && nval >= 0;\n            if (is_positive && (sign === \" \" || sign === \"+\")) {\n                value = sign + value;\n            }\n        }\n        function repeat(char, num) {\n            return (new Array(num+1)).join(char);\n        }\n        if (is_numeric && width && width[0] === \"0\") {\n            width = width.slice(1);\n            _$rapyd$_unpack = [\"0\", \"=\"];\n            fill = _$rapyd$_unpack[0];\n            align = _$rapyd$_unpack[1];\n        }\n        width = parseInt(width || \"-1\", 10);\n        if (isNaN(width)) {\n            throw new ValueError(\"Invalid width specification: \" + width);\n        }\n        if (fill && value.length < width) {\n            if (align === \"<\") {\n                value = value + repeat(fill, width - value.length);\n            } else if (align === \">\") {\n                value = repeat(fill, width - value.length) + value;\n            } else if (align === \"^\") {\n                left = Math.floor((width - value.length) / 2);\n                right = width - left - value.length;\n                value = repeat(fill, left) + value + repeat(fill, right);\n            } else if (align === \"=\") {\n                if (_$rapyd$_in(value[0], \"+- \")) {\n                    value = value[0] + repeat(fill, width - value.length) + value.slice(1);\n                } else {\n                    value = repeat(fill, width - value.length) + value;\n                }\n            } else {\n                throw new ValueError(\"Unrecognized alignment: \" + align);\n            }\n        }\n        return value;\n    }\n    function parse_markup(markup) {\n        var key, transformer, format_spec, _$rapyd$_chain_assign_temp, pos, state, ch;\n        _$rapyd$_chain_assign_temp = \"\";\n        key = _$rapyd$_chain_assign_temp;\n        transformer = _$rapyd$_chain_assign_temp;\n        format_spec = _$rapyd$_chain_assign_temp;\n;\n        pos = 0;\n        state = 0;\n        while (pos < markup.length) {\n            ch = markup[pos];\n            if (state === 0) {\n                if (ch === \"!\") {\n                    state = 1;\n                } else if (ch === \":\") {\n                    state = 2;\n                } else {\n                    key += ch;\n                }\n            } else if (state === 1) {\n                if (ch === \":\") {\n                    state = 2;\n                } else {\n                    transformer += ch;\n                }\n            } else {\n                format_spec += ch;\n            }\n            pos += 1;\n        }\n        return [key, transformer, format_spec];\n    }\n    function render_markup(markup) {\n        var _$rapyd$_unpack, key, transformer, format_spec, lkey, nvalue, object, ans;\n        _$rapyd$_unpack = parse_markup(markup);\n        key = _$rapyd$_unpack[0];\n        transformer = _$rapyd$_unpack[1];\n        format_spec = _$rapyd$_unpack[2];\n        if (transformer && ['a', 'r', 's'].indexOf(transformer) === -1) {\n            throw new ValueError(\"Unknown conversion specifier: \" + transformer);\n        }\n        lkey = key.length && key.split(/[.\\[]/, 1)[0];\n        if (lkey) {\n            explicit = true;\n            if (implicit) {\n                throw new ValueError(\"cannot switch from automatic field numbering to manual field specification\");\n            }\n            nvalue = parseInt(lkey);\n            object = (isNaN(nvalue)) ? kwargs[lkey] : args[nvalue];\n            if (object === undefined) {\n                if (isNaN(nvalue)) {\n                    throw new KeyError(lkey);\n                }\n                throw new IndexError(lkey);\n            }\n            object = resolve(key.slice(lkey.length), object);\n        } else {\n            implicit = true;\n            if (explicit) {\n                throw new ValueError(\"cannot switch from manual field specification to automatic field numbering\");\n            }\n            if (idx >= args.length) {\n                throw new IndexError(\"Not enough arguments to match template: \" + template);\n            }\n            object = args[idx];\n            idx += 1;\n        }\n        if (typeof object === \"function\") {\n            object = object();\n        }\n        ans = \"\" + object;\n        if (format_spec) {\n            ans = apply_formatting(ans, format_spec);\n        }\n        return ans;\n    }\n    ans = \"\";\n    pos = 0;\n    in_brace = 0;\n    markup = \"\";\n    while (pos < template.length) {\n        ch = template[pos];\n        if (in_brace) {\n            if (ch === \"{\") {\n                in_brace += 1;\n                markup += \"{\";\n            } else if (ch === \"}\") {\n                in_brace -= 1;\n                if (in_brace > 0) {\n                    markup += \"}\";\n                } else {\n                    ans += render_markup(markup);\n                }\n            } else {\n                markup += ch;\n            }\n        } else {\n            if (ch === \"{\") {\n                if (template[pos + 1] === \"{\") {\n                    pos += 1;\n                    ans += \"{\";\n                } else {\n                    in_brace = 1;\n                    markup = \"\";\n                }\n            } else {\n                ans += ch;\n            }\n        }\n        pos += 1;\n    }\n    if (in_brace) {\n        throw new ValueError(\"expected '}' before end of string\");\n    }\n    return ans;\n};\n_$rapyd$_str.capitalize = function(string) {\n    if (string) {\n        string = string[0].toUpperCase() + string.slice(1).toLowerCase();\n    }\n    return string;\n};\n_$rapyd$_str.center = function(string, width, fill) {\n    var left, right;\n    left = Math.floor((width - string.length) / 2);\n    right = width - left - string.length;\n    fill = fill || \" \";\n    return new Array(left+1).join(fill) + string + new Array(right+1).join(fill);\n};\n_$rapyd$_str.count = function(string, needle, start, end) {\n    var _$rapyd$_unpack, pos, step, ans;\n    start = start || 0;\n    end = end || string.length;\n    if (start < 0 || end < 0) {\n        string = string.slice(start, end);\n        _$rapyd$_unpack = [0, string.length];\n        start = _$rapyd$_unpack[0];\n        end = _$rapyd$_unpack[1];\n    }\n    pos = start;\n    step = needle.length;\n    ans = 0;\n    while (pos !== -1) {\n        pos = string.indexOf(needle, pos);\n        if (pos !== -1) {\n            ans += 1;\n            pos += step;\n        }\n    }\n    return ans;\n};\n_$rapyd$_str.endswith = function(string, suffixes, start, end) {\n    var q;\n    start = start || 0;\n    if (typeof suffixes === \"string\") {\n        suffixes = [suffixes];\n    }\n    if (end !== undefined) {\n        string = string.slice(0, end);\n    }\n    for (var i = 0; i < suffixes.length; i++) {\n        q = suffixes[i];\n        if (string.indexOf(q, Math.max(start, string.length - q.length)) !== -1) {\n            return true;\n        }\n    }\n    return false;\n};\n_$rapyd$_str.startswith = function(string, prefixes, start, end) {\n    var prefix;\n    start = start || 0;\n    if (typeof prefixes === \"string\") {\n        prefixes = [prefixes];\n    }\n    for (var i = 0; i < prefixes.length; i++) {\n        prefix = prefixes[i];\n        end = (end === undefined) ? string.length : end;\n        if (end - start >= prefix.length && prefix === string.slice(start, start + prefix.length)) {\n            return true;\n        }\n    }\n    return false;\n};\n_$rapyd$_str.find = function(string, needle, start, end) {\n    var ans;\n    while (start < 0) {\n        start += string.length;\n    }\n    ans = string.indexOf(needle, start);\n    if (end !== undefined && ans !== -1) {\n        while (end < 0) {\n            end += string.length;\n        }\n        if (ans >= end - needle.length) {\n            return -1;\n        }\n    }\n    return ans;\n};\n_$rapyd$_str.rfind = function(string, needle, start, end) {\n    var ans;\n    while (end < 0) {\n        end += string.length;\n    }\n    ans = string.lastIndexOf(needle, end - 1);\n    if (start !== undefined && ans !== -1) {\n        while (start < 0) {\n            start += string.length;\n        }\n        if (ans < start) {\n            return -1;\n        }\n    }\n    return ans;\n};\n_$rapyd$_str.index = function(string, needle, start, end) {\n    var ans;\n    ans = _$rapyd$_str.find.apply(null, arguments);\n    if (ans === -1) {\n        throw new ValueError(\"substring not found\");\n    }\n    return ans;\n};\n_$rapyd$_str.rindex = function(string, needle, start, end) {\n    var ans;\n    ans = _$rapyd$_str.rfind.apply(null, arguments);\n    if (ans === -1) {\n        throw new ValueError(\"substring not found\");\n    }\n    return ans;\n};\n_$rapyd$_str.islower = function(string) {\n    return string.length > 0 && string.toUpperCase() !== string;\n};\n_$rapyd$_str.isupper = function(string) {\n    return string.length > 0 && string.toLowerCase() !== string;\n};\n_$rapyd$_str.isspace = function(string) {\n    return string.length > 0 && /^\\s+$/.test(string);\n};\n_$rapyd$_str.join = function(string, iterable) {\n    var ans, r;\n    if (Array.isArray(iterable)) {\n        return iterable.join(string);\n    }\n    ans = \"\";\n    r = iterable.next();\n    while (!r.done) {\n        if (ans) {\n            ans += string;\n        }\n        ans += r.value;\n        r = iterable.next();\n    }\n    return ans;\n};\n_$rapyd$_str.ljust = function(string, width, fill) {\n    if (width > string.length) {\n        fill = fill || \" \";\n        string += new Array(width - string.length + 1).join(fill);\n    }\n    return string;\n};\n_$rapyd$_str.rjust = function(string, width, fill) {\n    if (width > string.length) {\n        fill = fill || \" \";\n        string = new Array(width - string.length + 1).join(fill) + string;\n    }\n    return string;\n};\n_$rapyd$_str.lower = function(string) {\n    return string.toLowerCase();\n};\n_$rapyd$_str.upper = function(string) {\n    return string.toUpperCase();\n};\n_$rapyd$_str.lstrip = function(string, chars) {\n    var pos;\n    pos = 0;\n    chars = chars || _$rapyd$_str.whitespace;\n    while (chars.indexOf(string[pos]) !== -1) {\n        pos += 1;\n    }\n    if (pos) {\n        string = string.slice(pos);\n    }\n    return string;\n};\n_$rapyd$_str.rstrip = function(string, chars) {\n    var pos;\n    pos = string.length - 1;\n    chars = chars || _$rapyd$_str.whitespace;\n    while (chars.indexOf(string[pos]) !== -1) {\n        pos -= 1;\n    }\n    if (pos < string.length - 1) {\n        string = string.slice(0, pos + 1);\n    }\n    return string;\n};\n_$rapyd$_str.strip = function(string, chars) {\n    return _$rapyd$_str.lstrip(_$rapyd$_str.rstrip(string, chars), chars);\n};\n_$rapyd$_str.partition = function(string, sep) {\n    var idx;\n    idx = string.indexOf(sep);\n    if (idx === -1) {\n        return [string, \"\", \"\"];\n    }\n    return [string.slice(0, idx), sep, string.slice(idx + sep.length)];\n};\n_$rapyd$_str.rpartition = function(string, sep) {\n    var idx;\n    idx = string.lastIndexOf(sep);\n    if (idx === -1) {\n        return [\"\", \"\", string];\n    }\n    return [string.slice(0, idx), sep, string.slice(idx + sep.length)];\n};\n_$rapyd$_str.replace = function(string, old, repl, count) {\n    var pos, idx;\n    if (count === 1) {\n        return string.replace(old, repl);\n    }\n    if (count < 1) {\n        return string;\n    }\n    count = count || Number.MAX_VALUE;\n    pos = 0;\n    while (count > 0) {\n        count -= 1;\n        idx = string.indexOf(old, pos);\n        if (idx === -1) {\n            break;\n        }\n        pos = idx + repl.length;\n        string = string.slice(0, idx) + repl + string.slice(idx + old.length);\n    }\n    return string;\n};\n_$rapyd$_str.split = function(string, sep, maxsplit) {\n    var ans, extra, parts;\n    if (maxsplit === 0) {\n        return _$rapyd$_list_decorate([ string ]);\n    }\n    if (sep === undefined || sep === null) {\n        if (maxsplit > 0) {\n            ans = string.split(/(\\s+)/);\n            extra = \"\";\n            parts = [];\n            for (var i = 0; i < ans.length; i++) {\n                if (parts.length >= maxsplit + 1) {\n                    extra += ans[i];\n                } else if (i % 2 === 0) {\n                    parts.push(ans[i]);\n                }\n            }\n            parts[parts.length-1] += extra;\n            ans = parts;\n        } else {\n            ans = string.split(/\\s+/);\n        }\n    } else {\n        if (sep === \"\") {\n            throw new ValueError(\"empty separator\");\n        }\n        ans = string.split(sep);\n        if (maxsplit > 0 && ans.length > maxsplit) {\n            extra = ans.slice(maxsplit).join(sep);\n            ans = ans.slice(0, maxsplit);\n            ans.push(extra);\n        }\n    }\n    return _$rapyd$_list_decorate(ans);\n};\n_$rapyd$_str.rsplit = function(string, sep, maxsplit) {\n    var ans, is_space, pos, current, spc, ch, end, _$rapyd$_chain_assign_temp, idx;\n    if (!maxsplit) {\n        return _$rapyd$_str.split.call(null, string, sep, maxsplit);\n    }\n    if (sep === undefined || sep === null) {\n        if (maxsplit > 0) {\n            ans = [];\n            is_space = /\\s/;\n            pos = string.length - 1;\n            current = \"\";\n            while (pos > -1 && maxsplit > 0) {\n                spc = false;\n                ch = string[pos];\n                while (pos > -1 && is_space.test(ch)) {\n                    spc = true;\n                    ch = string[--pos];\n                }\n                if (spc) {\n                    if (current) {\n                        ans.push(current);\n                        maxsplit -= 1;\n                    }\n                    current = ch;\n                } else {\n                    current += ch;\n                }\n                pos -= 1;\n            }\n            ans.push(string.slice(0, pos + 1) + current);\n            ans.reverse();\n        } else {\n            ans = string.split(/\\s+/);\n        }\n    } else {\n        if (sep === \"\") {\n            throw new ValueError(\"empty separator\");\n        }\n        ans = [];\n        _$rapyd$_chain_assign_temp = string.length;\n        pos = _$rapyd$_chain_assign_temp;\n        end = _$rapyd$_chain_assign_temp;\n;\n        while (pos > -1 && maxsplit > 0) {\n            maxsplit -= 1;\n            idx = string.lastIndexOf(sep, pos);\n            if (idx === -1) {\n                break;\n            }\n            ans.push(string.slice(idx + sep.length, end));\n            pos = idx - 1;\n            end = idx;\n        }\n        ans.push(string.slice(0, end));\n        ans.reverse();\n    }\n    return _$rapyd$_list_decorate(ans);\n};\n_$rapyd$_str.splitlines = function(string, keepends) {\n    var parts, ans;\n    if (keepends) {\n        parts = string.split(/((?:\\r?\\n)|\\r)/);\n        ans = [];\n        for (var i = 0; i < parts.length; i++) {\n            if (i % 2 === 0) {\n                ans.push(parts[i]);\n            } else {\n                ans[ans.length-1] += parts[i];\n            }\n        }\n    } else {\n        ans = string.split(/(?:\\r?\\n)|\\r/);\n    }\n    return _$rapyd$_list_decorate(ans);\n};\n_$rapyd$_str.swapcase = function(string) {\n    var ans, a, b;\n    ans = new Array(string.length);\n    for (var i = 0; i < ans.length; i++) {\n        a = string[i];\n        b = a.toLowerCase();\n        if (a === b) {\n            b = a.toUpperCase();\n        }\n        ans[i] = b;\n    }\n    return ans.join(\"\");\n};\n_$rapyd$_str.zfill = function(string, width) {\n    if (width > string.length) {\n        string = new Array(width - string.length + 1).join(\"0\") + string;\n    }\n    return string;\n};\n_$rapyd$_str.uchrs = function(string, with_positions) {\n    return (function(){\n        var _$rapyd$_d = {};\n        _$rapyd$_d[\"_string\"] = string;\n        _$rapyd$_d[\"_pos\"] = 0;\n        _$rapyd$_d[_$rapyd$_iterator_symbol] = function() {\n            return this;\n        };\n        _$rapyd$_d[\"next\"] = function() {\n            var length, pos, value, ans, extra;\n            length = this._string.length;\n            if (this._pos >= length) {\n                return {\n                    \"done\": true\n                };\n            }\n            pos = this._pos;\n            value = this._string.charCodeAt(this._pos++);\n            ans = \"\\ufffd\";\n            if (55296 <= value && value <= 56319) {\n                if (this._pos < length) {\n                    extra = this._string.charCodeAt(this._pos++);\n                    if ((extra & 56320) === 56320) {\n                        ans = String.fromCharCode(value, extra);\n                    }\n                }\n            } else if ((value & 56320) !== 56320) {\n                ans = String.fromCharCode(value);\n            }\n            if (with_positions) {\n                return {\n                    \"done\": false,\n                    \"value\": _$rapyd$_list_decorate([ pos, ans ])\n                };\n            } else {\n                return {\n                    \"done\": false,\n                    \"value\": ans\n                };\n            }\n        };\n        return _$rapyd$_d;\n    })();\n};\n_$rapyd$_str.uslice = function(string, start, end) {\n    var items, iterator, r;\n    items = [];\n    iterator = _$rapyd$_str.uchrs(string);\n    r = iterator.next();\n    while (!r.done) {\n        items.push(r.value);\n        r = iterator.next();\n    }\n    return items.slice(start || 0, (end === undefined) ? items.length : end).join(\"\");\n};\n_$rapyd$_str.ulen = function(string) {\n    var iterator, r, ans;\n    iterator = _$rapyd$_str.uchrs(string);\n    r = iterator.next();\n    ans = 0;\n    while (!r.done) {\n        r = iterator.next();\n        ans += 1;\n    }\n    return ans;\n};\n_$rapyd$_str.ascii_lowercase = \"abcdefghijklmnopqrstuvwxyz\";\n_$rapyd$_str.ascii_uppercase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n_$rapyd$_str.ascii_letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n_$rapyd$_str.digits = \"0123456789\";\n_$rapyd$_str.punctuation = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\n_$rapyd$_str.printable = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~ \\t\\n\\r\\u000b\\f\";\n_$rapyd$_str.whitespace = \" \\t\\n\\r\\u000b\\f\";\nvar str = _$rapyd$_str, repr = _$rapyd$_repr;;\nvar _$rapyd$_regenerator = {};\n!(function(global) {\n  \"use strict\";\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n  var undefined; \n\n  var iteratorSymbol =\n    typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n\n      module.exports = runtime;\n    }\n\n    return;\n  }\n\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n\n    var generator = Object.create((outerFn || Generator).prototype);\n\n    generator._invoke = makeInvokeMethod(\n      innerFn, self || null,\n      new Context(tryLocsList || [])\n    );\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  var ContinueSentinel = {};\n\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    genFun.__proto__ = GeneratorFunctionPrototype;\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  runtime.awrap = function(arg) {\n    return new AwaitArgument(arg);\n  };\n\n  function AwaitArgument(arg) {\n    this.arg = arg;\n  }\n\n  function AsyncIterator(generator) {\n\n    function invoke(method, arg) {\n      var result = generator[method](arg);\n      var value = result.value;\n      return value instanceof AwaitArgument\n        ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)\n        : Promise.resolve(value).then(function(unwrapped) {\n\n            result.value = unwrapped;\n            return result;\n          });\n    }\n\n    if (typeof process === \"object\" && process.domain) {\n      invoke = process.domain.bind(invoke);\n    }\n\n    var invokeNext = invoke.bind(generator, \"next\");\n    var invokeThrow = invoke.bind(generator, \"throw\");\n    var invokeReturn = invoke.bind(generator, \"return\");\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      var enqueueResult =\n\n        previousPromise ? previousPromise.then(function() {\n          return invoke(method, arg);\n        }) : new Promise(function(resolve) {\n          resolve(invoke(method, arg));\n        });\n\n      previousPromise = enqueueResult[\"catch\"](function(ignored){});\n\n      return enqueueResult;\n    }\n\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter \n\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        return doneResult();\n      }\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          if (method === \"return\" ||\n              (method === \"throw\" && delegate.iterator[method] === undefined)) {\n\n            context.delegate = null;\n\n            var returnMethod = delegate.iterator[\"return\"];\n            if (returnMethod) {\n              var record = tryCatch(returnMethod, delegate.iterator, arg);\n              if (record.type === \"throw\") {\n\n                method = \"throw\";\n                arg = record.arg;\n                continue;\n              }\n            }\n\n            if (method === \"return\") {\n\n              continue;\n            }\n          }\n\n          var record = tryCatch(\n            delegate.iterator[method],\n            delegate.iterator,\n            arg\n          );\n\n          if (record.type === \"throw\") {\n            context.delegate = null;\n\n            method = \"throw\";\n            arg = record.arg;\n            continue;\n          }\n\n          method = \"next\";\n          arg = undefined;\n\n          var info = record.arg;\n          if (info.done) {\n            context[delegate.resultName] = info.value;\n            context.next = delegate.nextLoc;\n          } else {\n            state = GenStateSuspendedYield;\n            return info;\n          }\n\n          context.delegate = null;\n        }\n\n        if (method === \"next\") {\n          if (state === GenStateSuspendedYield) {\n            context.sent = arg;\n          } else {\n            context.sent = undefined;\n          }\n\n        } else if (method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw arg;\n          }\n\n          if (context.dispatchException(arg)) {\n\n            method = \"next\";\n            arg = undefined;\n          }\n\n        } else if (method === \"return\") {\n          context.abrupt(\"return\", arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          var info = {\n            value: record.arg,\n            done: context.done\n          };\n\n          if (record.arg === ContinueSentinel) {\n            if (context.delegate && method === \"next\") {\n\n              arg = undefined;\n            }\n          } else {\n            return info;\n          }\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n\n          method = \"throw\";\n          arg = record.arg;\n        }\n      }\n    };\n  }\n\n  defineIteratorMethods(Gp);\n\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      this.sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.next = finallyEntry.finallyLoc;\n      } else {\n        this.complete(record);\n      }\n\n      return ContinueSentinel;\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = record.arg;\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      return ContinueSentinel;\n    }\n  };\n})(_$rapyd$_regenerator);\n","tools/web_repl.js":"/* vim:fileencoding=utf-8\n * \n * Copyright (C) 2016 Kovid Goyal <kovid at kovidgoyal.net>\n *\n * Distributed under terms of the BSD license\n */\n\"use strict\";  /*jshint node:true */\nvar vm = require('vm');\nvar embedded_compiler = require('tools/embedded_compiler.js');\n\nmodule.exports = function(compiler, baselib) {\n    var ctx = vm.createContext();\n    var LINE_CONTINUATION_CHARS = ':\\\\';\n    var find_completions = null;\n    var streaming_compiler = embedded_compiler(compiler, baselib, function(js) { return vm.runInContext(js, ctx); }, '__repl__');\n\n    return {\n        'in_block_mode': false,\n\n        'replace_print': function replace_print(write_line_func) {\n            ctx.print = function() {\n                var parts = [];\n                for (var i = 0; i < arguments.length; i++) \n                    parts.push(ctx._$rapyd$_str(arguments[i]));\n                write_line_func(parts.join(' '));\n            };\n        },\n\n        'is_input_complete': function is_input_complete(source) {\n            if (!source || !source.trim()) return false;\n            var lines = source.split('\\n');\n            var last_line = lines[lines.length - 1].trimRight();\n            if (this.in_block_mode) {\n                // In a block only exit after two blank lines\n                if (lines.length < 2) return false;\n                var second_last_line = lines[lines.length - 2].trimRight();\n                var block_ended = !!(!last_line && !second_last_line);\n                if (!block_ended) return false;\n                this.in_block_mode = false;\n                return true;\n            }\n\n            if (last_line && LINE_CONTINUATION_CHARS.indexOf(last_line.substr(last_line.length - 1)) > -1) {\n                this.in_block_mode = true;\n                return false;\n            }\n            try {\n                compiler.parse(source, {'filename': '<repl>', 'basedir': '__stdlib__'});\n            } catch(e) {\n                if (e.is_eof && e.line === lines.length && e.col > 0) {\n                    return false;\n                }\n                this.in_block_mode = false;\n                return true;\n            }\n            this.in_block_mode = false;\n            return true;\n        },\n\n        'compile': function web_repl_compile(code, filename) {\n            return streaming_compiler.compile(code, filename);\n        },\n\n        'runjs': function runjs(code) {\n            var ans = vm.runInContext(code, ctx);\n            if (ans !== undefined || ans === null) {\n                ctx._$rapyd$_repl_val = ans;\n                var q = vm.runInContext('_$rapyd$_repr(_$rapyd$_repl_val)', ctx);\n                ans = (q === 'undefined') ? ans.toString() : q;\n            }\n            return ans;\n        },\n\n        'init_completions': function init_completions(completelib) {\n            find_completions = completelib(compiler);\n        },\n\n        'find_completions': function find_completions_(line) {\n            return find_completions(line, ctx);\n        },\n\n    };\n};\n\n","tools/embedded_compiler.js":"/* vim:fileencoding=utf-8\n * \n * Copyright (C) 2016 Kovid Goyal <kovid at kovidgoyal.net>\n *\n * Distributed under terms of the BSD license\n */\n\"use strict\";  /*jshint node:true */\n\n\nmodule.exports = function(compiler, baselib, runjs, name) {\n\tvar output_options = {'omit_baselib':true, 'write_name':false, 'private_scope':false, 'beautify':true, 'js_version': 6};\n    compiler.AST_Node.warn_function = function() {};\n    var LINE_CONTINUATION_CHARS = ':\\\\';\n    runjs = runjs || eval;\n    runjs(baselib);\n    runjs('var __name__ = \"' + (name || '__embedded__') + '\";');\n\n    return {\n        'toplevel': null,\n\n        'compile': function web_repl_compile(code, filename) {\n            var classes = (this.toplevel) ? this.toplevel.classes : undefined;\n            this.toplevel = compiler.parse(code, {\n                'filename': filename || '<embedded>',\n                'basedir': '__stdlib__',\n                'classes': classes,\n            });\n            var out = compiler.OutputStream(output_options);\n            this.toplevel.print(out);\n            if (classes) {\n                var exports = {};\n                var self = this;\n                this.toplevel.exports.forEach(function (name) { exports[name] = true; });\n                Object.getOwnPropertyNames(classes).forEach(function (name) {\n                    if (!exports.hasOwnProperty(name) && !self.toplevel.classes.hasOwnProperty(name))\n                        self.toplevel.classes[name] = classes[name];\n                });\n            }\n    \n            return out.toString();\n        },\n\n    };\n};\n\n","tools/utils.js":"/* vim:fileencoding=utf-8\n * \n * Copyright (C) 2015 Kovid Goyal <kovid at kovidgoyal.net>\n *\n * Distributed under terms of the BSD license\n */\n\"use strict\";  /*jshint node:true */\n\nvar comment_contents = /\\/\\*!?(?:\\@preserve)?[ \\t]*(?:\\r\\n|\\n)([\\s\\S]*?)(?:\\r\\n|\\n)[ \\t]*\\*\\//;\nvar colors = ['red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'];\n\nfunction ansi(code) {\n    code = code || 0;\n    return String.fromCharCode(27) + '[' + code + 'm';\n}\n\nfunction colored(string, color, bold) {\n    var prefix = [];\n    if (bold) prefix.push(ansi(1));\n    if (color) prefix.push(ansi(colors.indexOf(color) + 31));\n    return prefix.join('') + string + ansi(0);\n}\n\nfunction supports_color(stdout) {\n    stdout = stdout || process.stdout;\n\tif (stdout && !stdout.isTTY) {\n\t\treturn false;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\treturn false;\n\t}\n\n\tif ('COLORTERM' in process.env) {\n\t\treturn true;\n\t}\n\n\tif (process.env.TERM === 'dumb') {\n\t\treturn false;\n\t}\n\n\tif (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {\n\t\treturn true;\n\t}\n\n    return false;\n\n}\n\nfunction safe_colored(string) {\n    return string;\n}\n\nfunction repeat(str, num) {\n    return new Array( num + 1 ).join( str );\n}\n\nfunction generators_available() {\n    var gen;\n    try {\n        eval('gen = function *(){}'); // jshint ignore:line\n        return typeof gen === 'function' && gen.constructor.name == 'GeneratorFunction';\n    } catch(e) {\n        return false;\n    }\n}\n\nfunction wrap(lines, width) {\n\tvar ans = [];\n\tvar prev = '';\n\tlines.forEach(function (line) {\n\t\tline = prev + line;\n\t\tprev = '';\n\t\tif (line.length > width) {\n\t\t\tprev = line.substr(width);\n            if (prev) prev += ' ';\n\t\t\tline = line.substr(0, width - 1);\n\t\t\tif (line.substr(line.length - 1 !== ' ')) line += '-';\n\t\t} \n\t\tans.push(line);\n\t});\n\tif (prev) ans = ans.concat(wrap([prev]));\n\treturn ans;\n}\n\nfunction merge() {\n    // Simple merge of properties from all objects\n    var ans = {};\n    Array.prototype.slice.call(arguments).forEach(function (arg) {\n        Object.keys(arg).forEach(function(key) {\n            ans[key] = arg[key];\n        });\n    });\n    return ans;\n}\n\nfunction get_import_dirs(paths_string, ignore_env) {\n    var path = require('path');\n    var paths = [];\n    function merge(new_path) {\n        if (paths.indexOf(new_path) == -1) paths.push(new_path);\n    }\n    if (!ignore_env && process && process.env && process.env.RAPYDSCRIPT_IMPORT_PATH) {\n        process.env.RAPYDSCRIPT_IMPORT_PATH.split(path.delimiter).forEach(merge);\n    }\n    if (paths_string) paths_string.split(path.delimiter).forEach(merge);\n    return paths;\n}\n\nexports.comment_contents = comment_contents;\nexports.repeat = repeat;\nexports.wrap = wrap;\nexports.merge = merge;\nexports.colored = colored;\nexports.safe_colored = (supports_color()) ? colored : safe_colored;\nexports.generators_available = generators_available;\nexports.get_import_dirs = get_import_dirs;\n","tools/completer.js":"/* vim:fileencoding=utf-8\n * \n * Copyright (C) 2016 Kovid Goyal <kovid at kovidgoyal.net>\n *\n * Distributed under terms of the BSD license\n */\n\n\nmodule.exports = function(compiler, options) {\n    \"use strict\";\n    var all_keywords = compiler.ALL_KEYWORDS.split(' ');\n    var vm = require('vm');\n    options = options || {};\n    if (!options.enum_global) options.enum_global = \"var global = Function('return this')(); Object.getOwnPropertyNames(global);\";\n\n    function global_names(ctx) {\n        try {\n            var ans = vm.runInContext(options.enum_global, ctx);\n            ans = ans.concat(all_keywords);\n            ans.sort();\n            var seen = {};\n            ans.filter(function (item) { \n                if (Object.prototype.hasOwnProperty.call(seen, item)) return false;\n                seen[item] = true;\n                return true;\n            });\n            return ans;\n        } catch(e) {\n            console.log(e.stack || e.toString());\n        }\n        return [];\n    }\n\n    function object_names(obj, prefix) {\n        if (obj === null || obj === undefined) return [];\n        var groups = [], prefix_len = prefix.length, p;\n\n        function prefix_filter(name) { return (prefix_len) ? (name.substr(0, prefix_len) === prefix) : true; }\n\n        function add(o) {\n            var items = Object.getOwnPropertyNames(o).filter(prefix_filter);\n            if (items.length) groups.push(items);\n        }\n\n        if (typeof obj === 'object' || typeof obj === 'function') {\n            add(obj);\n            p = Object.getPrototypeOf(obj);\n        } else p = obj.constructor ? obj.constructor.prototype : null; \n\n        // Walk the prototype chain\n        try {\n            var sentinel = 5;\n            while (p !== null && sentinel > 0) {\n                add(p);\n                p = Object.getPrototypeOf(p);\n                // Circular refs possible? Let's guard against that.\n                sentinel--;\n            }\n        } catch (e) {\n            // console.error(\"completion error walking prototype chain:\" + e);\n        }\n        if (!groups.length) return [];\n        var seen = {}, ans = [];\n        function uniq(name) {\n            if (Object.prototype.hasOwnProperty.call(seen, name)) return false;\n            seen[name] = true;\n            return true;\n        }\n        for (var i = 0; i < groups.length; i++) {\n            var group = groups[i];\n            group.sort();\n            ans = ans.concat(group.filter(uniq));\n            ans.push('');  // group separator\n\n        }\n        while (ans.length && ans[ans.length - 1] === '') ans.pop();\n        return ans;\n    }\n\n    function prefix_matches(prefix, items) {\n        var len = prefix.length;\n        var ans = items.filter(function(item) { return item.substr(0, len) === prefix; });\n        ans.sort();\n        return ans;\n    }\n\n    function find_completions(line, ctx) {\n        var t;\n        try {\n            t = compiler.tokenizer(line, '<repl>');\n        } catch(e) { return []; }\n        var tokens = [], token;\n        while (true) {\n            try {\n                token = t();\n            } catch (e) { return []; }\n            if (token.type === 'eof') break;\n            if (token.type === 'punc' && '(){},;:'.indexOf(token.value) > -1)\n                tokens = [];\n            tokens.push(token);\n        }\n        if (!tokens.length) {\n            // New line or trailing space\n            return [global_names(ctx), ''];\n        }\n        var last_tok = tokens[tokens.length - 1];\n        if (last_tok.value === '.' || (last_tok.type === 'name' && compiler.IDENTIFIER_PAT.test(last_tok.value))) {\n            last_tok = last_tok.value;\n            if (last_tok === '.') {\n                tokens.push({'value':''});\n                last_tok = '';\n            }\n            if (tokens.length > 1 && tokens[tokens.length - 2].value === '.') {\n                // A compound expression\n                var prefix = '', result;\n                tokens.slice(0, tokens.length - 2).forEach(function (tok) { prefix += tok.value; });\n                if (prefix) {\n                    try {\n                        result = vm.runInContext(prefix, ctx, {'displayErrors':false});\n                    } catch(e) { return []; }\n                    return [object_names(result, last_tok), last_tok];\n                }\n            } else {\n                return [prefix_matches(last_tok, global_names(ctx)), last_tok];\n            }\n        }\n        return [];\n    }\n\n    return find_completions;\n};\n","__stdlib__/elementmaker.pyj":"# vim:fileencoding=utf-8\n# License: GPL v3 Copyright: 2015, Kovid Goyal <kovid at kovidgoyal.net>\n\nhtml_elements = {\n    'a', 'abbr', 'acronym', 'address', 'area',\n    'article', 'aside', 'audio', 'b', 'big', 'blockquote', 'br', 'button',\n    'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup',\n    'command', 'datagrid', 'datalist', 'dd', 'del', 'details', 'dfn',\n    'dialog', 'dir', 'div', 'dl', 'dt', 'em', 'event-source', 'fieldset',\n    'figcaption', 'figure', 'footer', 'font', 'form', 'header', 'h1',\n    'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'img', 'input', 'ins',\n    'keygen', 'kbd', 'label', 'legend', 'li', 'm', 'map', 'menu', 'meter',\n    'multicol', 'nav', 'nextid', 'ol', 'output', 'optgroup', 'option',\n    'p', 'pre', 'progress', 'q', 's', 'samp', 'script', 'section', 'select',\n    'small', 'sound', 'source', 'spacer', 'span', 'strike', 'strong', 'style',\n    'sub', 'sup', 'table', 'tbody', 'td', 'textarea', 'time', 'tfoot',\n    'th', 'thead', 'tr', 'tt', 'u', 'ul', 'var', 'video'\n}\n\nmathml_elements = {\n    'maction', 'math', 'merror', 'mfrac', 'mi',\n    'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom',\n    'mprescripts', 'mroot', 'mrow', 'mspace', 'msqrt', 'mstyle', 'msub',\n    'msubsup', 'msup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder',\n    'munderover', 'none'\n}\n\nsvg_elements = {\n    'a', 'animate', 'animateColor', 'animateMotion',\n    'animateTransform', 'clipPath', 'circle', 'defs', 'desc', 'ellipse',\n    'font-face', 'font-face-name', 'font-face-src', 'g', 'glyph', 'hkern',\n    'linearGradient', 'line', 'marker', 'metadata', 'missing-glyph',\n    'mpath', 'path', 'polygon', 'polyline', 'radialGradient', 'rect',\n    'set', 'stop', 'svg', 'switch', 'text', 'title', 'tspan', 'use'\n}\n\nhtml5_tags = html_elements.union(mathml_elements).union(svg_elements)\n\ndef _makeelement(tag, *args, **kwargs):\n    ans = this.createElement(tag)\n\n    for attr in kwargs:\n        vattr = str.replace(str.rstrip(attr, '_'), '_', '-')\n        val = kwargs[attr]\n        if callable(val):\n            if str.startswith(attr, 'on'):\n                attr = attr[2:]\n            ans.addEventListener(attr, val)\n        else:\n            ans.setAttribute(vattr, val)\n\n    for arg in args:\n        if type(arg) is 'string':\n            arg = this.createTextNode(arg)\n        ans.appendChild(arg)\n    return ans\n\ndef maker_for_document(document):\n    # Create an elementmaker to be used with the specified document\n    E = _makeelement.bind(document)\n    for tag in html5_tags:\n        Object.defineProperty(E, tag, {'value':_makeelement.bind(document, tag)})\n    return E\n\nif type(document) is 'undefined':\n    E = maker_for_document({\n        'createTextNode': def(value): return value;,\n        'createElement': def(name):\n            return  {\n                'name':name,\n                'children':[],\n                'attributes':{},\n                'setAttribute': def(name, val): this.attributes[name] = val;,\n                'appendChild': def(child): this.children.push(child);,\n            }\n    })\nelse:\n    E = maker_for_document(document)\n","__stdlib__/gettext.pyj":"# vim:fileencoding=utf-8\n# License: BSD Copyright: 2015, Kovid Goyal <kovid at kovidgoyal.net>\n\n# noqa: eol-semicolon\n\n# The Plural-Forms parser {{{\n# From: https://github.com/SlexAxton/Jed/blob/master/jed.js licensed under the WTFPL\n\nJed = {}\n\nvr'''\n  Jed.PF = {};\n\n  Jed.PF.parse = function ( p ) {\n    var plural_str = Jed.PF.extractPluralExpr( p );\n    return Jed.PF.parser.parse.call(Jed.PF.parser, plural_str);\n  };\n\n  Jed.PF.compile = function ( p ) {\n    // Handle trues and falses as 0 and 1\n    function imply( val ) {\n      return (val === true ? 1 : val ? val : 0);\n    }\n\n    var ast = Jed.PF.parse( p );\n    return function ( n ) {\n      return imply( Jed.PF.interpreter( ast )( n ) );\n    };\n  };\n\n  Jed.PF.interpreter = function ( ast ) {\n    return function ( n ) {\n      var res;\n      switch ( ast.type ) {\n        case 'GROUP':\n          return Jed.PF.interpreter( ast.expr )( n );\n        case 'TERNARY':\n          if ( Jed.PF.interpreter( ast.expr )( n ) ) {\n            return Jed.PF.interpreter( ast.truthy )( n );\n          }\n          return Jed.PF.interpreter( ast.falsey )( n );\n        case 'OR':\n          return Jed.PF.interpreter( ast.left )( n ) || Jed.PF.interpreter( ast.right )( n );\n        case 'AND':\n          return Jed.PF.interpreter( ast.left )( n ) && Jed.PF.interpreter( ast.right )( n );\n        case 'LT':\n          return Jed.PF.interpreter( ast.left )( n ) < Jed.PF.interpreter( ast.right )( n );\n        case 'GT':\n          return Jed.PF.interpreter( ast.left )( n ) > Jed.PF.interpreter( ast.right )( n );\n        case 'LTE':\n          return Jed.PF.interpreter( ast.left )( n ) <= Jed.PF.interpreter( ast.right )( n );\n        case 'GTE':\n          return Jed.PF.interpreter( ast.left )( n ) >= Jed.PF.interpreter( ast.right )( n );\n        case 'EQ':\n          return Jed.PF.interpreter( ast.left )( n ) == Jed.PF.interpreter( ast.right )( n );\n        case 'NEQ':\n          return Jed.PF.interpreter( ast.left )( n ) != Jed.PF.interpreter( ast.right )( n );\n        case 'MOD':\n          return Jed.PF.interpreter( ast.left )( n ) % Jed.PF.interpreter( ast.right )( n );\n        case 'VAR':\n          return n;\n        case 'NUM':\n          return ast.val;\n        default:\n          throw new Error(\"Invalid Token found.\");\n      }\n    };\n  };\n\n  Jed.PF.extractPluralExpr = function ( p ) {\n    // trim first\n    p = p.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n\n    if (! /;\\s*$/.test(p)) {\n      p = p.concat(';');\n    }\n\n    var nplurals_re = /nplurals\\=(\\d+);/,\n        plural_re = /plural\\=(.*);/,\n        nplurals_matches = p.match( nplurals_re ),\n        res = {},\n        plural_matches;\n\n    // Find the nplurals number\n    if ( nplurals_matches.length > 1 ) {\n      res.nplurals = nplurals_matches[1];\n    }\n    else {\n      throw new Error('nplurals not found in plural_forms string: ' + p );\n    }\n\n    // remove that data to get to the formula\n    p = p.replace( nplurals_re, \"\" );\n    plural_matches = p.match( plural_re );\n\n    if (!( plural_matches && plural_matches.length > 1 ) ) {\n      throw new Error('`plural` expression not found: ' + p);\n    }\n    return plural_matches[ 1 ];\n  };\n\n  /* Jison generated parser */\n  Jed.PF.parser = (function(){\n\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"expressions\":3,\"e\":4,\"EOF\":5,\"?\":6,\":\":7,\"||\":8,\"&&\":9,\"<\":10,\"<=\":11,\">\":12,\">=\":13,\"!=\":14,\"==\":15,\"%\":16,\"(\":17,\")\":18,\"n\":19,\"NUMBER\":20,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"EOF\",6:\"?\",7:\":\",8:\"||\",9:\"&&\",10:\"<\",11:\"<=\",12:\">\",13:\">=\",14:\"!=\",15:\"==\",16:\"%\",17:\"(\",18:\")\",19:\"n\",20:\"NUMBER\"},\nproductions_: [0,[3,2],[4,5],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,1],[4,1]],\nperformAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1: return { type : 'GROUP', expr: $$[$0-1] };\ncase 2:this.$ = { type: 'TERNARY', expr: $$[$0-4], truthy : $$[$0-2], falsey: $$[$0] };\nbreak;\ncase 3:this.$ = { type: \"OR\", left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 4:this.$ = { type: \"AND\", left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 5:this.$ = { type: 'LT', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 6:this.$ = { type: 'LTE', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 7:this.$ = { type: 'GT', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 8:this.$ = { type: 'GTE', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 9:this.$ = { type: 'NEQ', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 10:this.$ = { type: 'EQ', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 11:this.$ = { type: 'MOD', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 12:this.$ = { type: 'GROUP', expr: $$[$0-1] };\nbreak;\ncase 13:this.$ = { type: 'VAR' };\nbreak;\ncase 14:this.$ = { type: 'NUM', val: Number(yytext) };\nbreak;\n}\n},\ntable: [{3:1,4:2,17:[1,3],19:[1,4],20:[1,5]},{1:[3]},{5:[1,6],6:[1,7],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16]},{4:17,17:[1,3],19:[1,4],20:[1,5]},{5:[2,13],6:[2,13],7:[2,13],8:[2,13],9:[2,13],10:[2,13],11:[2,13],12:[2,13],13:[2,13],14:[2,13],15:[2,13],16:[2,13],18:[2,13]},{5:[2,14],6:[2,14],7:[2,14],8:[2,14],9:[2,14],10:[2,14],11:[2,14],12:[2,14],13:[2,14],14:[2,14],15:[2,14],16:[2,14],18:[2,14]},{1:[2,1]},{4:18,17:[1,3],19:[1,4],20:[1,5]},{4:19,17:[1,3],19:[1,4],20:[1,5]},{4:20,17:[1,3],19:[1,4],20:[1,5]},{4:21,17:[1,3],19:[1,4],20:[1,5]},{4:22,17:[1,3],19:[1,4],20:[1,5]},{4:23,17:[1,3],19:[1,4],20:[1,5]},{4:24,17:[1,3],19:[1,4],20:[1,5]},{4:25,17:[1,3],19:[1,4],20:[1,5]},{4:26,17:[1,3],19:[1,4],20:[1,5]},{4:27,17:[1,3],19:[1,4],20:[1,5]},{6:[1,7],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[1,28]},{6:[1,7],7:[1,29],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16]},{5:[2,3],6:[2,3],7:[2,3],8:[2,3],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[2,3]},{5:[2,4],6:[2,4],7:[2,4],8:[2,4],9:[2,4],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[2,4]},{5:[2,5],6:[2,5],7:[2,5],8:[2,5],9:[2,5],10:[2,5],11:[2,5],12:[2,5],13:[2,5],14:[2,5],15:[2,5],16:[1,16],18:[2,5]},{5:[2,6],6:[2,6],7:[2,6],8:[2,6],9:[2,6],10:[2,6],11:[2,6],12:[2,6],13:[2,6],14:[2,6],15:[2,6],16:[1,16],18:[2,6]},{5:[2,7],6:[2,7],7:[2,7],8:[2,7],9:[2,7],10:[2,7],11:[2,7],12:[2,7],13:[2,7],14:[2,7],15:[2,7],16:[1,16],18:[2,7]},{5:[2,8],6:[2,8],7:[2,8],8:[2,8],9:[2,8],10:[2,8],11:[2,8],12:[2,8],13:[2,8],14:[2,8],15:[2,8],16:[1,16],18:[2,8]},{5:[2,9],6:[2,9],7:[2,9],8:[2,9],9:[2,9],10:[2,9],11:[2,9],12:[2,9],13:[2,9],14:[2,9],15:[2,9],16:[1,16],18:[2,9]},{5:[2,10],6:[2,10],7:[2,10],8:[2,10],9:[2,10],10:[2,10],11:[2,10],12:[2,10],13:[2,10],14:[2,10],15:[2,10],16:[1,16],18:[2,10]},{5:[2,11],6:[2,11],7:[2,11],8:[2,11],9:[2,11],10:[2,11],11:[2,11],12:[2,11],13:[2,11],14:[2,11],15:[2,11],16:[2,11],18:[2,11]},{5:[2,12],6:[2,12],7:[2,12],8:[2,12],9:[2,12],10:[2,12],11:[2,12],12:[2,12],13:[2,12],14:[2,12],15:[2,12],16:[2,12],18:[2,12]},{4:30,17:[1,3],19:[1,4],20:[1,5]},{5:[2,2],6:[1,7],7:[2,2],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[2,2]}],\ndefaultActions: {6:[2,1]},\nparseError: function parseError(str, hash) {\n    throw new Error(str);\n},\nparse: function parse(input) {\n    var self = this,\n        stack = [0],\n        vstack = [null], // semantic value stack\n        lstack = [], // location stack\n        table = this.table,\n        yytext = '',\n        yylineno = 0,\n        yyleng = 0,\n        recovering = 0,\n        TERROR = 2,\n        EOF = 1;\n\n    //this.reductionCount = this.shiftCount = 0;\n\n    this.lexer.setInput(input);\n    this.lexer.yy = this.yy;\n    this.yy.lexer = this.lexer;\n    if (typeof this.lexer.yylloc == 'undefined')\n        this.lexer.yylloc = {};\n    var yyloc = this.lexer.yylloc;\n    lstack.push(yyloc);\n\n    if (typeof this.yy.parseError === 'function')\n        this.parseError = this.yy.parseError;\n\n    function popStack (n) {\n        stack.length = stack.length - 2*n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n\n    function lex() {\n        var token;\n        token = self.lexer.lex() || 1; // $end = 1\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n        return token;\n    }\n\n    var symbol, preErrorSymbol, state, action, a, r, yyval={},p,len,newState, expected, errStr;\n    while (true) {\n        // retreive state number from top of stack\n        state = stack[stack.length-1];\n\n        // use default actions if available\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || symbol === undefined)\n                symbol = lex();\n            // read action for current state and first input\n            action = table[state] && table[state][symbol];\n        }\n\n        // handle parse error\n        _handle_error:\n        if (typeof action === 'undefined' || !action.length || !action[0]) {\n\n            if (!recovering) {\n                // Report error\n                expected = [];\n                for (p in table[state]) if (this.terminals_[p] && p > 2) {\n                    expected.push(\"'\"+this.terminals_[p]+\"'\");\n                }\n                errStr = '';\n                if (this.lexer.showPosition) {\n                    errStr = 'Parse error on line '+(yylineno+1)+\":\\n\"+this.lexer.showPosition()+\"\\nExpecting \"+expected.join(', ') + \", got '\" + this.terminals_[symbol]+ \"'\";\n                } else {\n                    errStr = 'Parse error on line '+(yylineno+1)+\": Unexpected \" +\n                                  (symbol == 1 /*EOF*/ ? \"end of input\" :\n                                              (\"'\"+(this.terminals_[symbol] || symbol)+\"'\"));\n                }\n                this.parseError(errStr,\n                    {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});\n            }\n\n            // just recovered from another error\n            if (recovering == 3) {\n                if (symbol == EOF) {\n                    throw new Error(errStr || 'Parsing halted.');\n                }\n\n                // discard current lookahead and grab another\n                yyleng = this.lexer.yyleng;\n                yytext = this.lexer.yytext;\n                yylineno = this.lexer.yylineno;\n                yyloc = this.lexer.yylloc;\n                symbol = lex();\n            }\n\n            // try to recover from error\n            while (1) {\n                // check for error recovery rule in this state\n                if ((TERROR.toString()) in table[state]) {\n                    break;\n                }\n                if (state === 0) {\n                    throw new Error(errStr || 'Parsing halted.');\n                }\n                popStack(1);\n                state = stack[stack.length-1];\n            }\n\n            preErrorSymbol = symbol; // save the lookahead token\n            symbol = TERROR;         // insert generic error symbol as new lookahead\n            state = stack[stack.length-1];\n            action = table[state] && table[state][TERROR];\n            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\n        }\n\n        // this shouldn't happen, unless resolve defaults are off\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);\n        }\n\n        switch (action[0]) {\n\n            case 1: // shift\n                //this.shiftCount++;\n\n                stack.push(symbol);\n                vstack.push(this.lexer.yytext);\n                lstack.push(this.lexer.yylloc);\n                stack.push(action[1]); // push state\n                symbol = null;\n                if (!preErrorSymbol) { // normal execution/no error\n                    yyleng = this.lexer.yyleng;\n                    yytext = this.lexer.yytext;\n                    yylineno = this.lexer.yylineno;\n                    yyloc = this.lexer.yylloc;\n                    if (recovering > 0)\n                        recovering--;\n                } else { // error just occurred, resume old lookahead f/ before error\n                    symbol = preErrorSymbol;\n                    preErrorSymbol = null;\n                }\n                break;\n\n            case 2: // reduce\n                //this.reductionCount++;\n\n                len = this.productions_[action[1]][1];\n\n                // perform semantic action\n                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1\n                // default location, uses first token for firsts, last for lasts\n                yyval._$ = {\n                    first_line: lstack[lstack.length-(len||1)].first_line,\n                    last_line: lstack[lstack.length-1].last_line,\n                    first_column: lstack[lstack.length-(len||1)].first_column,\n                    last_column: lstack[lstack.length-1].last_column\n                };\n                r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n\n                if (typeof r !== 'undefined') {\n                    return r;\n                }\n\n                // pop off stack\n                if (len) {\n                    stack = stack.slice(0,-1*len*2);\n                    vstack = vstack.slice(0, -1*len);\n                    lstack = lstack.slice(0, -1*len);\n                }\n\n                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)\n                vstack.push(yyval.$);\n                lstack.push(yyval._$);\n                // goto new state = table[STATE][NONTERMINAL]\n                newState = table[stack[stack.length-2]][stack[stack.length-1]];\n                stack.push(newState);\n                break;\n\n            case 3: // accept\n                return true;\n        }\n\n    }\n\n    return true;\n}};/* Jison generated lexer */\nvar lexer = (function(){\n\nvar lexer = ({EOF:1,\nparseError:function parseError(str, hash) {\n        if (this.yy.parseError) {\n            this.yy.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\nsetInput:function (input) {\n        this._input = input;\n        this._more = this._less = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};\n        return this;\n    },\ninput:function () {\n        var ch = this._input[0];\n        this.yytext+=ch;\n        this.yyleng++;\n        this.match+=ch;\n        this.matched+=ch;\n        var lines = ch.match(/\\n/);\n        if (lines) this.yylineno++;\n        this._input = this._input.slice(1);\n        return ch;\n    },\nunput:function (ch) {\n        this._input = ch + this._input;\n        return this;\n    },\nmore:function () {\n        this._more = true;\n        return this;\n    },\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\\n/g, \"\");\n    },\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c+\"^\";\n    },\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) this.done = true;\n\n        var token,\n            match,\n            col,\n            lines;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i=0;i < rules.length; i++) {\n            match = this._input.match(this.rules[rules[i]]);\n            if (match) {\n                lines = match[0].match(/\\n.*/g);\n                if (lines) this.yylineno += lines.length;\n                this.yylloc = {first_line: this.yylloc.last_line,\n                               last_line: this.yylineno+1,\n                               first_column: this.yylloc.last_column,\n                               last_column: lines ? lines[lines.length-1].length-1 : this.yylloc.last_column + match[0].length};\n                this.yytext += match[0];\n                this.match += match[0];\n                this.matches = match;\n                this.yyleng = this.yytext.length;\n                this._more = false;\n                this._input = this._input.slice(match[0].length);\n                this.matched += match[0];\n                token = this.performAction.call(this, this.yy, this, rules[i],this.conditionStack[this.conditionStack.length-1]);\n                if (token) return token;\n                else return;\n            }\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\\n'+this.showPosition(),\n                    {text: \"\", token: null, line: this.yylineno});\n        }\n    },\nlex:function lex() {\n        var r = this.next();\n        if (typeof r !== 'undefined') {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\npopState:function popState() {\n        return this.conditionStack.pop();\n    },\n_currentRules:function _currentRules() {\n        return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;\n    },\ntopState:function () {\n        return this.conditionStack[this.conditionStack.length-2];\n    },\npushState:function begin(condition) {\n        this.begin(condition);\n    }});\nlexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\n\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:/* skip whitespace */\nbreak;\ncase 1:return 20\nbreak;\ncase 2:return 19\nbreak;\ncase 3:return 8\nbreak;\ncase 4:return 9\nbreak;\ncase 5:return 6\nbreak;\ncase 6:return 7\nbreak;\ncase 7:return 11\nbreak;\ncase 8:return 13\nbreak;\ncase 9:return 10\nbreak;\ncase 10:return 12\nbreak;\ncase 11:return 14\nbreak;\ncase 12:return 15\nbreak;\ncase 13:return 16\nbreak;\ncase 14:return 17\nbreak;\ncase 15:return 18\nbreak;\ncase 16:return 5\nbreak;\ncase 17:return 'INVALID'\nbreak;\n}\n};\nlexer.rules = [/^\\s+/,/^[0-9]+(\\.[0-9]+)?\\b/,/^n\\b/,/^\\|\\|/,/^&&/,/^\\?/,/^:/,/^<=/,/^>=/,/^</,/^>/,/^!=/,/^==/,/^%/,/^\\(/,/^\\)/,/^$/,/^./];\nlexer.conditions = {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17],\"inclusive\":true}};return lexer;})()\nparser.lexer = lexer;\nreturn parser;\n})();\n'''\nplural_forms_parser = Jed.PF\n# }}}\n\ndef _get_plural_forms_function(plural_forms_string):\n    return plural_forms_parser.compile(plural_forms_string or \"nplurals=2; plural=(n != 1);\")\n\n_gettext = def(text): return text\n\n_ngettext = def(text, plural, n): return text if n is 1 else plural\n\ndef gettext(text):\n    return _gettext(text)\n\ndef ngettext(text, plural, n):\n    return _ngettext(text, plural, n)\n\ndef install(translation_data):\n    t = new Translations(translation_data)\n    t.install()\n    return t\n\nclass Translations:\n\n    def __init__(self, translation_data):\n        translation_data = translation_data or {}\n        translation_data['func'] = _get_plural_forms_function(translation_data['plural_forms'])\n        self.translations = v'[translation_data]'\n        self.language = translation_data['language']\n\n    def add_fallback(self, fallback):\n        fallback['func'] = _get_plural_forms_function(fallback['plural_forms'])\n        self.translations.push(fallback or {})\n\n    def gettext(self, text):\n        for t in self.translations:\n            m = t['entries']\n            if Object.prototype.hasOwnProperty.call(m, text):\n                return m[text][0]\n        return text\n\n    def ngettext(self, text, plural, n):\n        for t in self.translations:\n            m = t['entries']\n            if Object.prototype.hasOwnProperty.call(m, text):\n                idx = t['func'](n)\n                return m[text][idx] or (text if n is 1 else plural)\n        return text if n is 1 else plural\n\n    def install(self):\n        nonlocal _gettext, _ngettext\n        _gettext = def ():\n            return self.gettext.apply(self, arguments)\n        _ngettext = def ():\n            return self.ngettext.apply(self, arguments)\n\n","__stdlib__/math.pyj":"###########################################################\n# RapydScript Standard Library\n# Author: Alexander Tsepkov\n# Copyright 2013 Pyjeon Software LLC\n# License: Apache License    2.0\n# This library is covered under Apache license, so that\n# you can distribute it with your RapydScript applications.\n###########################################################\n\n\n# basic implementation of Python's 'math' library\n\n# NOTE: this is only meant to aid those porting lots of Python code into RapydScript,\n# if you're writing a new RapydScript application, in most cases you probably want to\n# use JavaScript's Math module directly instead\n\n\npi = Math.PI\ne = Math.E\n\n########################################\n# Number-theoretic and representation functions\n########################################\ndef ceil(x):\n    return Math.ceil(x)\ndef copysign(x, y):\n    x = Math.abs(x)\n    if y < 0:\n        return -x\n    else:\n        return x\ndef fabs(x):\n    return Math.abs(x)\ndef factorial(x):\n    if Math.abs(int(x)) is not x:\n        raise ValueError(\"factorial() only accepts integral values\")\n    factorial.cache = []\n    r = def(n):\n        if n is 0 or n is 1:\n            return 1\n        if not factorial.cache[n]:\n            factorial.cache[n] = r(n-1) * n\n        return factorial.cache[n]\n    return r(x)\ndef floor(x):\n    return Math.floor(x)\ndef fmod(x, y):\n    # javascript's % operator isn't consistent with C fmod implementation, this function is\n    while y <= x:\n        x -= y\n    return x\ndef fsum(iterable):\n    # like Python's fsum, this method is much more resilient to rounding errors than regular sum\n    partials = []   # sorted, non-overlapping partial sums\n    for x in iterable:\n        i = 0\n        for y in partials:\n            if Math.abs(x) < Math.abs(y):\n                x, y = y, x\n            hi = x + y\n            lo = y - (hi - x)\n            if lo:\n                partials[i] = lo\n                i += 1\n            x = hi\n        #partials[i:] = [x]\n        partials.splice(i, partials.length-i, x)\n    return sum(partials)\ndef isinf(x):\n    return not isFinite(x)\ndef isnan(x):\n    return isNaN(x)\ndef modf(x):\n    m = fmod(x, 1)\n    return m, x-m\ndef trunc(x):\n    return x | 0\n\n########################################\n# Power and logarithmic functions\n########################################\ndef exp(x):\n    return Math.exp(x)\ndef expm1(x):\n    # NOTE: Math.expm1() is currently only implemented in Firefox, this provides alternative implementation\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/expm1\n    #return Math.expm1(x)\n    if Math.abs(x) < 1e-5:\n        return x + 0.5*x*x\n    else:\n        return Math.exp(x) - 1\ndef log(x, base=e):\n    return Math.log(x)/Math.log(base)\ndef log1p(x):\n    # NOTE: Math.log1p() is currently only implemented in Firefox, this provides alternative implementation\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log1p\n    # this version has been taken from http://phpjs.org/functions/log1p/\n    # admittedly it's not as accurate as MDN version, as you can see from math.log1p(1) result\n    ret = 0\n    n = 50\n    if x <= -1:\n        return Number.NEGATIVE_INFINITY\n    if x < 0 or x > 1:\n        return Math.log(1 + x)\n    for i in range(1, n):\n        if i % 2 is 0:\n            ret -= Math.pow(x, i) / i\n        else:\n            ret += Math.pow(x, i) / i\n    return ret\ndef log10(x):\n    # NOTE: Math.log10() is currently only implemented in Firefox, this provides alternative implementation\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log10\n    # I didn't find a more accurate algorithm so I'm using the basic implementation\n    return Math.log(x)/Math.LN10\ndef pow(x, y):\n    if x < 0 and int(y) is not y:\n        raise ValueError('math domain error')\n    if isnan(y) and x is 1:\n        return 1\n    return Math.pow(x, y)\ndef sqrt(x):\n    return Math.sqrt(x)\n\n########################################\n# Trigonometric functions\n########################################\ndef acos(x):        return Math.acos(x)\ndef asin(x):        return Math.asin(x)\ndef atan(x):        return Math.atan(x)\ndef atan2(y, x):    return Math.atan2(y, x)\ndef cos(x):         return Math.cos(x)\ndef sin(x):         return Math.sin(x)\ndef hypot(x, y):    return Math.sqrt(x*x + y*y)\ndef tan(x):         return Math.tan(x)\n\n########################################\n# Angular conversion\n########################################\ndef degrees(x):     return x*180/pi\ndef radians(x):     return x*pi/180\n\n########################################\n# Hyperbolic functions\n########################################\ndef acosh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/acosh\n    return Math.log(x + Math.sqrt(x*x - 1))\ndef asinh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/asinh\n    return Math.log(x + Math.sqrt(x*x + 1))\ndef atanh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atanh\n    return 0.5 * Math.log((1 + x) / (1 - x))\ndef cosh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cosh\n    return (Math.exp(x) + Math.exp(-x)) / 2\ndef sinh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sinh\n    return (Math.exp(x) - Math.exp(-x)) / 2\ndef tanh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/tanh\n    return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x))\n\n\n\n#import stdlib\n#print(math.ceil(4.2))\n#print(math.floor(4.2))\n#print(math.fabs(-6))\n#print(math.copysign(-5, 7))\n#print(math.factorial(4))\n#print(math.fmod(-1e100, 1e100))\n#\n#d = [0.9999999, 1, 2, 3]\n#print(sum(d), math.fsum(d))\n#print(math.isinf(5), math.isinf(Infinity))\n#print(math.modf(5.5))\n#print(math.trunc(2.6), math.trunc(-2.6))\n#print(math.exp(1e-5), math.expm1(1e-5))\n#print(math.log(10), math.log(10, 1000))\n#print(math.log1p(1e-15), math.log1p(1))\n#print(math.log10(1000), math.log(1000, 10))\n#print(math.pow(1, 0), math.pow(1, NaN), math.pow(0, 0), math.pow(NaN, 0), math.pow(4,3), math.pow(100, -2))\n#print(math.hypot(3,4))\n#print(math.acosh(2), math.asinh(1), math.atanh(0.5), math.cosh(1), math.cosh(-1), math.sinh(1), math.tanh(1))\n","__stdlib__/operator.pyj":"add = __add__ = def(x, y): return x + y\nsub = __sub__ = def(x, y): return x - y\nmul = __mul__ = def(x, y): return x * y\ndiv = __div__ = def(x, y): return x / y\n\nlt = __lt__ = def(x, y): return x < y\nle = __le__ = def(x, y): return x <= y\neq = __eq__ = def(x, y): return x is y\nne = __ne__ = def(x, y): return x is not y\nge = __ge__ = def(x, y): return x >= y\ngt = __gt__ = def(x, y): return x > y\n","__stdlib__/random.pyj":"###########################################################\n# RapydScript Standard Library\n# Author: Alexander Tsepkov\n# Copyright 2013 Pyjeon Software LLC\n# License: Apache License    2.0\n# This library is covered under Apache license, so that\n# you can distribute it with your RapydScript applications.\n###########################################################\n\n\n# basic implementation of Python's 'random' library\n\n# JavaScript's Math.random() does not allow seeding its random generator, to bypass that, this module implements its own\n# version that can be seeded. I decided on RC4 algorithm for this.\n\n# please don't mess with this from the outside\n\n_$rapyd$_seed_state = {\n    'key': [],\n    'key_i': 0,\n    'key_j': 0\n}\n\n_$rapyd$_get_random_byte = def():\n    _$rapyd$_seed_state.key_i = (_$rapyd$_seed_state.key_i + 1) % 256\n    _$rapyd$_seed_state.key_j = (_$rapyd$_seed_state.key_j + _$rapyd$_seed_state.key[_$rapyd$_seed_state.key_i]) % 256\n    _$rapyd$_seed_state.key[_$rapyd$_seed_state.key_i], _$rapyd$_seed_state.key[_$rapyd$_seed_state.key_j] = \\\n            _$rapyd$_seed_state.key[_$rapyd$_seed_state.key_j], _$rapyd$_seed_state.key[_$rapyd$_seed_state.key_i]\n    return _$rapyd$_seed_state.key[(_$rapyd$_seed_state.key[_$rapyd$_seed_state.key_i] + \\\n            _$rapyd$_seed_state.key[_$rapyd$_seed_state.key_j]) % 256]\n\ndef seed(x=Date().getTime()):\n    if type(x) is 'number':\n        x = x.toString()\n    elif type(x) is not 'string':\n        raise TypeError(\"unhashable type: '\" + type(x) + \"'\")\n    for i in range(256):\n        _$rapyd$_seed_state.key[i] = i\n    j = 0\n    for i in range(256):\n        j = (j + _$rapyd$_seed_state.key[i] + x.charCodeAt(i % x.length)) % 256\n        _$rapyd$_seed_state.key[i], _$rapyd$_seed_state.key[j] = _$rapyd$_seed_state.key[j], _$rapyd$_seed_state.key[i]\nseed()\n\ndef random():\n    n = 0\n    m = 1\n    for i in range(8):\n        n += _$rapyd$_get_random_byte() * m\n        m *= 256\n    return n / 18446744073709551616\n\n# unlike the python version, this DOES build a range object, feel free to reimplement\ndef randrange():\n    return choice(range.apply(this, arguments))\n\ndef randint(a, b):\n    return int(random()*(b-a+1) + a)\n\ndef uniform(a, b):\n    return random()*(b-a) + a\n\ndef choice(seq):\n    if seq.length > 0:\n        return seq[Math.floor(random()*seq.length)]\n    else:\n        raise IndexError()\n\n# uses Fisher-Yates algorithm to shuffle an array\ndef shuffle(x, random_f=random):\n    for i in range(x.length):\n        j = Math.floor(random_f() * (i+1))\n        x[i], x[j] = x[j], x[i]\n    return x\n\n# similar to shuffle, but only shuffles a subset and creates a copy\ndef sample(population, k):\n    x = population.slice()\n    for i in range(population.length-1, population.length-k-1, -1):\n        j = Math.floor(random() * (i+1))\n        x[i], x[j] = x[j], x[i]\n    return x.slice(population.length-k)\n\n\n#import stdlib\n#a = range(50)\n#random.seed(5)\n#print(random.choice(a))\n#print(random.shuffle(a))\n#print(random.randrange(10))\n#print(random.randint(1,5))\n#print(random.uniform(1,5))\n#print(random.sample(range(20),5))\n","__stdlib__/re.pyj":"# vim:fileencoding=utf-8\n# License: BSD\n# Copyright: 2015, Kovid Goyal <kovid at kovidgoyal.net>\n# Copyright: 2013, Alexander Tsepkov\n\n# globals: _$rapyd$_iterator_symbol, _$rapyd$_list_decorate\n\n# basic implementation of Python's 're' library\n\n\n# Alias DB from http://www.unicode.org/Public/8.0.0/ucd/NameAliases.txt {{{\n_ALIAS_MAP = {\"null\":0,\"nul\":0,\"start of heading\":1,\"soh\":1,\"start of text\":2,\"stx\":2,\"end of text\":3,\"etx\":3,\"end of transmission\":4,\"eot\":4,\"enquiry\":5,\"enq\":5,\"acknowledge\":6,\"ack\":6,\"alert\":7,\"bel\":7,\"backspace\":8,\"bs\":8,\"character tabulation\":9,\"horizontal tabulation\":9,\"ht\":9,\"tab\":9,\"line feed\":10,\"new line\":10,\"end of line\":10,\"lf\":10,\"nl\":10,\"eol\":10,\"line tabulation\":11,\"vertical tabulation\":11,\"vt\":11,\"form feed\":12,\"ff\":12,\"carriage return\":13,\"cr\":13,\"shift out\":14,\"locking-shift one\":14,\"so\":14,\"shift in\":15,\"locking-shift zero\":15,\"si\":15,\"data link escape\":16,\"dle\":16,\"device control one\":17,\"dc1\":17,\"device control two\":18,\"dc2\":18,\"device control three\":19,\"dc3\":19,\"device control four\":20,\"dc4\":20,\"negative acknowledge\":21,\"nak\":21,\"synchronous idle\":22,\"syn\":22,\"end of transmission block\":23,\"etb\":23,\"cancel\":24,\"can\":24,\"end of medium\":25,\"eom\":25,\"substitute\":26,\"sub\":26,\"escape\":27,\"esc\":27,\"information separator four\":28,\"file separator\":28,\"fs\":28,\"information separator three\":29,\"group separator\":29,\"gs\":29,\"information separator two\":30,\"record separator\":30,\"rs\":30,\"information separator one\":31,\"unit separator\":31,\"us\":31,\"sp\":32,\"delete\":127,\"del\":127,\"padding character\":128,\"pad\":128,\"high octet preset\":129,\"hop\":129,\"break permitted here\":130,\"bph\":130,\"no break here\":131,\"nbh\":131,\"index\":132,\"ind\":132,\"next line\":133,\"nel\":133,\"start of selected area\":134,\"ssa\":134,\"end of selected area\":135,\"esa\":135,\"character tabulation set\":136,\"horizontal tabulation set\":136,\"hts\":136,\"character tabulation with justification\":137,\"horizontal tabulation with justification\":137,\"htj\":137,\"line tabulation set\":138,\"vertical tabulation set\":138,\"vts\":138,\"partial line forward\":139,\"partial line down\":139,\"pld\":139,\"partial line backward\":140,\"partial line up\":140,\"plu\":140,\"reverse line feed\":141,\"reverse index\":141,\"ri\":141,\"single shift two\":142,\"single-shift-2\":142,\"ss2\":142,\"single shift three\":143,\"single-shift-3\":143,\"ss3\":143,\"device control string\":144,\"dcs\":144,\"private use one\":145,\"private use-1\":145,\"pu1\":145,\"private use two\":146,\"private use-2\":146,\"pu2\":146,\"set transmit state\":147,\"sts\":147,\"cancel character\":148,\"cch\":148,\"message waiting\":149,\"mw\":149,\"start of guarded area\":150,\"start of protected area\":150,\"spa\":150,\"end of guarded area\":151,\"end of protected area\":151,\"epa\":151,\"start of string\":152,\"sos\":152,\"single graphic character introducer\":153,\"sgc\":153,\"single character introducer\":154,\"sci\":154,\"control sequence introducer\":155,\"csi\":155,\"string terminator\":156,\"st\":156,\"operating system command\":157,\"osc\":157,\"privacy message\":158,\"pm\":158,\"application program command\":159,\"apc\":159,\"nbsp\":160,\"shy\":173,\"latin capital letter gha\":418,\"latin small letter gha\":419,\"cgj\":847,\"alm\":1564,\"syriac sublinear colon skewed left\":1801,\"kannada letter llla\":3294,\"lao letter fo fon\":3741,\"lao letter fo fay\":3743,\"lao letter ro\":3747,\"lao letter lo\":3749,\"tibetan mark bka- shog gi mgo rgyan\":4048,\"fvs1\":6155,\"fvs2\":6156,\"fvs3\":6157,\"mvs\":6158,\"zwsp\":8203,\"zwnj\":8204,\"zwj\":8205,\"lrm\":8206,\"rlm\":8207,\"lre\":8234,\"rle\":8235,\"pdf\":8236,\"lro\":8237,\"rlo\":8238,\"nnbsp\":8239,\"mmsp\":8287,\"wj\":8288,\"lri\":8294,\"rli\":8295,\"fsi\":8296,\"pdi\":8297,\"weierstrass elliptic function\":8472,\"micr on us symbol\":9288,\"micr dash symbol\":9289,\"leftwards triangle-headed arrow with double vertical stroke\":11130,\"rightwards triangle-headed arrow with double vertical stroke\":11132,\"yi syllable iteration mark\":40981,\"presentation form for vertical right white lenticular bracket\":65048,\"vs1\":65024,\"vs2\":65025,\"vs3\":65026,\"vs4\":65027,\"vs5\":65028,\"vs6\":65029,\"vs7\":65030,\"vs8\":65031,\"vs9\":65032,\"vs10\":65033,\"vs11\":65034,\"vs12\":65035,\"vs13\":65036,\"vs14\":65037,\"vs15\":65038,\"vs16\":65039,\"byte order mark\":65279,\"bom\":65279,\"zwnbsp\":65279,\"cuneiform sign nu11 tenu\":74452,\"cuneiform sign nu11 over nu11 bur over bur\":74453,\"byzantine musical symbol fthora skliron chroma vasis\":118981,\"vs17\":917760,\"vs18\":917761,\"vs19\":917762,\"vs20\":917763,\"vs21\":917764,\"vs22\":917765,\"vs23\":917766,\"vs24\":917767,\"vs25\":917768,\"vs26\":917769,\"vs27\":917770,\"vs28\":917771,\"vs29\":917772,\"vs30\":917773,\"vs31\":917774,\"vs32\":917775,\"vs33\":917776,\"vs34\":917777,\"vs35\":917778,\"vs36\":917779,\"vs37\":917780,\"vs38\":917781,\"vs39\":917782,\"vs40\":917783,\"vs41\":917784,\"vs42\":917785,\"vs43\":917786,\"vs44\":917787,\"vs45\":917788,\"vs46\":917789,\"vs47\":917790,\"vs48\":917791,\"vs49\":917792,\"vs50\":917793,\"vs51\":917794,\"vs52\":917795,\"vs53\":917796,\"vs54\":917797,\"vs55\":917798,\"vs56\":917799,\"vs57\":917800,\"vs58\":917801,\"vs59\":917802,\"vs60\":917803,\"vs61\":917804,\"vs62\":917805,\"vs63\":917806,\"vs64\":917807,\"vs65\":917808,\"vs66\":917809,\"vs67\":917810,\"vs68\":917811,\"vs69\":917812,\"vs70\":917813,\"vs71\":917814,\"vs72\":917815,\"vs73\":917816,\"vs74\":917817,\"vs75\":917818,\"vs76\":917819,\"vs77\":917820,\"vs78\":917821,\"vs79\":917822,\"vs80\":917823,\"vs81\":917824,\"vs82\":917825,\"vs83\":917826,\"vs84\":917827,\"vs85\":917828,\"vs86\":917829,\"vs87\":917830,\"vs88\":917831,\"vs89\":917832,\"vs90\":917833,\"vs91\":917834,\"vs92\":917835,\"vs93\":917836,\"vs94\":917837,\"vs95\":917838,\"vs96\":917839,\"vs97\":917840,\"vs98\":917841,\"vs99\":917842,\"vs100\":917843,\"vs101\":917844,\"vs102\":917845,\"vs103\":917846,\"vs104\":917847,\"vs105\":917848,\"vs106\":917849,\"vs107\":917850,\"vs108\":917851,\"vs109\":917852,\"vs110\":917853,\"vs111\":917854,\"vs112\":917855,\"vs113\":917856,\"vs114\":917857,\"vs115\":917858,\"vs116\":917859,\"vs117\":917860,\"vs118\":917861,\"vs119\":917862,\"vs120\":917863,\"vs121\":917864,\"vs122\":917865,\"vs123\":917866,\"vs124\":917867,\"vs125\":917868,\"vs126\":917869,\"vs127\":917870,\"vs128\":917871,\"vs129\":917872,\"vs130\":917873,\"vs131\":917874,\"vs132\":917875,\"vs133\":917876,\"vs134\":917877,\"vs135\":917878,\"vs136\":917879,\"vs137\":917880,\"vs138\":917881,\"vs139\":917882,\"vs140\":917883,\"vs141\":917884,\"vs142\":917885,\"vs143\":917886,\"vs144\":917887,\"vs145\":917888,\"vs146\":917889,\"vs147\":917890,\"vs148\":917891,\"vs149\":917892,\"vs150\":917893,\"vs151\":917894,\"vs152\":917895,\"vs153\":917896,\"vs154\":917897,\"vs155\":917898,\"vs156\":917899,\"vs157\":917900,\"vs158\":917901,\"vs159\":917902,\"vs160\":917903,\"vs161\":917904,\"vs162\":917905,\"vs163\":917906,\"vs164\":917907,\"vs165\":917908,\"vs166\":917909,\"vs167\":917910,\"vs168\":917911,\"vs169\":917912,\"vs170\":917913,\"vs171\":917914,\"vs172\":917915,\"vs173\":917916,\"vs174\":917917,\"vs175\":917918,\"vs176\":917919,\"vs177\":917920,\"vs178\":917921,\"vs179\":917922,\"vs180\":917923,\"vs181\":917924,\"vs182\":917925,\"vs183\":917926,\"vs184\":917927,\"vs185\":917928,\"vs186\":917929,\"vs187\":917930,\"vs188\":917931,\"vs189\":917932,\"vs190\":917933,\"vs191\":917934,\"vs192\":917935,\"vs193\":917936,\"vs194\":917937,\"vs195\":917938,\"vs196\":917939,\"vs197\":917940,\"vs198\":917941,\"vs199\":917942,\"vs200\":917943,\"vs201\":917944,\"vs202\":917945,\"vs203\":917946,\"vs204\":917947,\"vs205\":917948,\"vs206\":917949,\"vs207\":917950,\"vs208\":917951,\"vs209\":917952,\"vs210\":917953,\"vs211\":917954,\"vs212\":917955,\"vs213\":917956,\"vs214\":917957,\"vs215\":917958,\"vs216\":917959,\"vs217\":917960,\"vs218\":917961,\"vs219\":917962,\"vs220\":917963,\"vs221\":917964,\"vs222\":917965,\"vs223\":917966,\"vs224\":917967,\"vs225\":917968,\"vs226\":917969,\"vs227\":917970,\"vs228\":917971,\"vs229\":917972,\"vs230\":917973,\"vs231\":917974,\"vs232\":917975,\"vs233\":917976,\"vs234\":917977,\"vs235\":917978,\"vs236\":917979,\"vs237\":917980,\"vs238\":917981,\"vs239\":917982,\"vs240\":917983,\"vs241\":917984,\"vs242\":917985,\"vs243\":917986,\"vs244\":917987,\"vs245\":917988,\"vs246\":917989,\"vs247\":917990,\"vs248\":917991,\"vs249\":917992,\"vs250\":917993,\"vs251\":917994,\"vs252\":917995,\"vs253\":917996,\"vs254\":917997,\"vs255\":917998,\"vs256\":917999}\n# }}}\n\n_ASCII_CONTROL_CHARS = {'a':7, 'b':8, 'f': 12, 'n': 10, 'r': 13, 't': 9, 'v': 11}\n_HEX_PAT = /^[a-fA-F0-9]/\n_NUM_PAT =  /^[0-9]/\n_GROUP_PAT = /<([^>]+)>/\n_NAME_PAT = /^[a-zA-Z ]/\n\nI = IGNORECASE = 2\nL = LOCALE = 4\nM = MULTILINE = 8\nD = DOTALL = 16\nU = UNICODE = 32\nX = VERBOSE = 64\nDEBUG = 128\nA = ASCII = 256\n\nsupports_unicode = RegExp.prototype.unicode is not undefined\n\n_RE_ESCAPE = /[-\\/\\\\^$*+?.()|[\\]{}]/g\n\n_re_cache_map = {}\n_re_cache_items = v'[]'\n\nerror = SyntaxError  # This is the error JS throws for invalid regexps\n\ndef _expand(groups, repl, group_name_map):\n    i = 0\n\n    def next():\n        nonlocal i\n        return v'repl[i++]'\n\n    def peek():\n        return repl[i]\n\n    def read_digits(count, pat, base, maxval, prefix):\n        ans = prefix or ''\n        greedy = count is Number.MAX_VALUE\n        while count > 0:\n            count -= 1\n            if not pat.test(peek()):\n                if greedy:\n                    break\n                return ans\n            ans += next()\n        nval = parseInt(ans, base)\n        if nval > maxval:\n            return ans\n        return nval\n\n    def read_escape_sequence():\n        nonlocal i\n        q = next()\n        if not q or q is '\\\\':\n            return '\\\\'\n        if '\"\\''.indexOf(q) is not -1:\n            return q\n        if _ASCII_CONTROL_CHARS.hasOwnProperty(q):\n            return String.fromCharCode(_ASCII_CONTROL_CHARS[q])\n        if '0' <= q <= '9':\n            ans = read_digits(Number.MAX_VALUE, _NUM_PAT, 10, Number.MAX_VALUE, q)\n            if type(ans) is 'number':\n                return groups[ans] or ''\n            return '\\\\' + ans\n        if q is 'g':\n            m = _GROUP_PAT.exec(repl[i:])\n            if m is not None:\n                i += m[0].length\n                gn = m[1]\n                if isNaN(parseInt(gn, 10)):\n                    if not Object.prototype.hasOwnProperty.call(group_name_map, gn):\n                        return ''\n                    gn = group_name_map[gn][-1]\n                return groups[gn] or ''\n        if q is 'x':\n            code = read_digits(2, _HEX_PAT, 16, 0x10FFFF)\n            if type(code) is 'number':\n                return String.fromCharCode(code)\n            return '\\\\x' + code\n        if q is 'u':\n            code = read_digits(4, _HEX_PAT, 16, 0x10FFFF)\n            if type(code) is 'number':\n                return String.fromCharCode(code)\n            return '\\\\u' + code\n        if q is 'U':\n            code = read_digits(8, _HEX_PAT, 16, 0x10FFFF)\n            if type(code) is 'number':\n                if code <= 0xFFFF:\n                    return String.fromCharCode(code)\n                code -= 0x10000\n                return String.fromCharCode(0xD800+(code>>10), 0xDC00+(code&0x3FF))\n            return '\\\\U' + code\n        if q is 'N' and peek() is '{':\n            next()\n            name = ''\n            while _NAME_PAT.test(peek()):\n                name += next()\n            if peek() is not '}':\n                return '\\\\N{' + name\n            next()\n            key = (name or '').toLowerCase()\n            if not name or not Object.prototype.hasOwnProperty.call(_ALIAS_MAP, key):\n                return '\\\\N{' + name + '}'\n            code = _ALIAS_MAP[key]\n            if code <= 0xFFFF:\n                return String.fromCharCode(code)\n            code -= 0x10000\n            return String.fromCharCode(0xD800+(code>>10), 0xDC00+(code&0x3FF))\n\n        return '\\\\' + q\n\n    ans = ch = ''\n    while (ch = next()):\n        if ch is '\\\\':\n            ans += read_escape_sequence()\n        else:\n            ans += ch\n    return ans\n\ndef transform_regex(source, flags):\n    pos = 0\n    previous_backslash = in_class = False\n    ans = ''\n    group_map = {}\n    flags = flags or 0\n    group_count = 0\n\n    while pos < source.length:\n        ch = v'source[pos++]'\n        if previous_backslash:\n            ans += '\\\\' + ch\n            previous_backslash = False\n            continue\n\n        if in_class:\n            if ch is ']':\n                in_class = False\n            ans += ch\n            continue\n\n        if ch is '\\\\':\n            previous_backslash = True\n            continue\n\n        if ch is '[':\n            in_class = True\n            if source[pos] is ']':  # in python the empty set is not allowed, instead []] is the same as [\\]]\n                pos += 1\n                ch = r'[\\]'\n        elif ch is '(':\n            if source[pos] is '?':\n                extension = source[pos + 1]\n                if extension is '#':\n                    close = source.indexOf(')', pos + 1)\n                    if close is -1:\n                        raise ValueError('Expecting a closing )')\n                    pos = close + 1\n                    continue\n                if 'aiLmsux'.indexOf(extension) is not -1:\n                    flag_map = {'a':ASCII, 'i':IGNORECASE, 'L':LOCALE, 'm':MULTILINE, 's':DOTALL, 'u':UNICODE, 'x':VERBOSE}\n                    close = source.indexOf(')', pos + 1)\n                    if close is -1:\n                        raise SyntaxError('Expecting a closing )')\n                    flgs = source[pos+1:close]\n                    for v'var i = 0; i < flgs.length; i++':\n                        q = flgs[i]  # noqa:undef\n                        if not flag_map.hasOwnProperty(q):\n                            raise SyntaxError('Invalid flag: ' + q)\n                        flags |= flag_map[q]\n                    pos = close + 1\n                    continue\n                if extension is '<':\n                    raise SyntaxError('Look behind assertions are not supported in JavaScript')\n                if extension is '(':\n                    raise SyntaxError('Group existence assertions are not supported in JavaScript')\n                if extension is 'P':\n                    pos += 2\n                    q = source[pos]\n                    if q is '<':\n                        close = source.indexOf('>', pos)\n                        if close is -1:\n                            raise SyntaxError('Named group not closed, expecting >')\n                        name = source[pos+1:close]\n                        if not Object.prototype.hasOwnProperty.call(group_map, name):\n                            group_map[name] = v'[]'\n                        group_map[name].push(v'++group_count')\n                        pos = close + 1\n                    elif q is '=':\n                        close = source.indexOf(')', pos)\n                        if close is -1:\n                            raise SyntaxError('Named group back-reference not closed, expecting a )')\n                        name = source[pos+1:close]\n                        if not isNaN(parseInt(name, 10)):\n                            ans += '\\\\' + name\n                        else:\n                            if not Object.prototype.hasOwnProperty.call(group_map, name):\n                                raise SyntaxError('Invalid back-reference. The named group: ' + name + ' has not yet been defined.')\n                            ans += '\\\\' + group_map[name][-1]\n                        pos = close + 1\n                        continue\n                    else:\n                        raise SyntaxError('Expecting < or = after (?P')\n            else:\n                group_count += 1\n        elif ch is '.' and (flags & DOTALL):\n            ans += r'[\\s\\S]'  # JavaScript has no DOTALL\n            continue\n\n        ans += ch\n\n    return ans, flags, group_map\n\nclass MatchObject:\n\n    def __init__(self, regex, match, pos, endpos):\n        self.re = regex\n        self.string = match.input\n        self._start_pos = match.index\n        self._groups = match\n        self.pos, self.endpos = pos, endpos\n\n    def _compute_extents(self):\n        # compute start/end for each group\n        match = self._groups\n        self._start = v'Array(match.length)'\n        self._end = v'Array(match.length)'\n        self._start[0] = self._start_pos\n        self._end[0] = self._start_pos + match[0].length\n        offset = self._start_pos\n        extent = match[0]\n        loc = 0\n        for v'var i = 1; i < match.length; i++':\n            g = match[i]\n            loc = extent.indexOf(g, loc)\n            if loc is -1:\n                self._start[i] = self._start[i-1]\n                self._end[i] = self._end[i-1]\n            else:\n                self._start[i] = offset + loc\n                loc += g.length\n                self._end[i] = offset + loc # noqa:undef\n\n    def groups(self, defval=None):\n        ans = v'[]'\n        for v'var i = 1; i < self._groups.length; i++':\n            val = self._groups[i]  # noqa:undef\n            if val is undefined:\n                val = defval\n            ans.push(val)\n        return ans\n\n    def _group_number(self, g):\n        if type(g) is 'number':\n            return g\n        if Object.prototype.hasOwnProperty.call(self.re.group_name_map, g):\n            return self.re.group_name_map[g][-1]\n        return g\n\n    def _group_val(self, q, defval):\n        val = undefined\n        if type(q) is 'number' and -1 < q < self._groups.length:\n            val = self._groups[q]\n        else:\n            if Object.prototype.hasOwnProperty.call(self.re.group_name_map, q):\n                val = self._groups[self.re.group_name_map[q][-1]]\n        if val is undefined:\n            val = defval\n        return val\n\n    def group(self):\n        if arguments.length is 0:\n            return self._groups[0]\n        ans = v'[]'\n        for v'var i = 0; i < arguments.length; i++':\n            q = arguments[i]  # noqa:undef\n            ans.push(self._group_val(q, None))\n        return ans[0] if ans.length is 1 else ans\n\n    def start(self, g):\n        if self._start is undefined:\n            self._compute_extents()\n        val = self._start[self._group_number(g or 0)]\n        if val is undefined:\n            val = -1\n        return val\n\n    def end(self, g):\n        if self._end is undefined:\n            self._compute_extents()\n        val = self._end[self._group_number(g or 0)]\n        if val is undefined:\n            val = -1\n        return val\n\n    def span(self, g):\n        return [self.start(g), self.end(g)]\n\n    def expand(self, repl):\n        return _expand(repl, this._groups, this.re.group_name_map)\n\n    def groupdict(self, defval=None):\n        gnm = self.re.group_name_map\n        names = Object.keys(gnm)\n        ans = {}\n        for v\"var i = 0; i < names.length; i++\":\n            name = names[i]  # noqa:undef\n            if Object.prototype.hasOwnProperty.call(gnm, name):\n                val = self._groups[gnm[name][-1]]\n                if val is undefined:\n                    val = defval\n                ans[name] = val\n        return ans\n\n    def captures(self, group_name):\n        ans = []\n        if not Object.prototype.hasOwnProperty.call(self.re.group_name_map, group_name):\n            return ans\n        groups = self.re.group_name_map[group_name]\n        for v'var i = 0; i < groups.length; i++':\n            val = self._groups[groups[i]]  # noqa:undef\n            if val is not undefined:\n                ans.push(val)\n        return ans\n\n    def capturesdict(self):\n        gnm = self.re.group_name_map\n        names = Object.keys(gnm)\n        ans = {}\n        for v'var i = 0; i < names.length; i++':\n            name = names[i]  # noqa:undef\n            ans[name] = self.captures(name)\n        return ans\n\nclass RegexObject:\n\n    def __init__(self, pattern, flags):\n        self.pattern = pattern.source if isinstance(pattern, RegExp) else pattern\n        self.js_pattern, self.flags, self.group_name_map = transform_regex(self.pattern, flags)\n\n        modifiers = ''\n        if self.flags & IGNORECASE: modifiers += 'i'\n        if self.flags & MULTILINE: modifiers += 'm'\n        if not (self.flags & ASCII) and supports_unicode:\n            modifiers += 'u'\n        self._modifiers = modifiers + 'g'\n        self._pattern = RegExp(self.js_pattern, self._modifiers)\n\n    def _do_search(self, pat, string, pos, endpos):\n        pat.lastIndex = 0\n        if endpos is not None:\n            string = string[:endpos]\n        while True:\n            n = pat.exec(string)\n            if n is None:\n                return None\n            if n.index >= pos:\n                return MatchObject(self, n, pos, endpos)\n\n    def search(self, string, pos=0, endpos=None):\n        return self._do_search(self._pattern, string, pos, endpos)\n\n    def match(self, string, pos=0, endpos=None):\n        return self._do_search(RegExp('^' + self.js_pattern, self._modifiers), string, pos, endpos)\n\n    def split(self, string, maxsplit=0):\n        self._pattern.lastIndex = 0\n        return string.split(self._pattern, maxsplit or undefined)\n\n    def findall(self, string):\n        self._pattern.lastIndex = 0\n        return _$rapyd$_list_decorate(string.match(self._pattern) or v'[]')\n\n    def finditer(self, string):\n        pat = RegExp(this._pattern.source, this._modifiers)  # We have to do this since lastIndex is mutable\n        return {\n            '_string':string,\n            '_r': pat,\n            '_self': self,\n            _$rapyd$_iterator_symbol: def (): return this;,\n            'next': def ():\n                m = this._r.exec(this._string)\n                if m is None:\n                    return {'done':True}\n                return {'done':False, 'value':MatchObject(this._self, m, 0, None)}\n        }\n\n    def subn(self, repl, string, count=0):\n        expand = _expand\n        if type(repl) is 'function':\n            expand = def(m, repl, gnm): return '' + repl(MatchObject(self, m, 0, None))\n        this._pattern.lastIndex = 0\n        num = 0\n        matches = v'[]'\n\n        while count < 1 or num < count:\n            m = this._pattern.exec(string)\n            if m is None:\n                break\n            matches.push(m)\n            num += 1\n\n        for v'var i = matches.length - 1; i > -1; i--':\n            m = matches[i]  # noqa:undef\n            start = m.index\n            end = start + m[0].length\n            string = string[:start] + expand(m, repl, self.group_name_map) + string[end:]\n        return string, matches.length\n\n    def sub(self, repl, string, count=0):\n        return self.subn(repl, string, count)[0]\n\ndef _get_from_cache(pattern, flags):\n    if isinstance(pattern, RegExp):\n        pattern = pattern.source\n    key = JSON.stringify(v'[pattern, flags]')\n    if Object.prototype.hasOwnProperty.call(_re_cache_map, key):\n        return _re_cache_map[key]\n    if _re_cache_items.length >= 100:\n        v'delete _re_cache_map[_re_cache_items.shift()]'\n    ans = RegexObject(pattern, flags)\n    _re_cache_map[key] = ans\n    _re_cache_items.push(key)\n    return ans\n\ndef compile(pattern, flags=0):\n    return _get_from_cache(pattern, flags)\n\ndef search(pattern, string, flags=0):\n    return _get_from_cache(pattern, flags).search(string)\n\ndef match(pattern, string, flags=0):\n    return _get_from_cache(pattern, flags).match(string)\n\ndef split(pattern, string, maxsplit=0, flags=0):\n    return _get_from_cache(pattern, flags).split(string)\n\ndef findall(pattern, string, flags=0):\n    return _get_from_cache(pattern, flags).findall(string)\n\ndef finditer(pattern, string, flags=0):\n    return _get_from_cache(pattern, flags).finditer(string)\n\ndef sub(pattern, repl, string, count=0, flags=0):\n    return _get_from_cache(pattern, flags).sub(repl, string, count)\n\ndef subn(pattern, repl, string, count=0, flags=0):\n    return _get_from_cache(pattern, flags).subn(repl, string, count)\n\ndef escape(string):\n    return string.replace(_RE_ESCAPE, '\\\\$&')\n\ndef purge():\n    nonlocal _re_cache_map, _re_cache_items\n    _re_cache_map = {}\n    _re_cache_items = v'[]'\n"};

// End embedded modules }}}

/* vim:fileencoding=utf-8
 * 
 * Copyright (C) 2016 Kovid Goyal <kovid at kovidgoyal.net>
 *
 * Distributed under terms of the BSD license
 */

var namespace = {}, jsSHA = {};

var write_cache = {};

var builtin_modules = {
    'crypto' : {
        'createHash': function create_hash() {
            var ans = new jsSHA.jsSHA('SHA-1', 'TEXT');
            ans.digest = function hex_digest() { return ans.getHash('HEX'); };
            return ans;
        },
    },

    'vm': {
        'createContext': function create_context(ctx) {
            var iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            document.body.appendChild(iframe);
            var win = iframe.contentWindow;
            if(!ctx) ctx = {};
            if (!ctx.sha1sum) ctx.sha1sum = sha1sum;
            if (!ctx.require) ctx.require = require;
            Object.keys(ctx).forEach(function(k) { win[k] = ctx[k]; });
            return win;
        },

        'runInContext': function run_in_context(code, ctx) {
            return ctx.eval(code);
        },

        'runInThisContext': eval,
    },
    'path': {
        'join': function path_join() { return Array.prototype.slice.call(arguments).join('/'); },
        'dirname': function path_dirname(path) {
            return path.split('/').slice(0, -1).join('/');
        },
    },
    'inspect': function inspect(x) { return x.toString(); },

    'fs': {
        'readFileSync': function readfile(name) {
            var data = namespace.file_data[name];
            if (data) return data;
            data = write_cache[name];
            if (data) return data;
            var err = Error();
            err.code = 'ENOENT';
            throw err;
        },

        'writeFileSync': function writefile(name, data) {
            write_cache[name] = data;
        },

    },
};

function require(name) {
    return builtin_modules[name] || {};
}

// Embedded sha1 implementation {{{
(function() {
/*
 A JavaScript implementation of the SHA family of hashes, as
 defined in FIPS PUB 180-2 as well as the corresponding HMAC implementation
 as defined in FIPS PUB 198a

 Copyright Brian Turek 2008-2015
 Distributed under the BSD License
 See http://caligatio.github.com/jsSHA/ for more information

 Several functions taken from Paul Johnston
*/
'use strict';(function(E){function t(e,a,c){var g=0,b=[],d=0,f,k,l,h,m,w,n,q=!1,r=!1,p=[],t=[],v,u=!1;c=c||{};f=c.encoding||"UTF8";v=c.numRounds||1;l=y(a,f);if(v!==parseInt(v,10)||1>v)throw Error("numRounds must a integer >= 1");if("SHA-1"===e)m=512,w=z,n=F,h=160;else throw Error("Chosen SHA variant is not supported");k=x(e);this.setHMACKey=function(a,b,d){var c;if(!0===r)throw Error("HMAC key already set");if(!0===q)throw Error("Cannot set HMAC key after finalizing hash");if(!0===u)throw Error("Cannot set HMAC key after calling update");
f=(d||{}).encoding||"UTF8";b=y(b,f)(a);a=b.binLen;b=b.value;c=m>>>3;d=c/4-1;if(c<a/8){for(b=n(b,a,0,x(e));b.length<=d;)b.push(0);b[d]&=4294967040}else if(c>a/8){for(;b.length<=d;)b.push(0);b[d]&=4294967040}for(a=0;a<=d;a+=1)p[a]=b[a]^909522486,t[a]=b[a]^1549556828;k=w(p,k);g=m;r=!0};this.update=function(a){var e,c,f,h=0,n=m>>>5;e=l(a,b,d);a=e.binLen;c=e.value;e=a>>>5;for(f=0;f<e;f+=n)h+m<=a&&(k=w(c.slice(f,f+n),k),h+=m);g+=h;b=c.slice(h>>>5);d=a%m;u=!0};this.getHash=function(a,c){var f,l,m;if(!0===
r)throw Error("Cannot call getHash after setting HMAC key");m=A(c);switch(a){case "HEX":f=function(a){return B(a,m)};break;case "B64":f=function(a){return C(a,m)};break;case "BYTES":f=D;break;default:throw Error("format must be HEX, B64, or BYTES");}if(!1===q)for(k=n(b,d,g,k),l=1;l<v;l+=1)k=n(k,h,0,x(e));q=!0;return f(k)};this.getHMAC=function(a,c){var f,l,p;if(!1===r)throw Error("Cannot call getHMAC without first setting HMAC key");p=A(c);switch(a){case "HEX":f=function(a){return B(a,p)};break;case "B64":f=
function(a){return C(a,p)};break;case "BYTES":f=D;break;default:throw Error("outputFormat must be HEX, B64, or BYTES");}!1===q&&(l=n(b,d,g,k),k=w(t,x(e)),k=n(l,h,m,k));q=!0;return f(k)}}function G(e,a,c){var g=e.length,b,d,f,k,l;a=a||[0];c=c||0;l=c>>>3;if(0!==g%2)throw Error("String of HEX type must be in byte increments");for(b=0;b<g;b+=2){d=parseInt(e.substr(b,2),16);if(isNaN(d))throw Error("String of HEX type contains invalid characters");k=(b>>>1)+l;for(f=k>>>2;a.length<=f;)a.push(0);a[f]|=d<<
8*(3-k%4)}return{value:a,binLen:4*g+c}}function H(e,a,c){var g=[],b,d,f,k,g=a||[0];c=c||0;d=c>>>3;for(b=0;b<e.length;b+=1)a=e.charCodeAt(b),k=b+d,f=k>>>2,g.length<=f&&g.push(0),g[f]|=a<<8*(3-k%4);return{value:g,binLen:8*e.length+c}}function I(e,a,c){var g=[],b=0,d,f,k,l,h,m,g=a||[0];c=c||0;a=c>>>3;if(-1===e.search(/^[a-zA-Z0-9=+\/]+$/))throw Error("Invalid character in base-64 string");f=e.indexOf("=");e=e.replace(/\=/g,"");if(-1!==f&&f<e.length)throw Error("Invalid '=' found in base-64 string");
for(f=0;f<e.length;f+=4){h=e.substr(f,4);for(k=l=0;k<h.length;k+=1)d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(h[k]),l|=d<<18-6*k;for(k=0;k<h.length-1;k+=1){m=b+a;for(d=m>>>2;g.length<=d;)g.push(0);g[d]|=(l>>>16-8*k&255)<<8*(3-m%4);b+=1}}return{value:g,binLen:8*b+c}}function B(e,a){var c="",g=4*e.length,b,d;for(b=0;b<g;b+=1)d=e[b>>>2]>>>8*(3-b%4),c+="0123456789abcdef".charAt(d>>>4&15)+"0123456789abcdef".charAt(d&15);return a.outputUpper?c.toUpperCase():c}function C(e,
a){var c="",g=4*e.length,b,d,f;for(b=0;b<g;b+=3)for(f=b+1>>>2,d=e.length<=f?0:e[f],f=b+2>>>2,f=e.length<=f?0:e[f],f=(e[b>>>2]>>>8*(3-b%4)&255)<<16|(d>>>8*(3-(b+1)%4)&255)<<8|f>>>8*(3-(b+2)%4)&255,d=0;4>d;d+=1)8*b+6*d<=32*e.length?c+="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(f>>>6*(3-d)&63):c+=a.b64Pad;return c}function D(e){var a="",c=4*e.length,g,b;for(g=0;g<c;g+=1)b=e[g>>>2]>>>8*(3-g%4)&255,a+=String.fromCharCode(b);return a}function A(e){var a={outputUpper:!1,b64Pad:"="};
e=e||{};a.outputUpper=e.outputUpper||!1;!0===e.hasOwnProperty("b64Pad")&&(a.b64Pad=e.b64Pad);if("boolean"!==typeof a.outputUpper)throw Error("Invalid outputUpper formatting option");if("string"!==typeof a.b64Pad)throw Error("Invalid b64Pad formatting option");return a}function y(e,a){var c;switch(a){case "UTF8":case "UTF16BE":case "UTF16LE":break;default:throw Error("encoding must be UTF8, UTF16BE, or UTF16LE");}switch(e){case "HEX":c=G;break;case "TEXT":c=function(e,b,d){var f=[],c=[],l=0,h,m,p,
n,q,f=b||[0];b=d||0;p=b>>>3;if("UTF8"===a)for(h=0;h<e.length;h+=1)for(d=e.charCodeAt(h),c=[],128>d?c.push(d):2048>d?(c.push(192|d>>>6),c.push(128|d&63)):55296>d||57344<=d?c.push(224|d>>>12,128|d>>>6&63,128|d&63):(h+=1,d=65536+((d&1023)<<10|e.charCodeAt(h)&1023),c.push(240|d>>>18,128|d>>>12&63,128|d>>>6&63,128|d&63)),m=0;m<c.length;m+=1){q=l+p;for(n=q>>>2;f.length<=n;)f.push(0);f[n]|=c[m]<<8*(3-q%4);l+=1}else if("UTF16BE"===a||"UTF16LE"===a)for(h=0;h<e.length;h+=1){d=e.charCodeAt(h);"UTF16LE"===a&&
(m=d&255,d=m<<8|d>>>8);q=l+p;for(n=q>>>2;f.length<=n;)f.push(0);f[n]|=d<<8*(2-q%4);l+=2}return{value:f,binLen:8*l+b}};break;case "B64":c=I;break;case "BYTES":c=H;break;default:throw Error("format must be HEX, TEXT, B64, or BYTES");}return c}function r(e,a){return e<<a|e>>>32-a}function p(e,a){var c=(e&65535)+(a&65535);return((e>>>16)+(a>>>16)+(c>>>16)&65535)<<16|c&65535}function u(e,a,c,g,b){var d=(e&65535)+(a&65535)+(c&65535)+(g&65535)+(b&65535);return((e>>>16)+(a>>>16)+(c>>>16)+(g>>>16)+(b>>>16)+
(d>>>16)&65535)<<16|d&65535}function x(e){if("SHA-1"===e)e=[1732584193,4023233417,2562383102,271733878,3285377520];else throw Error("No SHA variants supported");return e}function z(e,a){var c=[],g,b,d,f,k,l,h;g=a[0];b=a[1];d=a[2];f=a[3];k=a[4];for(h=0;80>h;h+=1)c[h]=16>h?e[h]:r(c[h-3]^c[h-8]^c[h-14]^c[h-16],1),l=20>h?u(r(g,5),b&d^~b&f,k,1518500249,c[h]):40>h?u(r(g,5),b^d^f,k,1859775393,c[h]):60>h?u(r(g,5),b&d^b&f^d&f,k,2400959708,c[h]):u(r(g,5),b^d^f,k,3395469782,c[h]),k=f,f=d,d=r(b,30),b=g,g=l;a[0]=
p(g,a[0]);a[1]=p(b,a[1]);a[2]=p(d,a[2]);a[3]=p(f,a[3]);a[4]=p(k,a[4]);return a}function F(e,a,c,g){var b;for(b=(a+65>>>9<<4)+15;e.length<=b;)e.push(0);e[a>>>5]|=128<<24-a%32;e[b]=a+c;c=e.length;for(a=0;a<c;a+=16)g=z(e.slice(a,a+16),g);return g}"function"===typeof define&&define.amd?define(function(){return t}):"undefined"!==typeof exports?"undefined"!==typeof module&&module.exports?module.exports=exports=t:exports=t:E.jsSHA=t})(this);
}).call(jsSHA);
// End embedded sha1 implementation }}}

var exports = namespace;
/* 
 * Copyright (C) 2015 Kovid Goyal <kovid at kovidgoyal.net>
 *
 * Distributed under terms of the BSD license
 */

var vm = require('vm');
var native_require = require;

function normalize_array(parts, allowAboveRoot) {
  var res = [];
  for (var i = 0; i < parts.length; i++) {
    var p = parts[i];

    // ignore empty parts
    if (!p || p === '.')
      continue;

    if (p === '..') {
      if (res.length && res[res.length - 1] !== '..') {
        res.pop();
      } else if (allowAboveRoot) {
        res.push('..');
      }
    } else {
      res.push(p);
    }
  }

  return res;
}

function normalize(path) {
    var is_abs = path && path[0] === '/';
    var trailing_slash = path && path[path.length - 1] === '/';
    path = normalize_array(path.split('/'), !is_abs).join('/');

    if (!path && !is_abs) {
        path = '.';
    }
    if (path && trailing_slash) {
        path += '/';
    }

    return (is_abs ? '/' : '') + path;
}

function dirname(path) {
    var idx = path.lastIndexOf('/');
    if (idx != -1) path = path.slice(0, idx);
    else path = '';
    return path;
}

function basename(path) {
    var idx = path.lastIndexOf('/');
    if (idx != -1) path = path.slice(idx + 1);
    return path;
}

var cache = {};

function load(filepath) {
    var cached = cache[filepath];
    if (cached) return cached.exports;
    var module = {'id':filepath, 'exports':{}};
    cache[filepath] = module;

    var content = data[filepath];
    if (Array.isArray(content)) content = data[content[0]];
    if (!content) throw 'Failed to load: ' + JSON.stringify(filepath);

    if (filepath.slice(-5) == '.json') { module.exports = JSON.parse(content); return module.exports; }

    var base = dirname(filepath);
    function mrequire(x) {
        return vrequire(x, base);
    }
    content = content.replace(/^\#\!.*/, '');
    var wrapped = '(function(exports, require, module, __filename, __dirname, create_rapydscript_compiler) { ';
    wrapped += content + '\n;})';
    try {
        vm.runInThisContext(wrapped, {'filename': filepath})(module.exports, mrequire, module, filepath, dirname(filepath), create_compiler);
    } catch (e) {
        console.error(e);
        delete cache[filepath];
        throw e;
    }
    return module.exports;
}

function has(x, y) { return Object.prototype.hasOwnProperty.call(x, y); }

function try_files(candidate) {
    if (has(data, candidate)) return candidate;
    if (has(data, candidate + '.js')) return candidate + '.js';
    if (has(data, candidate + '.json')) return candidate + '.json';
    return null;
}

function find_in_modules_dir(name, base) {
    var candidate = normalize(base + (base ? '/':'') + 'node_modules/' + name);
    var q = try_files(candidate);
    if (q) return q;

    var pj = candidate + '/package.json';
    if (has(data, pj)) {
        var ans = normalize(candidate + '/' + JSON.parse(data[pj]).main);
        if (has(data, ans)) return ans;
    }
    var index = candidate + '/index.js';
    if (has(data, index)) return index;

    var p = dirname(base);
    if (p) return find_in_modules_dir(name, p);
    return null;
}

function find_module(name, base) {
    if (name[0] == '/') throw 'Cannot find absolute module: ' + name;
    if (name.slice(0, 2) == './' || name.slice(0, 3) == '../') {
        var candidate = normalize((base ? base + '/' : base) + name);
        return try_files(candidate);
    }
    var q = try_files(name);
    if (q) return q;
    return find_in_modules_dir(name, base);
}

function vrequire(name, base) {
    var exports = {};
    var modpath = '';
    base = base || '';
    // console.log('vrequire', name, base);
    if (!name) throw new Error('Cannot load a module from an empty name');

    modpath = find_module(name, base);
    if (!modpath && name && './'.indexOf(name[0]) === -1) {
            try {
                return native_require(name);
            } catch (e) {}
        }

    if (!modpath) throw new Error("Failed to find module: " + JSON.stringify(name) + " with base: " + JSON.stringify(base));
    return load(modpath);
}

var UglifyJS = null, regenerator = null;
var crypto = null, fs = require('fs');

function uglify(x) {
    if (!UglifyJS) UglifyJS = vrequire("uglify-js");
    return UglifyJS.minify(ans, {fromString:true}).code;
}

function regenerate(code, beautify) {
    var orig = fs.readFileSync;
    fs.readFileSync = function(name) { 
        if (!has(data, name)) {
            throw {message: "Failed to readfile from data: " + name};
        }
        return data[name]; 
    };
    if (!regenerator) regenerator = vrequire('regenerator');
    var ans;
    if (code) {
        try {
            ans = regenerator.compile(code).code;
        } catch (e) {
            console.error('regenerator failed for code: ' + code + 'with error stack:\n' + e.stack);
            throw e;
        }
        if (!beautify) ans = uglify(ans);
    } else {
        // Return the runtime
        ans = regenerator.compile('', {includeRuntime:true}).code;
        ans = ans.slice(ans.indexOf('!'), ans.lastIndexOf(')(')) + ')';
        if (!beautify) ans = uglify(ans+'();').slice(0, -3);
    }
    fs.readFileSync = orig;
    return ans;
}

if (typeof this != 'object' || typeof this.sha1sum !== 'function') {
    var sha1sum = function (data) { 
        if (!crypto) crypto = require('crypto');
        var h = crypto.createHash('sha1');
        h.update(data);
        return h.digest('hex');
    };
} else var sha1sum = this.sha1sum;

function create_compiler() {
    var compilerjs = data['compiler.js'];
    var module = {'id':'compiler', 'exports':{}};
    var wrapped = '(function(module, exports, readfile, writefile, sha1sum, regenerate) {' + data['compiler.js'] + ';\n})';
    vm.runInThisContext(wrapped, {'filename': 'compiler.js'})(module, module.exports, fs.readFileSync, fs.writeFileSync, sha1sum, regenerate);
    return module.exports;
}

var RapydScript = null;

function compile(code, filename, options) {
    if (!RapydScript) RapydScript = create_compiler();
    options = options || {};
    var ast = RapydScript.parse(code, {
        filename: filename || '<eval>',
        auto_bind: !!options.auto_bind,
        basedir: options.basedir || dirname(filename || ''),
        libdir: options.libdir,
    });
    var out_ops = {
        beautify: (options.beautify === undefined ? true : options.beautify),
        private_scope: !options.bare,
        auto_bind: !!options.auto_bind,
        omit_baselib: !!options.omit_baselib,
        js_version: options.js_version || 5,
    };
    if (!out_ops.omit_baselib) out_ops.baselib = data['baselib-' + (out_ops.beautify ? 'pretty' : 'ugly') + '.js'];
    var out = RapydScript.OutputStream(out_ops);
    ast.print(out);
    return out.get();
}

function create_embedded_compiler(runjs) {
    var c = vrequire('tools/embedded_compiler.js');
    return c(create_compiler(), data['baselib-plain-pretty.js'], runjs);
}

function web_repl() {
    var repl = vrequire('tools/web_repl.js');
    return repl(create_compiler(), data['baselib-plain-pretty.js']);
}

function init_repl(options) {
    var repl = vrequire('tools/repl.js');
    options.baselib = data['baselib-plain-pretty.js'];
    return repl(options);
}

function gettext_parse(catalog, code, filename) {
    g = vrequire('tools/gettext.js');
    g.gettext(catalog, code, filename);
}

function gettext_output(catalog, options, write) {
    g = vrequire('tools/gettext.js');
    g.write_output(catalog, options, write);
}

function msgfmt(data, options) {
    m = vrequire('tools/msgfmt.js');
    return m.build(data, options);
}

function completer(compiler, options) {
    m = vrequire('tools/completer.js');
    return m(compiler, options);
}

if (typeof exports === 'object') {
    exports.compile = compile;
    exports.create_embedded_compiler = create_embedded_compiler;
    exports.web_repl = web_repl;
    exports.init_repl = init_repl;
    exports.gettext_parse = gettext_parse;
    exports.gettext_output = gettext_output;
    exports.msgfmt = msgfmt;
    exports.rs_version = rs_version;
    exports.file_data = data;
    exports.completer = completer;
    if (typeof rs_commit_sha === 'string') exports.rs_commit_sha = rs_commit_sha;
}
external_namespace.RapydScript = namespace;
})(this)