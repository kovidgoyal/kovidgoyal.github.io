// vim:fileencoding=utf-8
(function(external_namespace) {
"use strict;"
var rs_version = "0.5.2";
var rs_commit_sha = "9e47cd0fedcc1760e21d8d28396a4fb053abdea3\n";

// Embedded modules {{{
var data = {"compiler.js":"(function(){\n    \"use strict\";\n    var _$rapyd$_iterator_symbol = (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") ? Symbol.iterator : \"iterator-Symbol-5d0927e5554349048cf0e3762a228256\";\n    var _$rapyd$_kwargs_symbol = (typeof Symbol === \"function\") ? Symbol(\"kwargs-object\") : \"kwargs-object-Symbol-5d0927e5554349048cf0e3762a228256\";\n    var _$rapyd$_cond_temp, _$rapyd$_expr_temp;\n    var _$rapyd$_object_counter = 0;\nvar _$rapyd$_len;\nfunction _$rapyd$_bool(val) {\n    return !!val;\n};\n\n_$rapyd$_bool.__argnames__ = [\"val\"];\n\nfunction _$rapyd$_bind(fn, thisArg) {\n    var ret;\n    if (fn.orig) {\n        fn = fn.orig;\n    }\n    if (thisArg === false) {\n        return fn;\n    }\n    ret = (function() {\n        var _$rapyd$_anonfunc = function () {\n            return fn.apply(thisArg, arguments);\n        };\n        return _$rapyd$_anonfunc;\n    })();\n    ret.orig = fn;\n    return ret;\n};\n\n_$rapyd$_bind.__argnames__ = [\"fn\", \"thisArg\"];\n\nfunction _$rapyd$_rebind_all(thisArg, rebind) {\n    if (typeof rebind === \"undefined\") {\n        rebind = true;\n    }\n    for (var p in thisArg) {\n        if (thisArg[p] && thisArg[p].orig) {\n            if (rebind) {\n                thisArg[p] = _$rapyd$_bind(thisArg[p], thisArg);\n            } else {\n                thisArg[p] = thisArg[p].orig;\n            }\n        }\n    }\n};\n\n_$rapyd$_rebind_all.__argnames__ = [\"thisArg\", \"rebind\"];\n\nfunction _$rapyd$_eslice(arr, step, start, end) {\n    var isString;\n    arr = arr.slice(0);\n    if (typeof arr === \"string\" || arr instanceof String) {\n        isString = true;\n        arr = arr.split(\"\");\n    }\n    if (step < 0) {\n        step = -step;\n        arr.reverse();\n        if (typeof start !== \"undefined\") {\n            start = arr.length - start - 1;\n        }\n        if (typeof end !== \"undefined\") {\n            end = arr.length - end - 1;\n        }\n    }\n    if (typeof start === \"undefined\") {\n        start = 0;\n    }\n    if (typeof end === \"undefined\") {\n        end = arr.length;\n    }\n    arr = arr.slice(start, end).filter((function() {\n        var _$rapyd$_anonfunc = function (e, i) {\n            return i % step === 0;\n        };\n\n        _$rapyd$_anonfunc.__argnames__ = [\"e\", \"i\"];\n        return _$rapyd$_anonfunc;\n    })());\n    return (isString) ? arr.join(\"\") : arr;\n};\n\n_$rapyd$_eslice.__argnames__ = [\"arr\", \"step\", \"start\", \"end\"];\n\nfunction _$rapyd$_mixin(target, source, overwrite) {\n    for (var i in source) {\n        if (source.hasOwnProperty(i) && overwrite || typeof target[i] === \"undefined\") {\n            target[i] = source[i];\n        }\n    }\n};\n\n_$rapyd$_mixin.__argnames__ = [\"target\", \"source\", \"overwrite\"];\n\nfunction _$rapyd$_print() {\n    var parts;\n    if (typeof console === \"object\") {\n        parts = [];\n        for (var i = 0; i < arguments.length; i++) {\n            parts.push(_$rapyd$_str(arguments[i]));\n        }\n        console.log(parts.join(\" \"));\n    }\n};\n\nfunction _$rapyd$_int(val, base) {\n    var ans;\n    ans = parseInt(val, base || 10);\n    if (isNaN(ans)) {\n        throw new ValueError(\"Invalid literal for int with base \" + (base || 10) + \": \" + val);\n    }\n    return ans;\n};\n\n_$rapyd$_int.__argnames__ = [\"val\", \"base\"];\n\nfunction _$rapyd$_float() {\n    var ans;\n    ans = parseFloat.apply(null, arguments);\n    if (isNaN(ans)) {\n        throw new ValueError(\"Could not convert string to float: \" + arguments[0]);\n    }\n    return ans;\n};\n\nfunction _$rapyd$_arraylike_creator() {\n    var names;\n    names = \"Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array\".split(\" \");\n    if (typeof HTMLCollection === \"function\") {\n        names = names.concat(\"HTMLCollection NodeList NamedNodeMap\".split(\" \"));\n    }\n    return (function() {\n        var _$rapyd$_anonfunc = function (x) {\n            if (Array.isArray(x) || typeof x === \"string\" || names.indexOf(Object.prototype.toString.call(x).slice(8, -1)) > -1) {\n                return true;\n            }\n            return false;\n        };\n\n        _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n        return _$rapyd$_anonfunc;\n    })();\n};\n\nfunction options_object(f) {\n    return (function() {\n        var _$rapyd$_anonfunc = function () {\n            if (typeof arguments[arguments.length - 1] === \"object\") {\n                arguments[arguments.length - 1][_$rapyd$_kwargs_symbol] = true;\n            }\n            return f.apply(this, arguments);\n        };\n        return _$rapyd$_anonfunc;\n    })();\n};\n\noptions_object.__argnames__ = [\"f\"];\n\nfunction _$rapyd$_id(x) {\n    return x._$rapyd$_object_id;\n};\n\n_$rapyd$_id.__argnames__ = [\"x\"];\n\nfunction _$rapyd$_dir(item) {\n    var arr;\n    arr = _$rapyd$_list_decorate([]);\n    for (var i in item) {\n        arr.push(i);\n    }\n    return arr;\n};\n\n_$rapyd$_dir.__argnames__ = [\"item\"];\n\nfunction _$rapyd$_ord(x) {\n    var ans, second;\n    ans = x.charCodeAt(0);\n    if (55296 <= ans && ans <= 56319) {\n        second = x.charCodeAt(1);\n        if (56320 <= second && second <= 57343) {\n            return (ans - 55296) * 1024 + second - 56320 + 65536;\n        }\n        throw new TypeError(\"string is missing the low surrogate char\");\n    }\n    return ans;\n};\n\n_$rapyd$_ord.__argnames__ = [\"x\"];\n\nfunction _$rapyd$_chr(code) {\n    if (code <= 65535) {\n        return String.fromCharCode(code);\n    }\n    code -= 65536;\n    return String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n};\n\n_$rapyd$_chr.__argnames__ = [\"code\"];\n\nfunction _$rapyd$_callable(x) {\n    return typeof x === \"function\";\n};\n\n_$rapyd$_callable.__argnames__ = [\"x\"];\n\nfunction _$rapyd$_bin(x) {\n    var ans;\n    if (typeof x !== \"number\" || x % 1 !== 0) {\n        throw new TypeError(\"integer required\");\n    }\n    ans = x.toString(2);\n    if (ans[0] === \"-\") {\n        ans = \"-\" + \"0b\" + ans.slice(1);\n    } else {\n        ans = \"0b\" + ans;\n    }\n    return ans;\n};\n\n_$rapyd$_bin.__argnames__ = [\"x\"];\n\nfunction _$rapyd$_hex(x) {\n    var ans;\n    if (typeof x !== \"number\" || x % 1 !== 0) {\n        throw new TypeError(\"integer required\");\n    }\n    ans = x.toString(16);\n    if (ans[0] === \"-\") {\n        ans = \"-\" + \"0x\" + ans.slice(1);\n    } else {\n        ans = \"0x\" + ans;\n    }\n    return ans;\n};\n\n_$rapyd$_hex.__argnames__ = [\"x\"];\n\nfunction _$rapyd$_enumerate(iterable) {\n    var ans, iterator;\n    if (_$rapyd$_arraylike(iterable)) {\n        ans = {\n            \"_i\": -1,\n            \"next\": (function() {\n                var _$rapyd$_anonfunc = function () {\n                    this._i += 1;\n                    if (this._i < iterable.length) {\n                        return {\n                            \"done\": false,\n                            \"value\": _$rapyd$_list_decorate([ this._i, iterable[this._i] ])\n                        };\n                    }\n                    return {\n                        \"done\": true\n                    };\n                };\n                return _$rapyd$_anonfunc;\n            })()\n        };\n        ans[_$rapyd$_iterator_symbol] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this;\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        return ans;\n    }\n    if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n        ans = {\n            \"_iterator\": iterator,\n            \"_i\": -1,\n            \"next\": (function() {\n                var _$rapyd$_anonfunc = function () {\n                    var r;\n                    r = this._iterator.next();\n                    if (r.done) {\n                        return {\n                            \"done\": true\n                        };\n                    }\n                    this._i += 1;\n                    return {\n                        \"done\": false,\n                        \"value\": _$rapyd$_list_decorate([ this._i, r.value ])\n                    };\n                };\n                return _$rapyd$_anonfunc;\n            })()\n        };\n        ans[_$rapyd$_iterator_symbol] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this;\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        return ans;\n    }\n    return _$rapyd$_enumerate(Object.keys(iterable));\n};\n\n_$rapyd$_enumerate.__argnames__ = [\"iterable\"];\n\nfunction _$rapyd$_reversed(iterable) {\n    var ans;\n    if (_$rapyd$_arraylike(iterable)) {\n        ans = {\n            \"_i\": iterable.length,\n            \"next\": (function() {\n                var _$rapyd$_anonfunc = function () {\n                    this._i -= 1;\n                    if (this._i > -1) {\n                        return {\n                            \"done\": false,\n                            \"value\": iterable[this._i]\n                        };\n                    }\n                    return {\n                        \"done\": true\n                    };\n                };\n                return _$rapyd$_anonfunc;\n            })()\n        };\n        ans[_$rapyd$_iterator_symbol] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this;\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        return ans;\n    }\n    throw new TypeError(\"reversed() can only be called on arrays or strings\");\n};\n\n_$rapyd$_reversed.__argnames__ = [\"iterable\"];\n\nfunction _$rapyd$_iter(iterable) {\n    var ans;\n    if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n        return (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n    }\n    if (_$rapyd$_arraylike(iterable)) {\n        ans = {\n            \"_i\": -1,\n            \"next\": (function() {\n                var _$rapyd$_anonfunc = function () {\n                    this._i += 1;\n                    if (this._i < iterable.length) {\n                        return {\n                            \"done\": false,\n                            \"value\": iterable[this._i]\n                        };\n                    }\n                    return {\n                        \"done\": true\n                    };\n                };\n                return _$rapyd$_anonfunc;\n            })()\n        };\n        ans[_$rapyd$_iterator_symbol] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this;\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        return ans;\n    }\n    return _$rapyd$_iter(Object.keys(iterable));\n};\n\n_$rapyd$_iter.__argnames__ = [\"iterable\"];\n\nfunction _$rapyd$_range(start, stop, step) {\n    var length;\n    if (arguments.length <= 1) {\n        stop = start || 0;\n        start = 0;\n    }\n    step = arguments[2] || 1;\n    length = Math.max(Math.ceil((stop - start) / step), 0);\n    return (function(){\n        var _$rapyd$_d = {};\n        _$rapyd$_d[_$rapyd$_iterator_symbol] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this;\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        _$rapyd$_d[\"_i\"] = start - step;\n        _$rapyd$_d[\"_idx\"] = -1;\n        _$rapyd$_d[\"next\"] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                this._i += step;\n                this._idx += 1;\n                if (this._idx >= length) {\n                    return {\n                        \"done\": true\n                    };\n                }\n                return {\n                    \"done\": false,\n                    \"value\": this._i\n                };\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        return _$rapyd$_d;\n    })();\n};\n\n_$rapyd$_range.__argnames__ = [\"start\", \"stop\", \"step\"];\n\nfunction _$rapyd$_getattr(obj, name, defval) {\n    var ret;\n    try {\n        ret = obj[name];\n    } catch (_$rapyd$_Exception) {\n        if (_$rapyd$_Exception instanceof TypeError) {\n            if (defval === undefined) {\n                throw new AttributeError(\"The attribute \" + name + \" is not present\");\n            }\n            return defval;\n        } else {\n            throw _$rapyd$_Exception;\n        }\n    }\n    if (ret === undefined && !(name in obj)) {\n        if (defval === undefined) {\n            throw new AttributeError(\"The attribute \" + name + \" is not present\");\n        }\n        ret = defval;\n    }\n    return ret;\n};\n\n_$rapyd$_getattr.__argnames__ = [\"obj\", \"name\", \"defval\"];\n\nfunction _$rapyd$_setattr(obj, name, value) {\n    obj[name] = value;\n};\n\n_$rapyd$_setattr.__argnames__ = [\"obj\", \"name\", \"value\"];\n\nfunction _$rapyd$_hasattr(obj, name) {\n    return name in obj;\n};\n\n_$rapyd$_hasattr.__argnames__ = [\"obj\", \"name\"];\n\n_$rapyd$_len = (function() {\n    var _$rapyd$_anonfunc = function () {\n        function len(obj) {\n            if (_$rapyd$_arraylike(obj)) {\n                return obj.length;\n            }\n            if (typeof obj.__len__ === \"function\") {\n                return obj.__len__();\n            }\n            if (obj instanceof Set || obj instanceof Map) {\n                return obj.size;\n            }\n            return Object.keys(obj).length;\n        };\n\n        len.__argnames__ = [\"obj\"];\n\n        function len5(obj) {\n            if (_$rapyd$_arraylike(obj)) {\n                return obj.length;\n            }\n            if (typeof obj.__len__ === \"function\") {\n                return obj.__len__();\n            }\n            return Object.keys(obj).length;\n        };\n\n        len5.__argnames__ = [\"obj\"];\n\n        return (typeof Set === \"function\" && typeof Map === \"function\") ? len : len5;\n    };\n    return _$rapyd$_anonfunc;\n})()();\nvar abs = Math.abs, max = Math.max, min = Math.min;\nvar bool = _$rapyd$_bool, bind = _$rapyd$_bind, rebind_all = _$rapyd$_rebind_all;\nvar float = _$rapyd$_float, int = _$rapyd$_int, arraylike = _$rapyd$_arraylike_creator(), _$rapyd$_arraylike = arraylike;\nvar mixin = _$rapyd$_mixin, print = _$rapyd$_print, eslice = _$rapyd$_eslice, id = _$rapyd$_id;\nvar dir = _$rapyd$_dir, ord = _$rapyd$_ord, chr = _$rapyd$_chr, bin = _$rapyd$_bin, hex = _$rapyd$_hex, callable = _$rapyd$_callable;\nvar enumerate = _$rapyd$_enumerate, iter = _$rapyd$_iter, reversed = _$rapyd$_reversed, len = _$rapyd$_len;\nvar range = _$rapyd$_range, getattr = _$rapyd$_getattr, setattr = _$rapyd$_setattr, hasattr = _$rapyd$_hasattr;var _$rapyd$_chain_assign_temp;\nfunction _$rapyd$_equals(a, b) {\n    var _$rapyd$_unpack, akeys, bkeys, key;\n    if (a === b) {\n        return true;\n    }\n    if (a && typeof a.__eq__ === \"function\") {\n        return a.__eq__(b);\n    }\n    if (b && typeof b.__eq__ === \"function\") {\n        return b.__eq__(a);\n    }\n    if (_$rapyd$_arraylike(a) && _$rapyd$_arraylike(b)) {\n        if ((a.length !== b.length && (typeof a.length !== \"object\" || _$rapyd$_not_equals(a.length, b.length)))) {\n            return false;\n        }\n        for (var i=0; i < a.length; i++) {\n            if (!((a[i] === b[i] || typeof a[i] === \"object\" && _$rapyd$_equals(a[i], b[i])))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (a && b && a.constructor === b.constructor && a.constructor === Object) {\n        _$rapyd$_unpack = [Object.keys(a), Object.keys(b)];\n        akeys = _$rapyd$_unpack[0];\n        bkeys = _$rapyd$_unpack[1];\n        if (akeys.length !== bkeys.length) {\n            return false;\n        }\n        for (var j=0; j < akeys.length; j++) {\n            key = akeys[j];\n            if (!((a[key] === b[key] || typeof a[key] === \"object\" && _$rapyd$_equals(a[key], b[key])))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n_$rapyd$_equals.__argnames__ = [\"a\", \"b\"];\n\nfunction _$rapyd$_not_equals(a, b) {\n    if (a === b) {\n        return false;\n    }\n    if (a && typeof a.__ne__ === \"function\") {\n        return a.__ne__(b);\n    }\n    if (b && typeof b.__ne__ === \"function\") {\n        return b.__ne__(a);\n    }\n    return !_$rapyd$_equals(a, b);\n};\n\n_$rapyd$_not_equals.__argnames__ = [\"a\", \"b\"];\n\nvar equals = _$rapyd$_equals;\nfunction _$rapyd$_list_extend(iterable) {\n    var start, iterator, result;\n    if (Array.isArray(iterable) || typeof iterable === \"string\") {\n        start = this.length;\n        this.length += iterable.length;\n        for (var i = 0; i < iterable.length; i++) {\n            this[start + i] = iterable[i];\n        }\n    } else {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n        result = iterator.next();\n        while (!result.done) {\n            this.push(result.value);\n            result = iterator.next();\n        }\n    }\n};\n\n_$rapyd$_list_extend.__argnames__ = [\"iterable\"];\n\nfunction _$rapyd$_list_index(val, start, stop) {\n    var idx;\n    start = start || 0;\n    if (start < 0) {\n        start = this.length + start;\n    }\n    if (start < 0) {\n        throw new ValueError(val + \" is not in list\");\n    }\n    if (stop === undefined) {\n        idx = this.indexOf(val, start);\n        if (idx === -1) {\n            throw new ValueError(val + \" is not in list\");\n        }\n        return idx;\n    }\n    if (stop < 0) {\n        stop = this.length + stop;\n    }\n    for (var i = start; i < stop; i++) {\n        if ((this[i] === val || typeof this[i] === \"object\" && _$rapyd$_equals(this[i], val))) {\n            return i;\n        }\n    }\n    throw new ValueError(val + \" is not in list\");\n};\n\n_$rapyd$_list_index.__argnames__ = [\"val\", \"start\", \"stop\"];\n\nfunction _$rapyd$_list_pop(index) {\n    var ans;\n    if (this.length === 0) {\n        throw new IndexError(\"list is empty\");\n    }\n    ans = this.splice(index, 1);\n    if (!ans.length) {\n        throw new IndexError(\"pop index out of range\");\n    }\n    return ans[0];\n};\n\n_$rapyd$_list_pop.__argnames__ = [\"index\"];\n\nfunction _$rapyd$_list_remove(value) {\n    var idx;\n    idx = this.indexOf(value);\n    if (idx === -1) {\n        throw new ValueError(value + \" not in list\");\n    }\n    this.splice(idx, 1);\n};\n\n_$rapyd$_list_remove.__argnames__ = [\"value\"];\n\nfunction _$rapyd$_list_to_string() {\n    return \"[\" + this.join(\", \") + \"]\";\n};\n\nfunction _$rapyd$_list_insert(index, val) {\n    if (index < 0) {\n        index += this.length;\n    }\n    index = min(this.length, max(index, 0));\n    if (index === 0) {\n        this.unshift(val);\n        return;\n    }\n    for (var i = this.length; i > index; i--) {\n        this[i] = this[i - 1];\n    }\n    this[index] = val;\n};\n\n_$rapyd$_list_insert.__argnames__ = [\"index\", \"val\"];\n\nfunction _$rapyd$_list_copy() {\n    return _$rapyd$_list_constructor(this);\n};\n\nfunction _$rapyd$_list_clear() {\n    this.length = 0;\n};\n\nfunction _$rapyd$_list_as_array() {\n    return Array.prototype.slice.call(this);\n};\n\nfunction _$rapyd$_list_count(value) {\n    return this.reduce((function() {\n        var _$rapyd$_anonfunc = function (n, val) {\n            return n + (val === value);\n        };\n\n        _$rapyd$_anonfunc.__argnames__ = [\"n\", \"val\"];\n        return _$rapyd$_anonfunc;\n    })(), 0);\n};\n\n_$rapyd$_list_count.__argnames__ = [\"value\"];\n\nfunction _$rapyd$_list_sort_key(value) {\n    var t;\n    t = typeof value;\n    if (t === \"string\" || t === \"number\") {\n        return value;\n    }\n    return value.toString();\n};\n\n_$rapyd$_list_sort_key.__argnames__ = [\"value\"];\n\nfunction _$rapyd$_list_sort_cmp(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n};\n\n_$rapyd$_list_sort_cmp.__argnames__ = [\"a\", \"b\"];\n\nfunction _$rapyd$_list_sort(key, reverse) {\n    var mult, keymap, k;\n    key = key || _$rapyd$_list_sort_key;\n    mult = (reverse) ? -1 : 1;\n    keymap = dict();\n    for (var i=0; i < this.length; i++) {\n        k = this[i];\n        keymap.set(k, key(k));\n    }\n    this.sort((function() {\n        var _$rapyd$_anonfunc = function (a, b) {\n            return mult * _$rapyd$_list_sort_cmp(keymap.get(a), keymap.get(b));\n        };\n\n        _$rapyd$_anonfunc.__argnames__ = [\"a\", \"b\"];\n        return _$rapyd$_anonfunc;\n    })());\n};\n\n_$rapyd$_list_sort.__argnames__ = [\"key\", \"reverse\"];\n\nfunction _$rapyd$_list_concat() {\n    var ans;\n    ans = Array.prototype.concat.apply(this, arguments);\n    _$rapyd$_list_decorate(ans);\n    return ans;\n};\n\nfunction _$rapyd$_list_slice() {\n    var ans;\n    ans = Array.prototype.slice.apply(this, arguments);\n    _$rapyd$_list_decorate(ans);\n    return ans;\n};\n\nfunction _$rapyd$_list_iterator(value) {\n    var self;\n    self = this;\n    return {\n        \"_i\": -1,\n        \"_list\": self,\n        \"next\": (function() {\n            var _$rapyd$_anonfunc = function () {\n                this._i += 1;\n                if (this._i >= this._list.length) {\n                    return {\n                        \"done\": true\n                    };\n                }\n                return {\n                    \"done\": false,\n                    \"value\": this._list[this._i]\n                };\n            };\n            return _$rapyd$_anonfunc;\n        })()\n    };\n};\n\n_$rapyd$_list_iterator.__argnames__ = [\"value\"];\n\nfunction _$rapyd$_list_len() {\n    return this.length;\n};\n\nfunction _$rapyd$_list_contains(val) {\n    for (var i = 0; i < this.length; i++) {\n        if ((this[i] === val || typeof this[i] === \"object\" && _$rapyd$_equals(this[i], val))) {\n            return true;\n        }\n    }\n    return false;\n};\n\n_$rapyd$_list_contains.__argnames__ = [\"val\"];\n\nfunction _$rapyd$_list_eq(other) {\n    if (!_$rapyd$_arraylike(other)) {\n        return false;\n    }\n    if ((this.length !== other.length && (typeof this.length !== \"object\" || _$rapyd$_not_equals(this.length, other.length)))) {\n        return false;\n    }\n    for (var i = 0; i < this.length; i++) {\n        if (!((this[i] === other[i] || typeof this[i] === \"object\" && _$rapyd$_equals(this[i], other[i])))) {\n            return false;\n        }\n    }\n    return true;\n};\n\n_$rapyd$_list_eq.__argnames__ = [\"other\"];\n\nfunction _$rapyd$_list_decorate(ans) {\n    ans.append = Array.prototype.push;\n    ans.toString = _$rapyd$_list_to_string;\n    ans.inspect = _$rapyd$_list_to_string;\n    ans.extend = _$rapyd$_list_extend;\n    ans.index = _$rapyd$_list_index;\n    ans.pypop = _$rapyd$_list_pop;\n    ans.remove = _$rapyd$_list_remove;\n    ans.insert = _$rapyd$_list_insert;\n    ans.copy = _$rapyd$_list_copy;\n    ans.clear = _$rapyd$_list_clear;\n    ans.count = _$rapyd$_list_count;\n    ans.concat = _$rapyd$_list_concat;\n    ans.pysort = _$rapyd$_list_sort;\n    ans.slice = _$rapyd$_list_slice;\n    ans.as_array = _$rapyd$_list_as_array;\n    ans.__len__ = _$rapyd$_list_len;\n    ans.__contains__ = _$rapyd$_list_contains;\n    ans.__eq__ = _$rapyd$_list_eq;\n    ans.constructor = _$rapyd$_list_constructor;\n    if (typeof ans[_$rapyd$_iterator_symbol] !== \"function\") {\n        ans[_$rapyd$_iterator_symbol] = _$rapyd$_list_iterator;\n    }\n    return ans;\n};\n\n_$rapyd$_list_decorate.__argnames__ = [\"ans\"];\n\nfunction _$rapyd$_list_constructor(iterable) {\n    var ans, iterator, result;\n    if (iterable === undefined) {\n        ans = [];\n    } else if (_$rapyd$_arraylike(iterable)) {\n        ans = new Array(iterable.length);\n        for (var i = 0; i < iterable.length; i++) {\n            ans[i] = iterable[i];\n        }\n    } else if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n        ans = _$rapyd$_list_decorate([]);\n        result = iterator.next();\n        while (!result.done) {\n            ans.push(result.value);\n            result = iterator.next();\n        }\n    } else if (typeof iterable === \"number\") {\n        ans = new Array(iterable);\n    } else {\n        ans = Object.keys(iterable);\n    }\n    return _$rapyd$_list_decorate(ans);\n};\n\n_$rapyd$_list_constructor.__argnames__ = [\"iterable\"];\n\n_$rapyd$_list_constructor.__name__ = \"list\";\nvar list = _$rapyd$_list_constructor, list_wrap = _$rapyd$_list_decorate;\nfunction sorted() {\n    var iterable = ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true) ? undefined : arguments[0];\n    var key = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? sorted.__defaults__.key : arguments[1];\n    var reverse = (arguments[2] === undefined || ( 2 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? sorted.__defaults__.reverse : arguments[2];\n    var _$rapyd$_kwargs_obj = arguments[arguments.length-1];\n    if (_$rapyd$_kwargs_obj === null || typeof _$rapyd$_kwargs_obj !== \"object\" || _$rapyd$_kwargs_obj [_$rapyd$_kwargs_symbol] !== true) _$rapyd$_kwargs_obj = {};\n    if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"key\")){\n        key = _$rapyd$_kwargs_obj.key;\n    }\n    if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"reverse\")){\n        reverse = _$rapyd$_kwargs_obj.reverse;\n    }\n    var ans;\n    ans = _$rapyd$_list_constructor(iterable);\n    ans.pysort(key, reverse);\n    return ans;\n};\n\nsorted.__defaults__ = {\n    key:null, \n    reverse:false\n};\n\nsorted.__handles_kwarg_interpolation__ = true;\n\nsorted.__argnames__ = [\"iterable\", \"key\", \"reverse\"];\n\nvar _$rapyd$_global_object_id = 0, _$rapyd$_set_implementation;\nfunction _$rapyd$_set_keyfor(x) {\n    var t, ans;\n    t = typeof x;\n    if (t === \"string\" || t === \"number\" || t === \"boolean\") {\n        return \"_\" + t[0] + x;\n    }\n    if (x === null) {\n        return \"__!@#$0\";\n    }\n    ans = x._$rapyd$_hash_key_prop;\n    if (ans === undefined) {\n        ans = \"_!@#$\" + (++_$rapyd$_global_object_id);\n        Object.defineProperty(x, \"_$rapyd$_hash_key_prop\", {\n            \"value\": ans\n        });\n    }\n    return ans;\n};\n\n_$rapyd$_set_keyfor.__argnames__ = [\"x\"];\n\nfunction _$rapyd$_set_polyfill() {\n    this._store = {};\n    this.size = 0;\n};\n\n_$rapyd$_set_polyfill.prototype.add = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        var key;\n        key = _$rapyd$_set_keyfor(x);\n        if (!Object.hasOwnProperty.call(this._store, key)) {\n            this.size += 1;\n            this._store[key] = x;\n        }\n        return this;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set_polyfill.prototype.clear = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        this._store = {};\n        this.size = 0;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set_polyfill.prototype.delete = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        var key;\n        key = _$rapyd$_set_keyfor(x);\n        if (Object.hasOwnProperty.call(this._store, key)) {\n            this.size -= 1;\n            delete this._store[key];\n            return true;\n        }\n        return false;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set_polyfill.prototype.has = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        return Object.hasOwnProperty.call(this._store, _$rapyd$_set_keyfor(x));\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set_polyfill.prototype.values = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        var keys, s;\n        keys = Object.keys(this._store);\n        s = this._store;\n        return (function(){\n            var _$rapyd$_d = {};\n            _$rapyd$_d[\"_keys\"] = keys;\n            _$rapyd$_d[\"_i\"] = -1;\n            _$rapyd$_d[\"_s\"] = s;\n            _$rapyd$_d[_$rapyd$_iterator_symbol] = (function() {\n                var _$rapyd$_anonfunc = function () {\n                    return this;\n                };\n                return _$rapyd$_anonfunc;\n            })();\n            _$rapyd$_d[\"next\"] = (function() {\n                var _$rapyd$_anonfunc = function () {\n                    this._i += 1;\n                    if (this._i >= this._keys.length) {\n                        return {\n                            \"done\": true\n                        };\n                    }\n                    return {\n                        \"done\": false,\n                        \"value\": s[this._keys[this._i]]\n                    };\n                };\n                return _$rapyd$_anonfunc;\n            })();\n            return _$rapyd$_d;\n        })();\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\nif (typeof Set !== \"function\" || typeof Set.prototype.delete !== \"function\") {\n    _$rapyd$_set_implementation = _$rapyd$_set_polyfill;\n} else {\n    _$rapyd$_set_implementation = Set;\n}\nfunction _$rapyd$_set(iterable) {\n    var ans, s, iterator, result, keys;\n    if (this instanceof _$rapyd$_set) {\n        this.jsset = new _$rapyd$_set_implementation;\n        ans = this;\n        if (iterable === undefined) {\n            return ans;\n        }\n        s = ans.jsset;\n        if (_$rapyd$_arraylike(iterable)) {\n            for (var i = 0; i < iterable.length; i++) {\n                s.add(iterable[i]);\n            }\n        } else if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n            iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n            result = iterator.next();\n            while (!result.done) {\n                s.add(result.value);\n                result = iterator.next();\n            }\n        } else {\n            keys = Object.keys(iterable);\n            for (var j=0; j < keys.length; j++) {\n                s.add(keys[j]);\n            }\n        }\n        return ans;\n    } else {\n        return new _$rapyd$_set(iterable);\n    }\n};\n\n_$rapyd$_set.__argnames__ = [\"iterable\"];\n\n_$rapyd$_set.prototype.__name__ = \"set\";\nObject.defineProperties(_$rapyd$_set.prototype, {\n    \"length\": {\n        \"get\": (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this.jsset.size;\n            };\n            return _$rapyd$_anonfunc;\n        })()\n    },\n    \"size\": {\n        \"get\": (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this.jsset.size;\n            };\n            return _$rapyd$_anonfunc;\n        })()\n    }\n});\n_$rapyd$_set.prototype.__len__ = (function() {\n    var _$rapyd$_anonfunc = function () {\n        return this.jsset.size;\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_chain_assign_temp = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        return this.jsset.has(x);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.has = _$rapyd$_chain_assign_temp;\n_$rapyd$_set.prototype.__contains__ = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_set.prototype.add = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        this.jsset.add(x);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.clear = (function() {\n    var _$rapyd$_anonfunc = function () {\n        this.jsset.clear();\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.copy = (function() {\n    var _$rapyd$_anonfunc = function () {\n        return _$rapyd$_set(this);\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.discard = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        this.jsset.delete(x);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype[_$rapyd$_iterator_symbol] = (function() {\n    var _$rapyd$_anonfunc = function () {\n        return this.jsset.values();\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.difference = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var ans, s, iterator, r, x, has;\n        ans = new _$rapyd$_set;\n        s = ans.jsset;\n        iterator = this.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            has = false;\n            for (var i = 0; i < arguments.length; i++) {\n                if (arguments[i].has(x)) {\n                    has = true;\n                    break;\n                }\n            }\n            if (!has) {\n                s.add(x);\n            }\n            r = iterator.next();\n        }\n        return ans;\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.difference_update = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var s, remove, iterator, r, x;\n        s = this.jsset;\n        remove = [];\n        iterator = s.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            for (var i = 0; i < arguments.length; i++) {\n                if (arguments[i].has(x)) {\n                    remove.push(x);\n                    break;\n                }\n            }\n            r = iterator.next();\n        }\n        for (var j = 0; j < remove.length; j++) {\n            s.delete(remove[j]);\n        }\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.intersection = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var ans, s, iterator, r, x, has;\n        ans = new _$rapyd$_set;\n        s = ans.jsset;\n        iterator = this.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            has = true;\n            for (var i = 0; i < arguments.length; i++) {\n                if (!arguments[i].has(x)) {\n                    has = false;\n                    break;\n                }\n            }\n            if (has) {\n                s.add(x);\n            }\n            r = iterator.next();\n        }\n        return ans;\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.intersection_update = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var s, remove, iterator, r, x;\n        s = this.jsset;\n        remove = [];\n        iterator = s.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            for (var i = 0; i < arguments.length; i++) {\n                if (!arguments[i].has(x)) {\n                    remove.push(x);\n                    break;\n                }\n            }\n            r = iterator.next();\n        }\n        for (var j = 0; j < remove.length; j++) {\n            s.delete(remove[j]);\n        }\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.isdisjoint = (function() {\n    var _$rapyd$_anonfunc = function (other) {\n        var iterator, r, x;\n        iterator = this.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            if (other.has(x)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"other\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.issubset = (function() {\n    var _$rapyd$_anonfunc = function (other) {\n        var iterator, r, x;\n        iterator = this.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            if (!other.has(x)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"other\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.issuperset = (function() {\n    var _$rapyd$_anonfunc = function (other) {\n        var s, iterator, r, x;\n        s = this.jsset;\n        iterator = other.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            if (!s.has(x)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"other\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.pop = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var iterator, r;\n        iterator = this.jsset.values();\n        r = iterator.next();\n        if (r.done) {\n            throw new KeyError(\"pop from an empty set\");\n        }\n        this.jsset.delete(r.value);\n        return r.value;\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.remove = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        if (!this.jsset.delete(x)) {\n            throw new KeyError(x.toString());\n        }\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.symmetric_difference = (function() {\n    var _$rapyd$_anonfunc = function (other) {\n        return this.union(other).difference(this.intersection(other));\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"other\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.symmetric_difference_update = (function() {\n    var _$rapyd$_anonfunc = function (other) {\n        var common;\n        common = this.intersection(other);\n        this.update(other);\n        this.difference_update(common);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"other\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.union = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var ans;\n        ans = _$rapyd$_set(this);\n        ans.update.apply(ans, arguments);\n        return ans;\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.update = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var s, iterator, r;\n        s = this.jsset;\n        for (var i=0; i < arguments.length; i++) {\n            iterator = arguments[i][_$rapyd$_iterator_symbol]();\n            r = iterator.next();\n            while (!r.done) {\n                s.add(r.value);\n                r = iterator.next();\n            }\n        }\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_chain_assign_temp = (function() {\n    var _$rapyd$_anonfunc = function () {\n        return \"{\" + list(this).join(\", \") + \"}\";\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.toString = _$rapyd$_chain_assign_temp;\n_$rapyd$_set.prototype.inspect = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_set.prototype.__eq__ = (function() {\n    var _$rapyd$_anonfunc = function (other) {\n        var iterator, r;\n        if (!(other instanceof this.constructor)) {\n            return false;\n        }\n        if (other.size !== this.size) {\n            return false;\n        }\n        if (other.size === 0) {\n            return true;\n        }\n        iterator = other[_$rapyd$_iterator_symbol]();\n        r = iterator.next();\n        while (!r.done) {\n            if (!this.has(r.value)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"other\"];\n    return _$rapyd$_anonfunc;\n})();\nfunction _$rapyd$_set_wrap(x) {\n    var ans;\n    ans = new _$rapyd$_set;\n    ans.jsset = x;\n    return ans;\n};\n\n_$rapyd$_set_wrap.__argnames__ = [\"x\"];\n\nvar set = _$rapyd$_set, set_wrap = _$rapyd$_set_wrap;\nvar _$rapyd$_dict_implementation;\nfunction _$rapyd$_dict_polyfill() {\n    this._store = {};\n    this.size = 0;\n};\n\n_$rapyd$_dict_polyfill.prototype.set = (function() {\n    var _$rapyd$_anonfunc = function (x, value) {\n        var key;\n        key = _$rapyd$_set_keyfor(x);\n        if (!Object.hasOwnProperty.call(this._store, key)) {\n            this.size += 1;\n        }\n        this._store[key] = [x, value];\n        return this;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\", \"value\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict_polyfill.prototype.clear = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        this._store = {};\n        this.size = 0;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict_polyfill.prototype.delete = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        var key;\n        key = _$rapyd$_set_keyfor(x);\n        if (Object.hasOwnProperty.call(this._store, key)) {\n            this.size -= 1;\n            delete this._store[key];\n            return true;\n        }\n        return false;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict_polyfill.prototype.has = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        return Object.hasOwnProperty.call(this._store, _$rapyd$_set_keyfor(x));\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict_polyfill.prototype.get = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        try {\n            return this._store[_$rapyd$_set_keyfor(x)][1];\n        } catch (_$rapyd$_Exception) {\n            if (_$rapyd$_Exception instanceof TypeError) {\n                return undefined;\n            } else {\n                throw _$rapyd$_Exception;\n            }\n        }\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict_polyfill.prototype.values = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        var keys, s;\n        keys = Object.keys(this._store);\n        s = this._store;\n        return (function(){\n            var _$rapyd$_d = {};\n            _$rapyd$_d[\"_keys\"] = keys;\n            _$rapyd$_d[\"_i\"] = -1;\n            _$rapyd$_d[\"_s\"] = s;\n            _$rapyd$_d[_$rapyd$_iterator_symbol] = (function() {\n                var _$rapyd$_anonfunc = function () {\n                    return this;\n                };\n                return _$rapyd$_anonfunc;\n            })();\n            _$rapyd$_d[\"next\"] = (function() {\n                var _$rapyd$_anonfunc = function () {\n                    this._i += 1;\n                    if (this._i >= this._keys.length) {\n                        return {\n                            \"done\": true\n                        };\n                    }\n                    return {\n                        \"done\": false,\n                        \"value\": s[this._keys[this._i]][1]\n                    };\n                };\n                return _$rapyd$_anonfunc;\n            })();\n            return _$rapyd$_d;\n        })();\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict_polyfill.prototype.keys = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        var keys, s;\n        keys = Object.keys(this._store);\n        s = this._store;\n        return (function(){\n            var _$rapyd$_d = {};\n            _$rapyd$_d[\"_keys\"] = keys;\n            _$rapyd$_d[\"_i\"] = -1;\n            _$rapyd$_d[\"_s\"] = s;\n            _$rapyd$_d[_$rapyd$_iterator_symbol] = (function() {\n                var _$rapyd$_anonfunc = function () {\n                    return this;\n                };\n                return _$rapyd$_anonfunc;\n            })();\n            _$rapyd$_d[\"next\"] = (function() {\n                var _$rapyd$_anonfunc = function () {\n                    this._i += 1;\n                    if (this._i >= this._keys.length) {\n                        return {\n                            \"done\": true\n                        };\n                    }\n                    return {\n                        \"done\": false,\n                        \"value\": s[this._keys[this._i]][0]\n                    };\n                };\n                return _$rapyd$_anonfunc;\n            })();\n            return _$rapyd$_d;\n        })();\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict_polyfill.prototype.entries = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        var keys, s;\n        keys = Object.keys(this._store);\n        s = this._store;\n        return (function(){\n            var _$rapyd$_d = {};\n            _$rapyd$_d[\"_keys\"] = keys;\n            _$rapyd$_d[\"_i\"] = -1;\n            _$rapyd$_d[\"_s\"] = s;\n            _$rapyd$_d[_$rapyd$_iterator_symbol] = (function() {\n                var _$rapyd$_anonfunc = function () {\n                    return this;\n                };\n                return _$rapyd$_anonfunc;\n            })();\n            _$rapyd$_d[\"next\"] = (function() {\n                var _$rapyd$_anonfunc = function () {\n                    this._i += 1;\n                    if (this._i >= this._keys.length) {\n                        return {\n                            \"done\": true\n                        };\n                    }\n                    return {\n                        \"done\": false,\n                        \"value\": s[this._keys[this._i]]\n                    };\n                };\n                return _$rapyd$_anonfunc;\n            })();\n            return _$rapyd$_d;\n        })();\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\nif (typeof Map !== \"function\" || typeof Map.prototype.delete !== \"function\") {\n    _$rapyd$_dict_implementation = _$rapyd$_dict_polyfill;\n} else {\n    _$rapyd$_dict_implementation = Map;\n}\nfunction _$rapyd$_dict(iterable) {\n    if (this instanceof _$rapyd$_dict) {\n        this.jsmap = new _$rapyd$_dict_implementation;\n        if (iterable !== undefined) {\n            this.update(iterable);\n        }\n        return this;\n    } else {\n        return new _$rapyd$_dict(iterable);\n    }\n};\n\n_$rapyd$_dict.__argnames__ = [\"iterable\"];\n\n_$rapyd$_dict.prototype.__name__ = \"dict\";\nObject.defineProperties(_$rapyd$_dict.prototype, {\n    \"length\": {\n        \"get\": (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this.jsmap.size;\n            };\n            return _$rapyd$_anonfunc;\n        })()\n    },\n    \"size\": {\n        \"get\": (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this.jsmap.size;\n            };\n            return _$rapyd$_anonfunc;\n        })()\n    }\n});\n_$rapyd$_dict.prototype.__len__ = (function() {\n    var _$rapyd$_anonfunc = function () {\n        return this.jsmap.size;\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_chain_assign_temp = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        return this.jsmap.has(x);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.has = _$rapyd$_chain_assign_temp;\n_$rapyd$_dict.prototype.__contains__ = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_chain_assign_temp = (function() {\n    var _$rapyd$_anonfunc = function (key, value) {\n        this.jsmap.set(key, value);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"key\", \"value\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.set = _$rapyd$_chain_assign_temp;\n_$rapyd$_dict.prototype.__setitem__ = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_dict.prototype.clear = (function() {\n    var _$rapyd$_anonfunc = function () {\n        this.jsmap.clear();\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.copy = (function() {\n    var _$rapyd$_anonfunc = function () {\n        return _$rapyd$_dict(this);\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.keys = (function() {\n    var _$rapyd$_anonfunc = function () {\n        return this.jsmap.keys();\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.values = (function() {\n    var _$rapyd$_anonfunc = function () {\n        return this.jsmap.values();\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_chain_assign_temp = (function() {\n    var _$rapyd$_anonfunc = function () {\n        return this.jsmap.entries();\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.items = _$rapyd$_chain_assign_temp;\n_$rapyd$_dict.prototype.entries = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_dict.prototype[_$rapyd$_iterator_symbol] = (function() {\n    var _$rapyd$_anonfunc = function () {\n        return this.jsmap.keys();\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.__getitem__ = (function() {\n    var _$rapyd$_anonfunc = function (key) {\n        var ans;\n        ans = this.jsmap.get(key);\n        if (ans === undefined && !this.jsmap.has(key)) {\n            throw new KeyError(key + \"\");\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"key\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.get = (function() {\n    var _$rapyd$_anonfunc = function (key, defval) {\n        var ans;\n        ans = this.jsmap.get(key);\n        if (ans === undefined && !this.jsmap.has(key)) {\n            return (defval === undefined) ? null : defval;\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"key\", \"defval\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.set_default = (function() {\n    var _$rapyd$_anonfunc = function (key, defval) {\n        var j;\n        j = this.jsmap;\n        if (!j.has(key)) {\n            j.set(key, defval);\n            return defval;\n        }\n        return j.get(key);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"key\", \"defval\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_chain_assign_temp = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var iterable = ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true) ? undefined : arguments[0];\n        var value = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? _$rapyd$_anonfunc.__defaults__.value : arguments[1];\n        var _$rapyd$_kwargs_obj = arguments[arguments.length-1];\n        if (_$rapyd$_kwargs_obj === null || typeof _$rapyd$_kwargs_obj !== \"object\" || _$rapyd$_kwargs_obj [_$rapyd$_kwargs_symbol] !== true) _$rapyd$_kwargs_obj = {};\n        if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"value\")){\n            value = _$rapyd$_kwargs_obj.value;\n        }\n        var ans, iterator, r;\n        ans = _$rapyd$_dict();\n        iterator = iter(iterable);\n        r = iterator.next();\n        while (!r.done) {\n            ans.set(r.value, value);\n            r = iterator.next();\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__defaults__ = {\n        value:null\n    };\n\n    _$rapyd$_anonfunc.__handles_kwarg_interpolation__ = true;\n\n    _$rapyd$_anonfunc.__argnames__ = [\"iterable\", \"value\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.fromkeys = _$rapyd$_chain_assign_temp;\n_$rapyd$_dict.prototype.fromkeys = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_dict.prototype.pop = (function() {\n    var _$rapyd$_anonfunc = function (key, defval) {\n        var ans;\n        ans = this.jsmap.get(key);\n        if (ans === undefined && !this.jsmap.has(key)) {\n            if (defval === undefined) {\n                throw new KeyError(key);\n            }\n            return defval;\n        }\n        this.jsmap.delete(key);\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"key\", \"defval\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.popitem = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var r;\n        r = this.jsmap.entries().next();\n        if (r.done) {\n            throw new KeyError(\"dict is empty\");\n        }\n        this.jsmap.delete(r.value[0]);\n        return r.value;\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.update = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var m, iterable, iterator, result, keys;\n        if (arguments.length === 0) {\n            return;\n        }\n        m = this.jsmap;\n        iterable = arguments[0];\n        if (Array.isArray(iterable)) {\n            for (var i = 0; i < iterable.length; i++) {\n                m.set(iterable[i][0], iterable[i][1]);\n            }\n        } else if (iterable instanceof _$rapyd$_dict) {\n            iterator = iterable.items();\n            result = iterator.next();\n            while (!result.done) {\n                m.set(result.value[0], result.value[1]);\n                result = iterator.next();\n            }\n        } else if (typeof Map === \"function\" && iterable instanceof Map) {\n            iterator = iterable.entries();\n            result = iterator.next();\n            while (!result.done) {\n                m.set(result.value[0], result.value[1]);\n                result = iterator.next();\n            }\n        } else if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n            iterator = iterable[_$rapyd$_iterator_symbol]();\n            result = iterator.next();\n            while (!result.done) {\n                m.set(result.value[0], result.value[1]);\n                result = iterator.next();\n            }\n        } else {\n            keys = Object.keys(iterable);\n            for (var j=0; j < keys.length; j++) {\n                if (keys[j] !== _$rapyd$_iterator_symbol) {\n                    m.set(keys[j], iterable[keys[j]]);\n                }\n            }\n        }\n        if (arguments.length > 1) {\n            _$rapyd$_dict.prototype.update.call(this, arguments[1]);\n        }\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_chain_assign_temp = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var entries, iterator, r;\n        entries = [];\n        iterator = this.jsmap.entries();\n        r = iterator.next();\n        while (!r.done) {\n            entries.push(r.value[0] + \": \" + r.value[1]);\n            r = iterator.next();\n        }\n        return \"{\" + entries.join(\", \") + \"}\";\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.toString = _$rapyd$_chain_assign_temp;\n_$rapyd$_dict.prototype.inspect = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_dict.prototype.__eq__ = (function() {\n    var _$rapyd$_anonfunc = function (other) {\n        var iterator, r, x;\n        if (!(other instanceof this.constructor)) {\n            return false;\n        }\n        if (other.size !== this.size) {\n            return false;\n        }\n        if (other.size === 0) {\n            return true;\n        }\n        iterator = other.items();\n        r = iterator.next();\n        while (!r.done) {\n            x = this.jsmap.get(r.value[0]);\n            if (x === undefined && !this.jsmap.has(r.value[0]) || x !== r.value[1]) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"other\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.as_object = (function() {\n    var _$rapyd$_anonfunc = function (other) {\n        var ans, iterator, r;\n        ans = {};\n        iterator = this.jsmap.entries();\n        r = iterator.next();\n        while (!r.done) {\n            ans[r.value[0]] = r.value[1];\n            r = iterator.next();\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"other\"];\n    return _$rapyd$_anonfunc;\n})();\nfunction _$rapyd$_dict_wrap(x) {\n    var ans;\n    ans = new _$rapyd$_dict;\n    ans.jsmap = x;\n    return ans;\n};\n\n_$rapyd$_dict_wrap.__argnames__ = [\"x\"];\n\nvar dict = _$rapyd$_dict, dict_wrap = _$rapyd$_dict_wrap;var Exception = Error;\nfunction AttributeError() {\n    if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n    AttributeError.prototype.__init__.apply(this, arguments);\n}\n_$rapyd$_extends(AttributeError, Error);\nAttributeError.prototype.__init__ = function __init__(msg) {\n    var self = this;\n    self.message = msg;\n    self.stack = (new Error).stack;\n};\n\nAttributeError.prototype.__init__.__argnames__ = [\"msg\"];\nAttributeError.__argnames__ = AttributeError.prototype.__init__.__argnames__;\nAttributeError.__handles_kwarg_interpolation__ = AttributeError.prototype.__init__.__handles_kwarg_interpolation__;\nAttributeError.prototype.__repr__ = function __repr__ () {\n    return \"<\" + __name__ + \".\" + \"AttributeError\" + \" #\" + this._$rapyd$_object_id + \">\";\n};\nAttributeError.prototype.__str__ = function __str__ () {\n    return this.__repr__();\n};\nAttributeError.prototype.name = \"AttributeError\";\n\nfunction IndexError() {\n    if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n    IndexError.prototype.__init__.apply(this, arguments);\n}\n_$rapyd$_extends(IndexError, Error);\nIndexError.prototype.__init__ = function __init__(msg) {\n    var self = this;\n    self.message = msg;\n    self.stack = (new Error).stack;\n};\n\nIndexError.prototype.__init__.__argnames__ = [\"msg\"];\nIndexError.__argnames__ = IndexError.prototype.__init__.__argnames__;\nIndexError.__handles_kwarg_interpolation__ = IndexError.prototype.__init__.__handles_kwarg_interpolation__;\nIndexError.prototype.__repr__ = function __repr__ () {\n    return \"<\" + __name__ + \".\" + \"IndexError\" + \" #\" + this._$rapyd$_object_id + \">\";\n};\nIndexError.prototype.__str__ = function __str__ () {\n    return this.__repr__();\n};\nIndexError.prototype.name = \"IndexError\";\n\nfunction KeyError() {\n    if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n    KeyError.prototype.__init__.apply(this, arguments);\n}\n_$rapyd$_extends(KeyError, Error);\nKeyError.prototype.__init__ = function __init__(msg) {\n    var self = this;\n    self.message = msg;\n    self.stack = (new Error).stack;\n};\n\nKeyError.prototype.__init__.__argnames__ = [\"msg\"];\nKeyError.__argnames__ = KeyError.prototype.__init__.__argnames__;\nKeyError.__handles_kwarg_interpolation__ = KeyError.prototype.__init__.__handles_kwarg_interpolation__;\nKeyError.prototype.__repr__ = function __repr__ () {\n    return \"<\" + __name__ + \".\" + \"KeyError\" + \" #\" + this._$rapyd$_object_id + \">\";\n};\nKeyError.prototype.__str__ = function __str__ () {\n    return this.__repr__();\n};\nKeyError.prototype.name = \"KeyError\";\n\nfunction ValueError() {\n    if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n    ValueError.prototype.__init__.apply(this, arguments);\n}\n_$rapyd$_extends(ValueError, Error);\nValueError.prototype.__init__ = function __init__(msg) {\n    var self = this;\n    self.message = msg;\n    self.stack = (new Error).stack;\n};\n\nValueError.prototype.__init__.__argnames__ = [\"msg\"];\nValueError.__argnames__ = ValueError.prototype.__init__.__argnames__;\nValueError.__handles_kwarg_interpolation__ = ValueError.prototype.__init__.__handles_kwarg_interpolation__;\nValueError.prototype.__repr__ = function __repr__ () {\n    return \"<\" + __name__ + \".\" + \"ValueError\" + \" #\" + this._$rapyd$_object_id + \">\";\n};\nValueError.prototype.__str__ = function __str__ () {\n    return this.__repr__();\n};\nValueError.prototype.name = \"ValueError\";\n\nfunction UnicodeDecodeError() {\n    if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n    UnicodeDecodeError.prototype.__init__.apply(this, arguments);\n}\n_$rapyd$_extends(UnicodeDecodeError, ValueError);\nUnicodeDecodeError.prototype.__init__ = function __init__ () {\n    ValueError.prototype.__init__ && ValueError.prototype.__init__.apply(this, arguments);\n};\nUnicodeDecodeError.prototype.__repr__ = function __repr__ () {\n    return \"<\" + __name__ + \".\" + \"UnicodeDecodeError\" + \" #\" + this._$rapyd$_object_id + \">\";\n};\nUnicodeDecodeError.prototype.__str__ = function __str__ () {\n    return this.__repr__();\n};\nUnicodeDecodeError.prototype.name = \"UnicodeDecodeError\";\nvar _$rapyd$_in, _$rapyd$_desugar_kwargs;\nfunction _$rapyd$_flatten(arr) {\n    var ans, value;\n    ans = _$rapyd$_list_decorate([]);\n    for (var i=0; i<arr.length; i++) {\n        value = arr[i];\n        if (Array.isArray(value)) {\n            ans = ans.concat(_$rapyd$_flatten(value));\n        } else {\n            ans.push(value);\n        }\n    }\n    return ans;\n};\n\n_$rapyd$_flatten.__argnames__ = [\"arr\"];\n\nfunction _$rapyd$_extends(child, parent) {\n    child.prototype = Object.create(parent.prototype);\n    child.prototype.constructor = child;\n};\n\n_$rapyd$_extends.__argnames__ = [\"child\", \"parent\"];\n\n_$rapyd$_in = (function() {\n    var _$rapyd$_anonfunc = function () {\n        if (typeof Map === \"function\" && typeof Set === \"function\") {\n            return (function() {\n                var _$rapyd$_anonfunc = function (val, arr) {\n                    if (typeof arr === \"string\") {\n                        return arr.indexOf(val) !== -1;\n                    }\n                    if (typeof arr.__contains__ === \"function\") {\n                        return arr.__contains__(val);\n                    }\n                    if ((arr instanceof Map || arr instanceof Set)) {\n                        return arr.has(val);\n                    }\n                    if (_$rapyd$_arraylike(arr)) {\n                        return _$rapyd$_list_contains.call(arr, val);\n                    }\n                    return Object.prototype.hasOwnProperty.call(arr, val);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"val\", \"arr\"];\n                return _$rapyd$_anonfunc;\n            })();\n        }\n        return (function() {\n            var _$rapyd$_anonfunc = function (val, arr) {\n                if (typeof arr === \"string\") {\n                    return arr.indexOf(val) !== -1;\n                }\n                if (typeof arr.__contains__ === \"function\") {\n                    return arr.__contains__(val);\n                }\n                if (_$rapyd$_arraylike(arr)) {\n                    return _$rapyd$_list_contains.call(arr, val);\n                }\n                return Object.prototype.hasOwnProperty.call(arr, val);\n            };\n\n            _$rapyd$_anonfunc.__argnames__ = [\"val\", \"arr\"];\n            return _$rapyd$_anonfunc;\n        })();\n    };\n    return _$rapyd$_anonfunc;\n})()();\nfunction _$rapyd$_Iterable(iterable) {\n    var iterator, ans, result;\n    if (_$rapyd$_arraylike(iterable)) {\n        return iterable;\n    }\n    if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n        ans = _$rapyd$_list_decorate([]);\n        result = iterator.next();\n        while (!result.done) {\n            ans.push(result.value);\n            result = iterator.next();\n        }\n        return ans;\n    }\n    return Object.keys(iterable);\n};\n\n_$rapyd$_Iterable.__argnames__ = [\"iterable\"];\n\n_$rapyd$_desugar_kwargs = (function() {\n    var _$rapyd$_anonfunc = function () {\n        if (typeof Object.assign === \"function\") {\n            return (function() {\n                var _$rapyd$_anonfunc = function () {\n                    var ans;\n                    ans = {};\n                    ans[_$rapyd$_kwargs_symbol] = true;\n                    for (var i = 0; i < arguments.length; i++) {\n                        Object.assign(ans, arguments[i]);\n                    }\n                    return ans;\n                };\n                return _$rapyd$_anonfunc;\n            })();\n        }\n        return (function() {\n            var _$rapyd$_anonfunc = function () {\n                var ans, keys;\n                ans = {};\n                ans[_$rapyd$_kwargs_symbol] = true;\n                for (var i = 0; i < arguments.length; i++) {\n                    keys = Object.keys(arguments[i]);\n                    for (var j = 0; j < keys.length; j++) {\n                        ans[keys[j]] = arguments[i][keys[j]];\n                    }\n                }\n                return ans;\n            };\n            return _$rapyd$_anonfunc;\n        })();\n    };\n    return _$rapyd$_anonfunc;\n})()();\nfunction _$rapyd$_interpolate_kwargs(f, supplied_args) {\n    var has_prop, kwobj, args, prop;\n    if (!f.__argnames__) {\n        return f.apply(this, supplied_args);\n    }\n    has_prop = Object.prototype.hasOwnProperty;\n    kwobj = supplied_args.pop();\n    if (f.__handles_kwarg_interpolation__) {\n        args = new Array(Math.max(supplied_args.length, f.__argnames__.length) + 1);\n        args[args.length-1] = kwobj;\n        for (var i = 0; i < args.length - 1; i++) {\n            if (i < f.__argnames__.length) {\n                prop = f.__argnames__[i];\n                if (has_prop.call(kwobj, prop)) {\n                    args[i] = kwobj[prop];\n                    delete kwobj[prop];\n                } else if (i < supplied_args.length) {\n                    args[i] = supplied_args[i];\n                }\n            } else {\n                args[i] = supplied_args[i];\n            }\n        }\n        return f.apply(this, args);\n    }\n    for (var i = 0; i < f.__argnames__.length; i++) {\n        prop = f.__argnames__[i];\n        if (has_prop.call(kwobj, prop)) {\n            supplied_args[i] = kwobj[prop];\n        }\n    }\n    return f.apply(this, supplied_args);\n};\n\n_$rapyd$_interpolate_kwargs.__argnames__ = [\"f\", \"supplied_args\"];\n\nfunction _$rapyd$_interpolate_kwargs_constructor(apply, f, supplied_args) {\n    if (apply) {\n        f.apply(this, supplied_args);\n    } else {\n        _$rapyd$_interpolate_kwargs.call(this, f, supplied_args);\n    }\n    return this;\n};\n\n_$rapyd$_interpolate_kwargs_constructor.__argnames__ = [\"apply\", \"f\", \"supplied_args\"];\n\nfunction _$rapyd$_getitem(obj, key) {\n    return (obj.__getitem__) ? obj.__getitem__(key) : obj[key];\n};\n\n_$rapyd$_getitem.__argnames__ = [\"obj\", \"key\"];\n\nfunction _$rapyd$_setitem(obj, key, val) {\n    if (obj.__setitem__) {\n        obj.__setitem__(key, val);\n    } else {\n        obj[key] = val;\n    }\n};\n\n_$rapyd$_setitem.__argnames__ = [\"obj\", \"key\", \"val\"];\nfunction sum(iterable, start) {\n    var ans, iterator, r;\n    if (Array.isArray(iterable)) {\n        return iterable.reduce((function() {\n            var _$rapyd$_anonfunc = function (prev, cur) {\n                return prev + cur;\n            };\n\n            _$rapyd$_anonfunc.__argnames__ = [\"prev\", \"cur\"];\n            return _$rapyd$_anonfunc;\n        })(), start || 0);\n    }\n    ans = start || 0;\n    iterator = iter(iterable);\n    r = iterator.next();\n    while (!r.done) {\n        ans += r.value;\n        r = iterator.next();\n    }\n    return ans;\n};\n\nsum.__argnames__ = [\"iterable\", \"start\"];\n\nfunction map() {\n    var func, iterators, args;\n    func = arguments[0];\n    iterators = new Array(arguments.length - 1);\n    args = new Array(arguments.length - 1);\n    for (var i = 1; i < arguments.length; i++) {\n        iterators[i - 1] = iter(arguments[i]);\n    }\n    return (function(){\n        var _$rapyd$_d = {};\n        _$rapyd$_d[\"_func\"] = func;\n        _$rapyd$_d[\"_iterators\"] = iterators;\n        _$rapyd$_d[\"_args\"] = args;\n        _$rapyd$_d[\"next\"] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                var r;\n                for (var i = 0; i < this._iterators.length; i++) {\n                    r = this._iterators[i].next();\n                    if (r.done) {\n                        return {\n                            \"done\": true\n                        };\n                    }\n                    this._args[i] = r.value;\n                }\n                return {\n                    \"done\": false,\n                    \"value\": this._func.apply(undefined, this._args)\n                };\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        _$rapyd$_d[_$rapyd$_iterator_symbol] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this;\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        return _$rapyd$_d;\n    })();\n};\n\nfunction filter(func_or_none, iterable) {\n    return (function(){\n        var _$rapyd$_d = {};\n        _$rapyd$_d[\"_iterator\"] = iter(iterable);\n        _$rapyd$_d[\"_func\"] = (func_or_none === null) ? bool : func_or_none;\n        _$rapyd$_d[\"next\"] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                var r;\n                r = this._iterator.next();\n                while (!r.done) {\n                    if (this._func(r.value)) {\n                        return r;\n                    }\n                    r = this._iterator.next();\n                }\n                return {\n                    \"done\": true\n                };\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        _$rapyd$_d[_$rapyd$_iterator_symbol] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this;\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        return _$rapyd$_d;\n    })();\n};\n\nfilter.__argnames__ = [\"func_or_none\", \"iterable\"];\n\nfunction zip() {\n    var iterators;\n    iterators = new Array(arguments.length);\n    for (var i = 0; i < arguments.length; i++) {\n        iterators[i] = iter(arguments[i]);\n    }\n    return (function(){\n        var _$rapyd$_d = {};\n        _$rapyd$_d[\"_iterators\"] = iterators;\n        _$rapyd$_d[\"next\"] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                var args, r;\n                args = new Array(this._iterators.length);\n                for (var i = 0; i < this._iterators.length; i++) {\n                    r = this._iterators[i].next();\n                    if (r.done) {\n                        return {\n                            \"done\": true\n                        };\n                    }\n                    args[i] = r.value;\n                }\n                return {\n                    \"done\": false,\n                    \"value\": args\n                };\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        _$rapyd$_d[_$rapyd$_iterator_symbol] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this;\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        return _$rapyd$_d;\n    })();\n};\nfunction _$rapyd$_repr_js_builtin(x, as_array) {\n    var ans, b, keys, key;\n    ans = [];\n    b = \"{}\";\n    if (as_array) {\n        b = \"[]\";\n        for (var i = 0; i < x.length; i++) {\n            ans.push(_$rapyd$_repr(x[i]));\n        }\n    } else {\n        keys = Object.keys(x);\n        for (var k = 0; k < keys.length; k++) {\n            key = keys[k];\n            ans.push(JSON.stringify(key) + \":\" + _$rapyd$_repr(x[key]));\n        }\n    }\n    return b[0] + ans.join(\", \") + b[1];\n};\n\n_$rapyd$_repr_js_builtin.__argnames__ = [\"x\", \"as_array\"];\n\nfunction _$rapyd$_repr(x) {\n    var ans, name;\n    if (x === null) {\n        return \"None\";\n    }\n    if (x === undefined) {\n        return \"undefined\";\n    }\n    ans = x;\n    if (typeof x.__repr__ === \"function\") {\n        ans = x.__repr__();\n    } else if (x === true || x === false) {\n        ans = (x) ? \"True\" : \"False\";\n    } else if (Array.isArray(x)) {\n        ans = _$rapyd$_repr_js_builtin(x, true);\n    } else if (typeof x === \"function\") {\n        ans = x.toString();\n    } else {\n        name = Object.prototype.toString.call(x).slice(8, -1);\n        if (_$rapyd$_not_equals(\"Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array\".indexOf(name), -1)) {\n            return name + \"([\" + x.map((function() {\n                var _$rapyd$_anonfunc = function (i) {\n                    return str.format(\"0x{:02x}\", i);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"i\"];\n                return _$rapyd$_anonfunc;\n            })()).join(\", \") + \"])\";\n        }\n        ans = (typeof x.toString === \"function\") ? x.toString() : x;\n        if (ans === \"[object Object]\") {\n            return _$rapyd$_repr_js_builtin(x);\n        }\n        try {\n            ans = JSON.stringify(x);\n        } catch (_$rapyd$_Exception) {\n        }\n    }\n    return ans + \"\";\n};\n\n_$rapyd$_repr.__argnames__ = [\"x\"];\n\nfunction _$rapyd$_str(x) {\n    var ans, name;\n    if (x === null) {\n        return \"None\";\n    }\n    if (x === undefined) {\n        return \"undefined\";\n    }\n    ans = x;\n    if (typeof x.__str__ === \"function\") {\n        ans = x.__str__();\n    } else if (typeof x.__repr__ === \"function\") {\n        ans = x.__repr__();\n    } else if (x === true || x === false) {\n        ans = (x) ? \"True\" : \"False\";\n    } else if (Array.isArray(x)) {\n        ans = _$rapyd$_repr_js_builtin(x, true);\n    } else if (typeof x.toString === \"function\") {\n        name = Object.prototype.toString.call(x).slice(8, -1);\n        if (_$rapyd$_not_equals(\"Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array\".indexOf(name), -1)) {\n            return name + \"([\" + x.map((function() {\n                var _$rapyd$_anonfunc = function (i) {\n                    return str.format(\"0x{:02x}\", i);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"i\"];\n                return _$rapyd$_anonfunc;\n            })()).join(\", \") + \"])\";\n        }\n        ans = x.toString();\n        if (ans === \"[object Object]\") {\n            ans = _$rapyd$_repr_js_builtin(x);\n        }\n    }\n    return ans + \"\";\n};\n\n_$rapyd$_str.__argnames__ = [\"x\"];\n\n_$rapyd$_str.format = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var template, args, kwargs, explicit, implicit, _$rapyd$_chain_assign_temp, idx, ans, pos, in_brace, markup, ch;\n        template = arguments[0];\n        if (template === undefined) {\n            throw new TypeError(\"Template is required\");\n        }\n        args = Array.prototype.slice.call(arguments, 1);\n        kwargs = {};\n        if (args.length && args[args.length-1][_$rapyd$_kwargs_symbol] !== undefined) {\n            kwargs = args[args.length-1];\n            args = args.slice(0, -1);\n        }\n        _$rapyd$_chain_assign_temp = false;\n        explicit = _$rapyd$_chain_assign_temp;\n        implicit = _$rapyd$_chain_assign_temp;\n;\n        idx = 0;\n        if (_$rapyd$_str.format._template_resolve_pat === undefined) {\n            _$rapyd$_str.format._template_resolve_pat = /[.\\[]/;\n        }\n        function resolve(arg, object) {\n            var _$rapyd$_unpack, first, key, rest, ans;\n            if (!arg) {\n                return object;\n            }\n            _$rapyd$_unpack = [arg[0], arg.slice(1)];\n            first = _$rapyd$_unpack[0];\n            arg = _$rapyd$_unpack[1];\n            key = arg.split(_$rapyd$_str.format._template_resolve_pat, 1)[0];\n            rest = arg.slice(key.length);\n            ans = (first === \"[\") ? object[key.slice(0, -1)] : getattr(object, key);\n            if (ans === undefined) {\n                throw new KeyError((first === \"[\") ? key.slice(0, -1) : key);\n            }\n            return resolve(rest, ans);\n        };\n\n        resolve.__argnames__ = [\"arg\", \"object\"];\n\n        function resolve_format_spec(format_spec) {\n            if (_$rapyd$_str.format._template_resolve_fs_pat === undefined) {\n                _$rapyd$_str.format._template_resolve_fs_pat = /[{]([a-zA-Z0-9_]+)[}]/g;\n            }\n            return format_spec.replace(_$rapyd$_str.format._template_resolve_fs_pat, (function() {\n                var _$rapyd$_anonfunc = function (match, key) {\n                    if (!Object.prototype.hasOwnProperty.call(kwargs, key)) {\n                        return \"\";\n                    }\n                    return \"\" + kwargs[key];\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"match\", \"key\"];\n                return _$rapyd$_anonfunc;\n            })());\n        };\n\n        resolve_format_spec.__argnames__ = [\"format_spec\"];\n\n        function apply_formatting(value, format_spec) {\n            var _$rapyd$_unpack, fill, align, sign, fhash, zeropad, width, comma, precision, ftype, is_numeric, is_int, lftype, code, exp, nval, is_positive, left, right;\n            if (format_spec.indexOf(\"{\") !== -1) {\n                format_spec = resolve_format_spec(format_spec);\n            }\n            if (_$rapyd$_str.format._template_format_pat === undefined) {\n                _$rapyd$_str.format._template_format_pat = /([^{}](?=[<>=^]))?([<>=^])?([-+\\x20])?(\\#)?(0)?(\\d+)?(,)?(?:\\.(\\d+))?([bcdeEfFgGnosxX%])?/;\n            }\n            try {\n                _$rapyd$_unpack = format_spec.match(_$rapyd$_str.format._template_format_pat).slice(1);\n                fill = _$rapyd$_unpack[0];\n                align = _$rapyd$_unpack[1];\n                sign = _$rapyd$_unpack[2];\n                fhash = _$rapyd$_unpack[3];\n                zeropad = _$rapyd$_unpack[4];\n                width = _$rapyd$_unpack[5];\n                comma = _$rapyd$_unpack[6];\n                precision = _$rapyd$_unpack[7];\n                ftype = _$rapyd$_unpack[8];\n            } catch (_$rapyd$_Exception) {\n                if (_$rapyd$_Exception instanceof TypeError) {\n                    return value;\n                } else {\n                    throw _$rapyd$_Exception;\n                }\n            }\n            if (zeropad) {\n                fill = fill || \"0\";\n                align = align || \"=\";\n            } else {\n                fill = fill || \" \";\n                align = align || \">\";\n            }\n            is_numeric = Number(value) === value;\n            is_int = is_numeric && value % 1 === 0;\n            precision = parseInt(precision, 10);\n            lftype = (ftype || \"\").toLowerCase();\n            if (ftype === \"n\") {\n                is_numeric = true;\n                if (is_int) {\n                    if (comma) {\n                        throw new ValueError(\"Cannot specify ',' with 'n'\");\n                    }\n                    value = parseInt(value, 10).toLocaleString();\n                } else {\n                    value = parseFloat(value).toLocaleString();\n                }\n            } else if (['b', 'c', 'd', 'o', 'x'].indexOf(lftype) !== -1) {\n                value = parseInt(value, 10);\n                is_numeric = true;\n                if (!isNaN(value)) {\n                    if (ftype === \"b\") {\n                        value = (value >>> 0).toString(2);\n                        if (fhash) {\n                            value = \"0b\" + value;\n                        }\n                    } else if (ftype === \"c\") {\n                        if (value > 65535) {\n                            code = value - 65536;\n                            value = String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n                        } else {\n                            value = String.fromCharCode(value);\n                        }\n                    } else if (ftype === \"d\") {\n                        if (comma) {\n                            value = value.toLocaleString(\"en-US\");\n                        } else {\n                            value = value.toString(10);\n                        }\n                    } else if (ftype === \"o\") {\n                        value = value.toString(8);\n                        if (fhash) {\n                            value = \"0o\" + value;\n                        }\n                    } else if (lftype === \"x\") {\n                        value = value.toString(16);\n                        value = (ftype === \"x\") ? value.toLowerCase() : value.toUpperCase();\n                        if (fhash) {\n                            value = \"0x\" + value;\n                        }\n                    }\n                }\n            } else if (['e','f','g','%'].indexOf(lftype) !== -1) {\n                is_numeric = true;\n                value = parseFloat(value);\n                if (lftype === \"e\") {\n                    value = value.toExponential((isNaN(precision)) ? 6 : precision);\n                    value = (ftype === \"E\") ? value.toUpperCase() : value.toLowerCase();\n                } else if (lftype === \"f\") {\n                    value = value.toFixed((isNaN(precision)) ? 6 : precision);\n                    value = (ftype === \"F\") ? value.toUpperCase() : value.toLowerCase();\n                } else if (ftype === \"%\") {\n                    value *= 100;\n                    value = value.toFixed((isNaN(precision)) ? 6 : precision) + \"%\";\n                } else if (lftype === \"g\") {\n                    if (isNaN(precision)) {\n                        precision = 6;\n                    }\n                    precision = max(1, precision);\n                    exp = parseInt(value.toExponential(precision - 1).toLowerCase().split(\"e\")[1], 10);\n                    if (-4 <= exp && exp < precision) {\n                        value = value.toFixed(precision - 1 - exp);\n                    } else {\n                        value = value.toExponential(precision - 1);\n                    }\n                    value = value.replace(/0+$/g, \"\");\n                    if (value[value.length-1] === \".\") {\n                        value = value.slice(0, -1);\n                    }\n                    if (ftype === \"G\") {\n                        value = value.toUpperCase();\n                    }\n                }\n            } else {\n                value += \"\";\n                if (!isNaN(precision)) {\n                    value = value.slice(0, precision);\n                }\n            }\n            value += \"\";\n            if (is_numeric && sign) {\n                nval = Number(value);\n                is_positive = !isNaN(nval) && nval >= 0;\n                if (is_positive && (sign === \" \" || sign === \"+\")) {\n                    value = sign + value;\n                }\n            }\n            function repeat(char, num) {\n                return (new Array(num+1)).join(char);\n            };\n\n            repeat.__argnames__ = [\"char\", \"num\"];\n\n            if (is_numeric && width && width[0] === \"0\") {\n                width = width.slice(1);\n                _$rapyd$_unpack = [\"0\", \"=\"];\n                fill = _$rapyd$_unpack[0];\n                align = _$rapyd$_unpack[1];\n            }\n            width = parseInt(width || \"-1\", 10);\n            if (isNaN(width)) {\n                throw new ValueError(\"Invalid width specification: \" + width);\n            }\n            if (fill && value.length < width) {\n                if (align === \"<\") {\n                    value = value + repeat(fill, width - value.length);\n                } else if (align === \">\") {\n                    value = repeat(fill, width - value.length) + value;\n                } else if (align === \"^\") {\n                    left = Math.floor((width - value.length) / 2);\n                    right = width - left - value.length;\n                    value = repeat(fill, left) + value + repeat(fill, right);\n                } else if (align === \"=\") {\n                    if (_$rapyd$_in(value[0], \"+- \")) {\n                        value = value[0] + repeat(fill, width - value.length) + value.slice(1);\n                    } else {\n                        value = repeat(fill, width - value.length) + value;\n                    }\n                } else {\n                    throw new ValueError(\"Unrecognized alignment: \" + align);\n                }\n            }\n            return value;\n        };\n\n        apply_formatting.__argnames__ = [\"value\", \"format_spec\"];\n\n        function parse_markup(markup) {\n            var key, transformer, format_spec, _$rapyd$_chain_assign_temp, pos, state, ch;\n            _$rapyd$_chain_assign_temp = \"\";\n            key = _$rapyd$_chain_assign_temp;\n            transformer = _$rapyd$_chain_assign_temp;\n            format_spec = _$rapyd$_chain_assign_temp;\n;\n            pos = 0;\n            state = 0;\n            while (pos < markup.length) {\n                ch = markup[pos];\n                if (state === 0) {\n                    if (ch === \"!\") {\n                        state = 1;\n                    } else if (ch === \":\") {\n                        state = 2;\n                    } else {\n                        key += ch;\n                    }\n                } else if (state === 1) {\n                    if (ch === \":\") {\n                        state = 2;\n                    } else {\n                        transformer += ch;\n                    }\n                } else {\n                    format_spec += ch;\n                }\n                pos += 1;\n            }\n            return [key, transformer, format_spec];\n        };\n\n        parse_markup.__argnames__ = [\"markup\"];\n\n        function render_markup(markup) {\n            var _$rapyd$_unpack, key, transformer, format_spec, lkey, nvalue, object, ans;\n            _$rapyd$_unpack = parse_markup(markup);\n            key = _$rapyd$_unpack[0];\n            transformer = _$rapyd$_unpack[1];\n            format_spec = _$rapyd$_unpack[2];\n            if (transformer && ['a', 'r', 's'].indexOf(transformer) === -1) {\n                throw new ValueError(\"Unknown conversion specifier: \" + transformer);\n            }\n            lkey = key.length && key.split(/[.\\[]/, 1)[0];\n            if (lkey) {\n                explicit = true;\n                if (implicit) {\n                    throw new ValueError(\"cannot switch from automatic field numbering to manual field specification\");\n                }\n                nvalue = parseInt(lkey);\n                object = (isNaN(nvalue)) ? kwargs[lkey] : args[nvalue];\n                if (object === undefined) {\n                    if (isNaN(nvalue)) {\n                        throw new KeyError(lkey);\n                    }\n                    throw new IndexError(lkey);\n                }\n                object = resolve(key.slice(lkey.length), object);\n            } else {\n                implicit = true;\n                if (explicit) {\n                    throw new ValueError(\"cannot switch from manual field specification to automatic field numbering\");\n                }\n                if (idx >= args.length) {\n                    throw new IndexError(\"Not enough arguments to match template: \" + template);\n                }\n                object = args[idx];\n                idx += 1;\n            }\n            if (typeof object === \"function\") {\n                object = object();\n            }\n            ans = \"\" + object;\n            if (format_spec) {\n                ans = apply_formatting(ans, format_spec);\n            }\n            return ans;\n        };\n\n        render_markup.__argnames__ = [\"markup\"];\n\n        ans = \"\";\n        pos = 0;\n        in_brace = 0;\n        markup = \"\";\n        while (pos < template.length) {\n            ch = template[pos];\n            if (in_brace) {\n                if (ch === \"{\") {\n                    in_brace += 1;\n                    markup += \"{\";\n                } else if (ch === \"}\") {\n                    in_brace -= 1;\n                    if (in_brace > 0) {\n                        markup += \"}\";\n                    } else {\n                        ans += render_markup(markup);\n                    }\n                } else {\n                    markup += ch;\n                }\n            } else {\n                if (ch === \"{\") {\n                    if (template[pos + 1] === \"{\") {\n                        pos += 1;\n                        ans += \"{\";\n                    } else {\n                        in_brace = 1;\n                        markup = \"\";\n                    }\n                } else {\n                    ans += ch;\n                }\n            }\n            pos += 1;\n        }\n        if (in_brace) {\n            throw new ValueError(\"expected '}' before end of string\");\n        }\n        return ans;\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.capitalize = (function() {\n    var _$rapyd$_anonfunc = function (string) {\n        if (string) {\n            string = string[0].toUpperCase() + string.slice(1).toLowerCase();\n        }\n        return string;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.center = (function() {\n    var _$rapyd$_anonfunc = function (string, width, fill) {\n        var left, right;\n        left = Math.floor((width - string.length) / 2);\n        right = width - left - string.length;\n        fill = fill || \" \";\n        return new Array(left+1).join(fill) + string + new Array(right+1).join(fill);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"width\", \"fill\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.count = (function() {\n    var _$rapyd$_anonfunc = function (string, needle, start, end) {\n        var _$rapyd$_unpack, pos, step, ans;\n        start = start || 0;\n        end = end || string.length;\n        if (start < 0 || end < 0) {\n            string = string.slice(start, end);\n            _$rapyd$_unpack = [0, string.length];\n            start = _$rapyd$_unpack[0];\n            end = _$rapyd$_unpack[1];\n        }\n        pos = start;\n        step = needle.length;\n        ans = 0;\n        while (pos !== -1) {\n            pos = string.indexOf(needle, pos);\n            if (pos !== -1) {\n                ans += 1;\n                pos += step;\n            }\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"needle\", \"start\", \"end\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.endswith = (function() {\n    var _$rapyd$_anonfunc = function (string, suffixes, start, end) {\n        var q;\n        start = start || 0;\n        if (typeof suffixes === \"string\") {\n            suffixes = [suffixes];\n        }\n        if (end !== undefined) {\n            string = string.slice(0, end);\n        }\n        for (var i = 0; i < suffixes.length; i++) {\n            q = suffixes[i];\n            if (string.indexOf(q, Math.max(start, string.length - q.length)) !== -1) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"suffixes\", \"start\", \"end\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.startswith = (function() {\n    var _$rapyd$_anonfunc = function (string, prefixes, start, end) {\n        var prefix;\n        start = start || 0;\n        if (typeof prefixes === \"string\") {\n            prefixes = [prefixes];\n        }\n        for (var i = 0; i < prefixes.length; i++) {\n            prefix = prefixes[i];\n            end = (end === undefined) ? string.length : end;\n            if (end - start >= prefix.length && prefix === string.slice(start, start + prefix.length)) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"prefixes\", \"start\", \"end\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.find = (function() {\n    var _$rapyd$_anonfunc = function (string, needle, start, end) {\n        var ans;\n        while (start < 0) {\n            start += string.length;\n        }\n        ans = string.indexOf(needle, start);\n        if (end !== undefined && ans !== -1) {\n            while (end < 0) {\n                end += string.length;\n            }\n            if (ans >= end - needle.length) {\n                return -1;\n            }\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"needle\", \"start\", \"end\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.rfind = (function() {\n    var _$rapyd$_anonfunc = function (string, needle, start, end) {\n        var ans;\n        while (end < 0) {\n            end += string.length;\n        }\n        ans = string.lastIndexOf(needle, end - 1);\n        if (start !== undefined && ans !== -1) {\n            while (start < 0) {\n                start += string.length;\n            }\n            if (ans < start) {\n                return -1;\n            }\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"needle\", \"start\", \"end\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.index = (function() {\n    var _$rapyd$_anonfunc = function (string, needle, start, end) {\n        var ans;\n        ans = _$rapyd$_str.find.apply(null, arguments);\n        if (ans === -1) {\n            throw new ValueError(\"substring not found\");\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"needle\", \"start\", \"end\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.rindex = (function() {\n    var _$rapyd$_anonfunc = function (string, needle, start, end) {\n        var ans;\n        ans = _$rapyd$_str.rfind.apply(null, arguments);\n        if (ans === -1) {\n            throw new ValueError(\"substring not found\");\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"needle\", \"start\", \"end\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.islower = (function() {\n    var _$rapyd$_anonfunc = function (string) {\n        return string.length > 0 && string.toUpperCase() !== string;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.isupper = (function() {\n    var _$rapyd$_anonfunc = function (string) {\n        return string.length > 0 && string.toLowerCase() !== string;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.isspace = (function() {\n    var _$rapyd$_anonfunc = function (string) {\n        return string.length > 0 && /^\\s+$/.test(string);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.join = (function() {\n    var _$rapyd$_anonfunc = function (string, iterable) {\n        var ans, r;\n        if (Array.isArray(iterable)) {\n            return iterable.join(string);\n        }\n        ans = \"\";\n        r = iterable.next();\n        while (!r.done) {\n            if (ans) {\n                ans += string;\n            }\n            ans += r.value;\n            r = iterable.next();\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"iterable\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.ljust = (function() {\n    var _$rapyd$_anonfunc = function (string, width, fill) {\n        if (width > string.length) {\n            fill = fill || \" \";\n            string += new Array(width - string.length + 1).join(fill);\n        }\n        return string;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"width\", \"fill\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.rjust = (function() {\n    var _$rapyd$_anonfunc = function (string, width, fill) {\n        if (width > string.length) {\n            fill = fill || \" \";\n            string = new Array(width - string.length + 1).join(fill) + string;\n        }\n        return string;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"width\", \"fill\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.lower = (function() {\n    var _$rapyd$_anonfunc = function (string) {\n        return string.toLowerCase();\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.upper = (function() {\n    var _$rapyd$_anonfunc = function (string) {\n        return string.toUpperCase();\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.lstrip = (function() {\n    var _$rapyd$_anonfunc = function (string, chars) {\n        var pos;\n        pos = 0;\n        chars = chars || _$rapyd$_str.whitespace;\n        while (chars.indexOf(string[pos]) !== -1) {\n            pos += 1;\n        }\n        if (pos) {\n            string = string.slice(pos);\n        }\n        return string;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"chars\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.rstrip = (function() {\n    var _$rapyd$_anonfunc = function (string, chars) {\n        var pos;\n        pos = string.length - 1;\n        chars = chars || _$rapyd$_str.whitespace;\n        while (chars.indexOf(string[pos]) !== -1) {\n            pos -= 1;\n        }\n        if (pos < string.length - 1) {\n            string = string.slice(0, pos + 1);\n        }\n        return string;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"chars\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.strip = (function() {\n    var _$rapyd$_anonfunc = function (string, chars) {\n        return _$rapyd$_str.lstrip(_$rapyd$_str.rstrip(string, chars), chars);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"chars\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.partition = (function() {\n    var _$rapyd$_anonfunc = function (string, sep) {\n        var idx;\n        idx = string.indexOf(sep);\n        if (idx === -1) {\n            return [string, \"\", \"\"];\n        }\n        return [string.slice(0, idx), sep, string.slice(idx + sep.length)];\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"sep\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.rpartition = (function() {\n    var _$rapyd$_anonfunc = function (string, sep) {\n        var idx;\n        idx = string.lastIndexOf(sep);\n        if (idx === -1) {\n            return [\"\", \"\", string];\n        }\n        return [string.slice(0, idx), sep, string.slice(idx + sep.length)];\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"sep\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.replace = (function() {\n    var _$rapyd$_anonfunc = function (string, old, repl, count) {\n        var pos, idx;\n        if (count === 1) {\n            return string.replace(old, repl);\n        }\n        if (count < 1) {\n            return string;\n        }\n        count = count || Number.MAX_VALUE;\n        pos = 0;\n        while (count > 0) {\n            count -= 1;\n            idx = string.indexOf(old, pos);\n            if (idx === -1) {\n                break;\n            }\n            pos = idx + repl.length;\n            string = string.slice(0, idx) + repl + string.slice(idx + old.length);\n        }\n        return string;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"old\", \"repl\", \"count\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.split = (function() {\n    var _$rapyd$_anonfunc = function (string, sep, maxsplit) {\n        var ans, extra, parts;\n        if (maxsplit === 0) {\n            return _$rapyd$_list_decorate([ string ]);\n        }\n        if (sep === undefined || sep === null) {\n            if (maxsplit > 0) {\n                ans = string.split(/(\\s+)/);\n                extra = \"\";\n                parts = [];\n                for (var i = 0; i < ans.length; i++) {\n                    if (parts.length >= maxsplit + 1) {\n                        extra += ans[i];\n                    } else if (i % 2 === 0) {\n                        parts.push(ans[i]);\n                    }\n                }\n                parts[parts.length-1] += extra;\n                ans = parts;\n            } else {\n                ans = string.split(/\\s+/);\n            }\n        } else {\n            if (sep === \"\") {\n                throw new ValueError(\"empty separator\");\n            }\n            ans = string.split(sep);\n            if (maxsplit > 0 && ans.length > maxsplit) {\n                extra = ans.slice(maxsplit).join(sep);\n                ans = ans.slice(0, maxsplit);\n                ans.push(extra);\n            }\n        }\n        return _$rapyd$_list_decorate(ans);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"sep\", \"maxsplit\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.rsplit = (function() {\n    var _$rapyd$_anonfunc = function (string, sep, maxsplit) {\n        var ans, is_space, pos, current, spc, ch, end, _$rapyd$_chain_assign_temp, idx;\n        if (!maxsplit) {\n            return _$rapyd$_str.split.call(null, string, sep, maxsplit);\n        }\n        if (sep === undefined || sep === null) {\n            if (maxsplit > 0) {\n                ans = [];\n                is_space = /\\s/;\n                pos = string.length - 1;\n                current = \"\";\n                while (pos > -1 && maxsplit > 0) {\n                    spc = false;\n                    ch = string[pos];\n                    while (pos > -1 && is_space.test(ch)) {\n                        spc = true;\n                        ch = string[--pos];\n                    }\n                    if (spc) {\n                        if (current) {\n                            ans.push(current);\n                            maxsplit -= 1;\n                        }\n                        current = ch;\n                    } else {\n                        current += ch;\n                    }\n                    pos -= 1;\n                }\n                ans.push(string.slice(0, pos + 1) + current);\n                ans.reverse();\n            } else {\n                ans = string.split(/\\s+/);\n            }\n        } else {\n            if (sep === \"\") {\n                throw new ValueError(\"empty separator\");\n            }\n            ans = [];\n            _$rapyd$_chain_assign_temp = string.length;\n            pos = _$rapyd$_chain_assign_temp;\n            end = _$rapyd$_chain_assign_temp;\n;\n            while (pos > -1 && maxsplit > 0) {\n                maxsplit -= 1;\n                idx = string.lastIndexOf(sep, pos);\n                if (idx === -1) {\n                    break;\n                }\n                ans.push(string.slice(idx + sep.length, end));\n                pos = idx - 1;\n                end = idx;\n            }\n            ans.push(string.slice(0, end));\n            ans.reverse();\n        }\n        return _$rapyd$_list_decorate(ans);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"sep\", \"maxsplit\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.splitlines = (function() {\n    var _$rapyd$_anonfunc = function (string, keepends) {\n        var parts, ans;\n        if (keepends) {\n            parts = string.split(/((?:\\r?\\n)|\\r)/);\n            ans = [];\n            for (var i = 0; i < parts.length; i++) {\n                if (i % 2 === 0) {\n                    ans.push(parts[i]);\n                } else {\n                    ans[ans.length-1] += parts[i];\n                }\n            }\n        } else {\n            ans = string.split(/(?:\\r?\\n)|\\r/);\n        }\n        return _$rapyd$_list_decorate(ans);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"keepends\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.swapcase = (function() {\n    var _$rapyd$_anonfunc = function (string) {\n        var ans, a, b;\n        ans = new Array(string.length);\n        for (var i = 0; i < ans.length; i++) {\n            a = string[i];\n            b = a.toLowerCase();\n            if (a === b) {\n                b = a.toUpperCase();\n            }\n            ans[i] = b;\n        }\n        return ans.join(\"\");\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.zfill = (function() {\n    var _$rapyd$_anonfunc = function (string, width) {\n        if (width > string.length) {\n            string = new Array(width - string.length + 1).join(\"0\") + string;\n        }\n        return string;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"width\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.uchrs = (function() {\n    var _$rapyd$_anonfunc = function (string, with_positions) {\n        return (function(){\n            var _$rapyd$_d = {};\n            _$rapyd$_d[\"_string\"] = string;\n            _$rapyd$_d[\"_pos\"] = 0;\n            _$rapyd$_d[_$rapyd$_iterator_symbol] = (function() {\n                var _$rapyd$_anonfunc = function () {\n                    return this;\n                };\n                return _$rapyd$_anonfunc;\n            })();\n            _$rapyd$_d[\"next\"] = (function() {\n                var _$rapyd$_anonfunc = function () {\n                    var length, pos, value, ans, extra;\n                    length = this._string.length;\n                    if (this._pos >= length) {\n                        return {\n                            \"done\": true\n                        };\n                    }\n                    pos = this._pos;\n                    value = this._string.charCodeAt(this._pos++);\n                    ans = \"\\ufffd\";\n                    if (55296 <= value && value <= 56319) {\n                        if (this._pos < length) {\n                            extra = this._string.charCodeAt(this._pos++);\n                            if ((extra & 56320) === 56320) {\n                                ans = String.fromCharCode(value, extra);\n                            }\n                        }\n                    } else if ((value & 56320) !== 56320) {\n                        ans = String.fromCharCode(value);\n                    }\n                    if (with_positions) {\n                        return {\n                            \"done\": false,\n                            \"value\": _$rapyd$_list_decorate([ pos, ans ])\n                        };\n                    } else {\n                        return {\n                            \"done\": false,\n                            \"value\": ans\n                        };\n                    }\n                };\n                return _$rapyd$_anonfunc;\n            })();\n            return _$rapyd$_d;\n        })();\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"with_positions\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.uslice = (function() {\n    var _$rapyd$_anonfunc = function (string, start, end) {\n        var items, iterator, r;\n        items = [];\n        iterator = _$rapyd$_str.uchrs(string);\n        r = iterator.next();\n        while (!r.done) {\n            items.push(r.value);\n            r = iterator.next();\n        }\n        return items.slice(start || 0, (end === undefined) ? items.length : end).join(\"\");\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"start\", \"end\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.ulen = (function() {\n    var _$rapyd$_anonfunc = function (string) {\n        var iterator, r, ans;\n        iterator = _$rapyd$_str.uchrs(string);\n        r = iterator.next();\n        ans = 0;\n        while (!r.done) {\n            r = iterator.next();\n            ans += 1;\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.ascii_lowercase = \"abcdefghijklmnopqrstuvwxyz\";\n_$rapyd$_str.ascii_uppercase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n_$rapyd$_str.ascii_letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n_$rapyd$_str.digits = \"0123456789\";\n_$rapyd$_str.punctuation = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\n_$rapyd$_str.printable = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~ \\t\\n\\r\\u000b\\f\";\n_$rapyd$_str.whitespace = \" \\t\\n\\r\\u000b\\f\";\nvar str = _$rapyd$_str, repr = _$rapyd$_repr;;\n    var _$rapyd$_modules = {};\n    _$rapyd$_modules.utils = {};\n    _$rapyd$_modules.errors = {};\n    _$rapyd$_modules.unicode_aliases = {};\n    _$rapyd$_modules.ast = {};\n    _$rapyd$_modules.tokenizer = {};\n    _$rapyd$_modules.parse = {};\n    _$rapyd$_modules.output = {};\n    _$rapyd$_modules[\"output.stream\"] = {};\n    _$rapyd$_modules[\"output.statements\"] = {};\n    _$rapyd$_modules[\"output.exceptions\"] = {};\n    _$rapyd$_modules[\"output.functions\"] = {};\n    _$rapyd$_modules[\"output.classes\"] = {};\n    _$rapyd$_modules[\"output.literals\"] = {};\n    _$rapyd$_modules[\"output.loops\"] = {};\n    _$rapyd$_modules[\"output.modules\"] = {};\n    _$rapyd$_modules[\"output.operators\"] = {};\n    _$rapyd$_modules[\"output.utils\"] = {};\n    _$rapyd$_modules[\"output.codegen\"] = {};\n\n    (function(){\n        var __name__ = \"utils\";\n        var MAP;\n        function array_to_hash(a) {\n            var ret, i;\n            ret = Object.create(null);\n            for (var _$rapyd$_Index0 = 0; _$rapyd$_Index0 < len(a); _$rapyd$_Index0++) {\n                i = _$rapyd$_Index0;\n                ret[a[i]] = true;\n            }\n            return ret;\n        };\n\n        array_to_hash.__argnames__ = [\"a\"];\n\n        function slice(a, start) {\n            return Array.prototype.slice.call(a, start || 0);\n        };\n\n        slice.__argnames__ = [\"a\", \"start\"];\n\n        function characters(str_) {\n            return str_.split(\"\");\n        };\n\n        characters.__argnames__ = [\"str_\"];\n\n        function member(name, array) {\n            var i;\n            for (var _$rapyd$_Index1 = array.length - 1; _$rapyd$_Index1 > -1; _$rapyd$_Index1-=1) {\n                i = _$rapyd$_Index1;\n                if (array[i] === name) {\n                    return true;\n                }\n            }\n            return false;\n        };\n\n        member.__argnames__ = [\"name\", \"array\"];\n\n        function repeat_string(str_, i) {\n            var d;\n            if (i <= 0) {\n                return \"\";\n            }\n            if (i === 1) {\n                return str_;\n            }\n            d = repeat_string(str_, i >> 1);\n            d += d;\n            if (i & 1) {\n                d += str_;\n            }\n            return d;\n        };\n\n        repeat_string.__argnames__ = [\"str_\", \"i\"];\n\n        function DefaultsError() {\n            if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n            DefaultsError.prototype.__init__.apply(this, arguments);\n        }\n        _$rapyd$_extends(DefaultsError, ValueError);\n        DefaultsError.prototype.__init__ = function __init__(name, defs) {\n            var self = this;\n            ValueError.prototype.constructor.call(self, name + \" is not a supported option. Supported options are: \" + str(Object.keys(defs)));\n        };\n\n        DefaultsError.prototype.__init__.__argnames__ = [\"name\", \"defs\"];\n        DefaultsError.__argnames__ = DefaultsError.prototype.__init__.__argnames__;\n        DefaultsError.__handles_kwarg_interpolation__ = DefaultsError.prototype.__init__.__handles_kwarg_interpolation__;\n        DefaultsError.prototype.__repr__ = function __repr__ () {\n            return \"<\" + __name__ + \".\" + \"DefaultsError\" + \" #\" + this._$rapyd$_object_id + \">\";\n        };\n        DefaultsError.prototype.__str__ = function __str__ () {\n            return this.__repr__();\n        };\n\n        function defaults(args, defs, croak) {\n            var ret, i;\n            if (args === true) {\n                args = {};\n            }\n            ret = args || {};\n            if (croak) {\n                var _$rapyd$_Iter2 = _$rapyd$_Iterable(ret);\n                for (var _$rapyd$_Index2 = 0; _$rapyd$_Index2 < _$rapyd$_Iter2.length; _$rapyd$_Index2++) {\n                    i = _$rapyd$_Iter2[_$rapyd$_Index2];\n                    if (!defs.hasOwnProperty(i)) {\n                        throw new DefaultsError(i, defs);\n                    }\n                }\n            }\n            var _$rapyd$_Iter3 = _$rapyd$_Iterable(defs);\n            for (var _$rapyd$_Index3 = 0; _$rapyd$_Index3 < _$rapyd$_Iter3.length; _$rapyd$_Index3++) {\n                i = _$rapyd$_Iter3[_$rapyd$_Index3];\n                ret[i] = (args && args.hasOwnProperty(i)) ? args[i] : defs[i];\n            }\n            return ret;\n        };\n\n        defaults.__argnames__ = [\"args\", \"defs\", \"croak\"];\n\n        function merge(obj, ext) {\n            var i;\n            var _$rapyd$_Iter4 = _$rapyd$_Iterable(ext);\n            for (var _$rapyd$_Index4 = 0; _$rapyd$_Index4 < _$rapyd$_Iter4.length; _$rapyd$_Index4++) {\n                i = _$rapyd$_Iter4[_$rapyd$_Index4];\n                obj[i] = ext[i];\n            }\n            return obj;\n        };\n\n        merge.__argnames__ = [\"obj\", \"ext\"];\n\n        function noop() {\n        };\n\n        MAP = (function() {\n            var _$rapyd$_anonfunc = function () {\n                var skip, _$rapyd$_chain_assign_temp;\n                function MAP(a, f, backwards) {\n                    var ret, top, i;\n                    ret = _$rapyd$_list_decorate([]);\n                    top = _$rapyd$_list_decorate([]);\n                    function doit() {\n                        var val, is_last;\n                        val = f(a[i], i);\n                        is_last = val instanceof Last;\n                        if (is_last) {\n                            val = val.v;\n                        }\n                        if (val instanceof AtTop) {\n                            val = val.v;\n                            if (val instanceof Splice) {\n                                top.push.apply(top, (backwards) ? val.v.slice().reverse() : val.v);\n                            } else {\n                                top.push(val);\n                            }\n                        } else if (val !== skip) {\n                            if (val instanceof Splice) {\n                                ret.push.apply(ret, (backwards) ? val.v.slice().reverse() : val.v);\n                            } else {\n                                ret.push(val);\n                            }\n                        }\n                        return is_last;\n                    };\n\n                    if (Array.isArray(a)) {\n                        if (backwards) {\n                            for (var _$rapyd$_Index5 = a.length - 1; _$rapyd$_Index5 > -1; _$rapyd$_Index5-=1) {\n                                i = _$rapyd$_Index5;\n                                if (doit()) {\n                                    break;\n                                }\n                            }\n                            ret.reverse();\n                            top.reverse();\n                        } else {\n                            for (var _$rapyd$_Index6 = 0; _$rapyd$_Index6 < len(a); _$rapyd$_Index6++) {\n                                i = _$rapyd$_Index6;\n                                if (doit()) {\n                                    break;\n                                }\n                            }\n                        }\n                    } else {\n                        var _$rapyd$_Iter7 = _$rapyd$_Iterable(a);\n                        for (var _$rapyd$_Index7 = 0; _$rapyd$_Index7 < _$rapyd$_Iter7.length; _$rapyd$_Index7++) {\n                            i = _$rapyd$_Iter7[_$rapyd$_Index7];\n                            if (doit()) {\n                                break;\n                            }\n                        }\n                    }\n                    return top.concat(ret);\n                };\n\n                MAP.__argnames__ = [\"a\", \"f\", \"backwards\"];\n\n                MAP.at_top = (function() {\n                    var _$rapyd$_anonfunc = function (val) {\n                        return new AtTop(val);\n                    };\n\n                    _$rapyd$_anonfunc.__argnames__ = [\"val\"];\n                    return _$rapyd$_anonfunc;\n                })();\n                MAP.splice = (function() {\n                    var _$rapyd$_anonfunc = function (val) {\n                        return new Splice(val);\n                    };\n\n                    _$rapyd$_anonfunc.__argnames__ = [\"val\"];\n                    return _$rapyd$_anonfunc;\n                })();\n                MAP.last = (function() {\n                    var _$rapyd$_anonfunc = function (val) {\n                        return new Last(val);\n                    };\n\n                    _$rapyd$_anonfunc.__argnames__ = [\"val\"];\n                    return _$rapyd$_anonfunc;\n                })();\n                _$rapyd$_chain_assign_temp = {};\n                skip = _$rapyd$_chain_assign_temp;\n                MAP.skip = _$rapyd$_chain_assign_temp;\n;\n                function AtTop(val) {\n                    this.v = val;\n                };\n\n                AtTop.__argnames__ = [\"val\"];\n\n                function Splice(val) {\n                    this.v = val;\n                };\n\n                Splice.__argnames__ = [\"val\"];\n\n                function Last(val) {\n                    this.v = val;\n                };\n\n                Last.__argnames__ = [\"val\"];\n\n                return MAP;\n            };\n            return _$rapyd$_anonfunc;\n        })().call(this);\n        function push_uniq(array, el) {\n            if (array.indexOf(el) < 0) {\n                array.push(el);\n            }\n        };\n\n        push_uniq.__argnames__ = [\"array\", \"el\"];\n\n        function string_template(text, props) {\n            return text.replace(/\\{(.+?)\\}/g, (function() {\n                var _$rapyd$_anonfunc = function (str_, p) {\n                    return props[p];\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"str_\", \"p\"];\n                return _$rapyd$_anonfunc;\n            })());\n        };\n\n        string_template.__argnames__ = [\"text\", \"props\"];\n\n        function remove(array, el) {\n            var i;\n            for (var _$rapyd$_Index8 = array.length - 1; _$rapyd$_Index8 > -1; _$rapyd$_Index8-=1) {\n                i = _$rapyd$_Index8;\n                if (array[i] === el) {\n                    array.splice(i, 1);\n                }\n            }\n        };\n\n        remove.__argnames__ = [\"array\", \"el\"];\n\n        function mergeSort(array, cmp) {\n            if (array.length < 2) {\n                return array.slice();\n            }\n            function merge(a, b) {\n                var r, ai, bi, i;\n                r = _$rapyd$_list_decorate([]);\n                ai = 0;\n                bi = 0;\n                i = 0;\n                while (ai < a.length && bi < b.length) {\n                    if (cmp(a[ai], b[bi]) <= 0) {\n                        r[i] = a[ai];\n                        ai += 1;\n                    } else {\n                        r[i] = b[bi];\n                        bi += 1;\n                    }\n                    i += 1;\n                }\n                if (ai < a.length) {\n                    r.push.apply(r, a.slice(ai));\n                }\n                if (bi < b.length) {\n                    r.push.apply(r, b.slice(bi));\n                }\n                return r;\n            };\n\n            merge.__argnames__ = [\"a\", \"b\"];\n\n            function _ms(a) {\n                var m, left, right;\n                if (a.length <= 1) {\n                    return a;\n                }\n                m = Math.floor(a.length / 2);\n                left = a.slice(0, m);\n                right = a.slice(m);\n                left = _ms(left);\n                right = _ms(right);\n                return merge(left, right);\n            };\n\n            _ms.__argnames__ = [\"a\"];\n\n            return _ms(array);\n        };\n\n        mergeSort.__argnames__ = [\"array\", \"cmp\"];\n\n        function set_difference(a, b) {\n            return a.filter((function() {\n                var _$rapyd$_anonfunc = function (el) {\n                    return b.indexOf(el) < 0;\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"el\"];\n                return _$rapyd$_anonfunc;\n            })());\n        };\n\n        set_difference.__argnames__ = [\"a\", \"b\"];\n\n        function set_intersection(a, b) {\n            return a.filter((function() {\n                var _$rapyd$_anonfunc = function (el) {\n                    return b.indexOf(el) >= 0;\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"el\"];\n                return _$rapyd$_anonfunc;\n            })());\n        };\n\n        set_intersection.__argnames__ = [\"a\", \"b\"];\n\n        function make_predicate(words) {\n            var a, k;\n            if (!Array.isArray(words)) {\n                words = words.split(\" \");\n            }\n            if (typeof Set === \"function\") {\n                a = new Set(words);\n                return (function() {\n                    var _$rapyd$_anonfunc = function (x) {\n                        return a.has(x);\n                    };\n\n                    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n                    return _$rapyd$_anonfunc;\n                })();\n            } else {\n                a = {};\n                var _$rapyd$_Iter9 = _$rapyd$_Iterable(words);\n                for (var _$rapyd$_Index9 = 0; _$rapyd$_Index9 < _$rapyd$_Iter9.length; _$rapyd$_Index9++) {\n                    k = _$rapyd$_Iter9[_$rapyd$_Index9];\n                    a[k] = true;\n                }\n                return (function() {\n                    var _$rapyd$_anonfunc = function (x) {\n                        return a.hasOwnProperty(x);\n                    };\n\n                    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n                    return _$rapyd$_anonfunc;\n                })();\n            }\n        };\n\n        make_predicate.__argnames__ = [\"words\"];\n\n        _$rapyd$_modules.utils.MAP = MAP;\n        _$rapyd$_modules.utils.array_to_hash = array_to_hash;\n        _$rapyd$_modules.utils.slice = slice;\n        _$rapyd$_modules.utils.characters = characters;\n        _$rapyd$_modules.utils.member = member;\n        _$rapyd$_modules.utils.repeat_string = repeat_string;\n        _$rapyd$_modules.utils.DefaultsError = DefaultsError;\n        _$rapyd$_modules.utils.defaults = defaults;\n        _$rapyd$_modules.utils.merge = merge;\n        _$rapyd$_modules.utils.noop = noop;\n        _$rapyd$_modules.utils.push_uniq = push_uniq;\n        _$rapyd$_modules.utils.string_template = string_template;\n        _$rapyd$_modules.utils.remove = remove;\n        _$rapyd$_modules.utils.mergeSort = mergeSort;\n        _$rapyd$_modules.utils.set_difference = set_difference;\n        _$rapyd$_modules.utils.set_intersection = set_intersection;\n        _$rapyd$_modules.utils.make_predicate = make_predicate;\n    })();\n\n    (function(){\n        var __name__ = \"errors\";\n        function SyntaxError() {\n            if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n            SyntaxError.prototype.__init__.apply(this, arguments);\n        }\n        _$rapyd$_extends(SyntaxError, Error);\n        SyntaxError.prototype.__init__ = function __init__(message, filename, line, col, pos, is_eof) {\n            var self = this;\n            self.stack = (new Error).stack;\n            self.message = message;\n            self.line = line;\n            self.col = col;\n            self.pos = pos;\n            self.is_eof = is_eof;\n            self.filename = filename;\n            self.lineNumber = line;\n            self.fileName = filename;\n        };\n\n        SyntaxError.prototype.__init__.__argnames__ = [\"message\", \"filename\", \"line\", \"col\", \"pos\", \"is_eof\"];\n        SyntaxError.__argnames__ = SyntaxError.prototype.__init__.__argnames__;\n        SyntaxError.__handles_kwarg_interpolation__ = SyntaxError.prototype.__init__.__handles_kwarg_interpolation__;\n        SyntaxError.prototype.toString = function toString() {\n            var self = this;\n            var ans;\n            ans = self.message + \" (line: \" + self.line + \", col: \" + self.col + \", pos: \" + self.pos + \")\";\n            if (self.filename) {\n                ans = self.filename + \":\" + ans;\n            }\n            if (self.stack) {\n                ans += \"\\n\\n\" + self.stack;\n            }\n            return ans;\n        };\n\n        SyntaxError.prototype.toString.__argnames__ = [];\n        SyntaxError.prototype.__repr__ = function __repr__ () {\n            return \"<\" + __name__ + \".\" + \"SyntaxError\" + \" #\" + this._$rapyd$_object_id + \">\";\n        };\n        SyntaxError.prototype.__str__ = function __str__ () {\n            return this.__repr__();\n        };\n\n        function ImportError() {\n            if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n            ImportError.prototype.__init__.apply(this, arguments);\n        }\n        _$rapyd$_extends(ImportError, SyntaxError);\n        ImportError.prototype.__init__ = function __init__ () {\n            SyntaxError.prototype.__init__ && SyntaxError.prototype.__init__.apply(this, arguments);\n        };\n        ImportError.prototype.__repr__ = function __repr__ () {\n            return \"<\" + __name__ + \".\" + \"ImportError\" + \" #\" + this._$rapyd$_object_id + \">\";\n        };\n        ImportError.prototype.__str__ = function __str__ () {\n            return this.__repr__();\n        };\n        \n\n        _$rapyd$_modules.errors.SyntaxError = SyntaxError;\n        _$rapyd$_modules.errors.ImportError = ImportError;\n    })();\n\n    (function(){\n        var __name__ = \"unicode_aliases\";\n        var DB, ALIAS_MAP;\n        DB = \"\\n# NameAliases-8.0.0.txt\\n# Date: 2014-11-19, 01:30:00 GMT [KW, LI]\\n#\\n# This file is a normative contributory data file in the\\n# Unicode Character Database.\\n#\\n# Copyright (c) 2005-2014 Unicode, Inc.\\n# For terms of use, see http://www.unicode.org/terms_of_use.html\\n#\\n# This file defines the formal name aliases for Unicode characters.\\n#\\n# For informative aliases, see NamesList.txt\\n#\\n# The formal name aliases are divided into five types, each with a distinct label.\\n#\\n# Type Labels:\\n#\\n# 1. correction\\n#      Corrections for serious problems in the character names\\n# 2. control\\n#      ISO 6429 names for C0 and C1 control functions, and other\\n#      commonly occurring names for control codes\\n# 3. alternate\\n#      A few widely used alternate names for format characters\\n# 4. figment\\n#      Several documented labels for C1 control code points which\\n#      were never actually approved in any standard\\n# 5. abbreviation\\n#      Commonly occurring abbreviations (or acronyms) for control codes,\\n#      format characters, spaces, and variation selectors\\n#\\n# The formal name aliases are part of the Unicode character namespace, which\\n# includes the character names and the names of named character sequences.\\n# The inclusion of ISO 6429 names and other commonly occurring names and\\n# abbreviations for control codes and format characters as formal name aliases\\n# is to help avoid name collisions between Unicode character names and the\\n# labels which commonly appear in text and/or in implementations such as regex, for\\n# control codes (which for historical reasons have no Unicode character name)\\n# or for format characters.\\n#\\n# For documentation, see NamesList.html and http://www.unicode.org/reports/tr44/\\n#\\n# FORMAT\\n#\\n# Each line has three fields, as described here:\\n#\\n# First field:  Code point\\n# Second field: Alias\\n# Third field:  Type\\n#\\n# The type labels used are defined above. As for property values, comparisons\\n# of type labels should ignore case.\\n#\\n# The type labels can be mapped to other strings for display, if desired.\\n#\\n# In case multiple aliases are assigned, additional aliases\\n# are provided on separate lines. Parsers of this data file should\\n# take note that the same code point can (and does) occur more than once.\\n#\\n# Note that currently the only instances of multiple aliases of the same\\n# type for a single code point are either of type \\\"control\\\" or \\\"abbreviation\\\".\\n# An alias of type \\\"abbreviation\\\" can, in principle, be added for any code\\n# point, although currently aliases of type \\\"correction\\\" do not have\\n# any additional aliases of type \\\"abbreviation\\\". Such relationships\\n# are not enforced by stability policies.\\n#\\n#-----------------------------------------------------------------\\n\\n0000;NULL;control\\n0000;NUL;abbreviation\\n0001;START OF HEADING;control\\n0001;SOH;abbreviation\\n0002;START OF TEXT;control\\n0002;STX;abbreviation\\n0003;END OF TEXT;control\\n0003;ETX;abbreviation\\n0004;END OF TRANSMISSION;control\\n0004;EOT;abbreviation\\n0005;ENQUIRY;control\\n0005;ENQ;abbreviation\\n0006;ACKNOWLEDGE;control\\n0006;ACK;abbreviation\\n\\n# Note that no formal name alias for the ISO 6429 \\\"BELL\\\" is\\n# provided for U+0007, because of the existing name collision\\n# with U+1F514 BELL.\\n\\n0007;ALERT;control\\n0007;BEL;abbreviation\\n\\n0008;BACKSPACE;control\\n0008;BS;abbreviation\\n0009;CHARACTER TABULATION;control\\n0009;HORIZONTAL TABULATION;control\\n0009;HT;abbreviation\\n0009;TAB;abbreviation\\n000A;LINE FEED;control\\n000A;NEW LINE;control\\n000A;END OF LINE;control\\n000A;LF;abbreviation\\n000A;NL;abbreviation\\n000A;EOL;abbreviation\\n000B;LINE TABULATION;control\\n000B;VERTICAL TABULATION;control\\n000B;VT;abbreviation\\n000C;FORM FEED;control\\n000C;FF;abbreviation\\n000D;CARRIAGE RETURN;control\\n000D;CR;abbreviation\\n000E;SHIFT OUT;control\\n000E;LOCKING-SHIFT ONE;control\\n000E;SO;abbreviation\\n000F;SHIFT IN;control\\n000F;LOCKING-SHIFT ZERO;control\\n000F;SI;abbreviation\\n0010;DATA LINK ESCAPE;control\\n0010;DLE;abbreviation\\n0011;DEVICE CONTROL ONE;control\\n0011;DC1;abbreviation\\n0012;DEVICE CONTROL TWO;control\\n0012;DC2;abbreviation\\n0013;DEVICE CONTROL THREE;control\\n0013;DC3;abbreviation\\n0014;DEVICE CONTROL FOUR;control\\n0014;DC4;abbreviation\\n0015;NEGATIVE ACKNOWLEDGE;control\\n0015;NAK;abbreviation\\n0016;SYNCHRONOUS IDLE;control\\n0016;SYN;abbreviation\\n0017;END OF TRANSMISSION BLOCK;control\\n0017;ETB;abbreviation\\n0018;CANCEL;control\\n0018;CAN;abbreviation\\n0019;END OF MEDIUM;control\\n0019;EOM;abbreviation\\n001A;SUBSTITUTE;control\\n001A;SUB;abbreviation\\n001B;ESCAPE;control\\n001B;ESC;abbreviation\\n001C;INFORMATION SEPARATOR FOUR;control\\n001C;FILE SEPARATOR;control\\n001C;FS;abbreviation\\n001D;INFORMATION SEPARATOR THREE;control\\n001D;GROUP SEPARATOR;control\\n001D;GS;abbreviation\\n001E;INFORMATION SEPARATOR TWO;control\\n001E;RECORD SEPARATOR;control\\n001E;RS;abbreviation\\n001F;INFORMATION SEPARATOR ONE;control\\n001F;UNIT SEPARATOR;control\\n001F;US;abbreviation\\n0020;SP;abbreviation\\n007F;DELETE;control\\n007F;DEL;abbreviation\\n\\n# PADDING CHARACTER and HIGH OCTET PRESET represent\\n# architectural concepts initially proposed for early\\n# drafts of ISO/IEC 10646-1. They were never actually\\n# approved or standardized: hence their designation\\n# here as the \\\"figment\\\" type. Formal name aliases\\n# (and corresponding abbreviations) for these code\\n# points are included here because these names leaked\\n# out from the draft documents and were published in\\n# at least one RFC whose names for code points was\\n# implemented in Perl regex expressions.\\n\\n0080;PADDING CHARACTER;figment\\n0080;PAD;abbreviation\\n0081;HIGH OCTET PRESET;figment\\n0081;HOP;abbreviation\\n\\n0082;BREAK PERMITTED HERE;control\\n0082;BPH;abbreviation\\n0083;NO BREAK HERE;control\\n0083;NBH;abbreviation\\n0084;INDEX;control\\n0084;IND;abbreviation\\n0085;NEXT LINE;control\\n0085;NEL;abbreviation\\n0086;START OF SELECTED AREA;control\\n0086;SSA;abbreviation\\n0087;END OF SELECTED AREA;control\\n0087;ESA;abbreviation\\n0088;CHARACTER TABULATION SET;control\\n0088;HORIZONTAL TABULATION SET;control\\n0088;HTS;abbreviation\\n0089;CHARACTER TABULATION WITH JUSTIFICATION;control\\n0089;HORIZONTAL TABULATION WITH JUSTIFICATION;control\\n0089;HTJ;abbreviation\\n008A;LINE TABULATION SET;control\\n008A;VERTICAL TABULATION SET;control\\n008A;VTS;abbreviation\\n008B;PARTIAL LINE FORWARD;control\\n008B;PARTIAL LINE DOWN;control\\n008B;PLD;abbreviation\\n008C;PARTIAL LINE BACKWARD;control\\n008C;PARTIAL LINE UP;control\\n008C;PLU;abbreviation\\n008D;REVERSE LINE FEED;control\\n008D;REVERSE INDEX;control\\n008D;RI;abbreviation\\n008E;SINGLE SHIFT TWO;control\\n008E;SINGLE-SHIFT-2;control\\n008E;SS2;abbreviation\\n008F;SINGLE SHIFT THREE;control\\n008F;SINGLE-SHIFT-3;control\\n008F;SS3;abbreviation\\n0090;DEVICE CONTROL STRING;control\\n0090;DCS;abbreviation\\n0091;PRIVATE USE ONE;control\\n0091;PRIVATE USE-1;control\\n0091;PU1;abbreviation\\n0092;PRIVATE USE TWO;control\\n0092;PRIVATE USE-2;control\\n0092;PU2;abbreviation\\n0093;SET TRANSMIT STATE;control\\n0093;STS;abbreviation\\n0094;CANCEL CHARACTER;control\\n0094;CCH;abbreviation\\n0095;MESSAGE WAITING;control\\n0095;MW;abbreviation\\n0096;START OF GUARDED AREA;control\\n0096;START OF PROTECTED AREA;control\\n0096;SPA;abbreviation\\n0097;END OF GUARDED AREA;control\\n0097;END OF PROTECTED AREA;control\\n0097;EPA;abbreviation\\n0098;START OF STRING;control\\n0098;SOS;abbreviation\\n\\n# SINGLE GRAPHIC CHARACTER INTRODUCER is another\\n# architectural concept from early drafts of ISO/IEC 10646-1\\n# which was never approved and standardized.\\n\\n0099;SINGLE GRAPHIC CHARACTER INTRODUCER;figment\\n0099;SGC;abbreviation\\n\\n009A;SINGLE CHARACTER INTRODUCER;control\\n009A;SCI;abbreviation\\n009B;CONTROL SEQUENCE INTRODUCER;control\\n009B;CSI;abbreviation\\n009C;STRING TERMINATOR;control\\n009C;ST;abbreviation\\n009D;OPERATING SYSTEM COMMAND;control\\n009D;OSC;abbreviation\\n009E;PRIVACY MESSAGE;control\\n009E;PM;abbreviation\\n009F;APPLICATION PROGRAM COMMAND;control\\n009F;APC;abbreviation\\n00A0;NBSP;abbreviation\\n00AD;SHY;abbreviation\\n01A2;LATIN CAPITAL LETTER GHA;correction\\n01A3;LATIN SMALL LETTER GHA;correction\\n034F;CGJ;abbreviation\\n061C;ALM;abbreviation\\n0709;SYRIAC SUBLINEAR COLON SKEWED LEFT;correction\\n0CDE;KANNADA LETTER LLLA;correction\\n0E9D;LAO LETTER FO FON;correction\\n0E9F;LAO LETTER FO FAY;correction\\n0EA3;LAO LETTER RO;correction\\n0EA5;LAO LETTER LO;correction\\n0FD0;TIBETAN MARK BKA- SHOG GI MGO RGYAN;correction\\n180B;FVS1;abbreviation\\n180C;FVS2;abbreviation\\n180D;FVS3;abbreviation\\n180E;MVS;abbreviation\\n200B;ZWSP;abbreviation\\n200C;ZWNJ;abbreviation\\n200D;ZWJ;abbreviation\\n200E;LRM;abbreviation\\n200F;RLM;abbreviation\\n202A;LRE;abbreviation\\n202B;RLE;abbreviation\\n202C;PDF;abbreviation\\n202D;LRO;abbreviation\\n202E;RLO;abbreviation\\n202F;NNBSP;abbreviation\\n205F;MMSP;abbreviation\\n2060;WJ;abbreviation\\n2066;LRI;abbreviation\\n2067;RLI;abbreviation\\n2068;FSI;abbreviation\\n2069;PDI;abbreviation\\n2118;WEIERSTRASS ELLIPTIC FUNCTION;correction\\n2448;MICR ON US SYMBOL;correction\\n2449;MICR DASH SYMBOL;correction\\n2B7A;LEFTWARDS TRIANGLE-HEADED ARROW WITH DOUBLE VERTICAL STROKE;correction\\n2B7C;RIGHTWARDS TRIANGLE-HEADED ARROW WITH DOUBLE VERTICAL STROKE;correction\\nA015;YI SYLLABLE ITERATION MARK;correction\\nFE18;PRESENTATION FORM FOR VERTICAL RIGHT WHITE LENTICULAR BRACKET;correction\\nFE00;VS1;abbreviation\\nFE01;VS2;abbreviation\\nFE02;VS3;abbreviation\\nFE03;VS4;abbreviation\\nFE04;VS5;abbreviation\\nFE05;VS6;abbreviation\\nFE06;VS7;abbreviation\\nFE07;VS8;abbreviation\\nFE08;VS9;abbreviation\\nFE09;VS10;abbreviation\\nFE0A;VS11;abbreviation\\nFE0B;VS12;abbreviation\\nFE0C;VS13;abbreviation\\nFE0D;VS14;abbreviation\\nFE0E;VS15;abbreviation\\nFE0F;VS16;abbreviation\\nFEFF;BYTE ORDER MARK;alternate\\nFEFF;BOM;abbreviation\\nFEFF;ZWNBSP;abbreviation\\n122D4;CUNEIFORM SIGN NU11 TENU;correction\\n122D5;CUNEIFORM SIGN NU11 OVER NU11 BUR OVER BUR;correction\\n1D0C5;BYZANTINE MUSICAL SYMBOL FTHORA SKLIRON CHROMA VASIS;correction\\nE0100;VS17;abbreviation\\nE0101;VS18;abbreviation\\nE0102;VS19;abbreviation\\nE0103;VS20;abbreviation\\nE0104;VS21;abbreviation\\nE0105;VS22;abbreviation\\nE0106;VS23;abbreviation\\nE0107;VS24;abbreviation\\nE0108;VS25;abbreviation\\nE0109;VS26;abbreviation\\nE010A;VS27;abbreviation\\nE010B;VS28;abbreviation\\nE010C;VS29;abbreviation\\nE010D;VS30;abbreviation\\nE010E;VS31;abbreviation\\nE010F;VS32;abbreviation\\nE0110;VS33;abbreviation\\nE0111;VS34;abbreviation\\nE0112;VS35;abbreviation\\nE0113;VS36;abbreviation\\nE0114;VS37;abbreviation\\nE0115;VS38;abbreviation\\nE0116;VS39;abbreviation\\nE0117;VS40;abbreviation\\nE0118;VS41;abbreviation\\nE0119;VS42;abbreviation\\nE011A;VS43;abbreviation\\nE011B;VS44;abbreviation\\nE011C;VS45;abbreviation\\nE011D;VS46;abbreviation\\nE011E;VS47;abbreviation\\nE011F;VS48;abbreviation\\nE0120;VS49;abbreviation\\nE0121;VS50;abbreviation\\nE0122;VS51;abbreviation\\nE0123;VS52;abbreviation\\nE0124;VS53;abbreviation\\nE0125;VS54;abbreviation\\nE0126;VS55;abbreviation\\nE0127;VS56;abbreviation\\nE0128;VS57;abbreviation\\nE0129;VS58;abbreviation\\nE012A;VS59;abbreviation\\nE012B;VS60;abbreviation\\nE012C;VS61;abbreviation\\nE012D;VS62;abbreviation\\nE012E;VS63;abbreviation\\nE012F;VS64;abbreviation\\nE0130;VS65;abbreviation\\nE0131;VS66;abbreviation\\nE0132;VS67;abbreviation\\nE0133;VS68;abbreviation\\nE0134;VS69;abbreviation\\nE0135;VS70;abbreviation\\nE0136;VS71;abbreviation\\nE0137;VS72;abbreviation\\nE0138;VS73;abbreviation\\nE0139;VS74;abbreviation\\nE013A;VS75;abbreviation\\nE013B;VS76;abbreviation\\nE013C;VS77;abbreviation\\nE013D;VS78;abbreviation\\nE013E;VS79;abbreviation\\nE013F;VS80;abbreviation\\nE0140;VS81;abbreviation\\nE0141;VS82;abbreviation\\nE0142;VS83;abbreviation\\nE0143;VS84;abbreviation\\nE0144;VS85;abbreviation\\nE0145;VS86;abbreviation\\nE0146;VS87;abbreviation\\nE0147;VS88;abbreviation\\nE0148;VS89;abbreviation\\nE0149;VS90;abbreviation\\nE014A;VS91;abbreviation\\nE014B;VS92;abbreviation\\nE014C;VS93;abbreviation\\nE014D;VS94;abbreviation\\nE014E;VS95;abbreviation\\nE014F;VS96;abbreviation\\nE0150;VS97;abbreviation\\nE0151;VS98;abbreviation\\nE0152;VS99;abbreviation\\nE0153;VS100;abbreviation\\nE0154;VS101;abbreviation\\nE0155;VS102;abbreviation\\nE0156;VS103;abbreviation\\nE0157;VS104;abbreviation\\nE0158;VS105;abbreviation\\nE0159;VS106;abbreviation\\nE015A;VS107;abbreviation\\nE015B;VS108;abbreviation\\nE015C;VS109;abbreviation\\nE015D;VS110;abbreviation\\nE015E;VS111;abbreviation\\nE015F;VS112;abbreviation\\nE0160;VS113;abbreviation\\nE0161;VS114;abbreviation\\nE0162;VS115;abbreviation\\nE0163;VS116;abbreviation\\nE0164;VS117;abbreviation\\nE0165;VS118;abbreviation\\nE0166;VS119;abbreviation\\nE0167;VS120;abbreviation\\nE0168;VS121;abbreviation\\nE0169;VS122;abbreviation\\nE016A;VS123;abbreviation\\nE016B;VS124;abbreviation\\nE016C;VS125;abbreviation\\nE016D;VS126;abbreviation\\nE016E;VS127;abbreviation\\nE016F;VS128;abbreviation\\nE0170;VS129;abbreviation\\nE0171;VS130;abbreviation\\nE0172;VS131;abbreviation\\nE0173;VS132;abbreviation\\nE0174;VS133;abbreviation\\nE0175;VS134;abbreviation\\nE0176;VS135;abbreviation\\nE0177;VS136;abbreviation\\nE0178;VS137;abbreviation\\nE0179;VS138;abbreviation\\nE017A;VS139;abbreviation\\nE017B;VS140;abbreviation\\nE017C;VS141;abbreviation\\nE017D;VS142;abbreviation\\nE017E;VS143;abbreviation\\nE017F;VS144;abbreviation\\nE0180;VS145;abbreviation\\nE0181;VS146;abbreviation\\nE0182;VS147;abbreviation\\nE0183;VS148;abbreviation\\nE0184;VS149;abbreviation\\nE0185;VS150;abbreviation\\nE0186;VS151;abbreviation\\nE0187;VS152;abbreviation\\nE0188;VS153;abbreviation\\nE0189;VS154;abbreviation\\nE018A;VS155;abbreviation\\nE018B;VS156;abbreviation\\nE018C;VS157;abbreviation\\nE018D;VS158;abbreviation\\nE018E;VS159;abbreviation\\nE018F;VS160;abbreviation\\nE0190;VS161;abbreviation\\nE0191;VS162;abbreviation\\nE0192;VS163;abbreviation\\nE0193;VS164;abbreviation\\nE0194;VS165;abbreviation\\nE0195;VS166;abbreviation\\nE0196;VS167;abbreviation\\nE0197;VS168;abbreviation\\nE0198;VS169;abbreviation\\nE0199;VS170;abbreviation\\nE019A;VS171;abbreviation\\nE019B;VS172;abbreviation\\nE019C;VS173;abbreviation\\nE019D;VS174;abbreviation\\nE019E;VS175;abbreviation\\nE019F;VS176;abbreviation\\nE01A0;VS177;abbreviation\\nE01A1;VS178;abbreviation\\nE01A2;VS179;abbreviation\\nE01A3;VS180;abbreviation\\nE01A4;VS181;abbreviation\\nE01A5;VS182;abbreviation\\nE01A6;VS183;abbreviation\\nE01A7;VS184;abbreviation\\nE01A8;VS185;abbreviation\\nE01A9;VS186;abbreviation\\nE01AA;VS187;abbreviation\\nE01AB;VS188;abbreviation\\nE01AC;VS189;abbreviation\\nE01AD;VS190;abbreviation\\nE01AE;VS191;abbreviation\\nE01AF;VS192;abbreviation\\nE01B0;VS193;abbreviation\\nE01B1;VS194;abbreviation\\nE01B2;VS195;abbreviation\\nE01B3;VS196;abbreviation\\nE01B4;VS197;abbreviation\\nE01B5;VS198;abbreviation\\nE01B6;VS199;abbreviation\\nE01B7;VS200;abbreviation\\nE01B8;VS201;abbreviation\\nE01B9;VS202;abbreviation\\nE01BA;VS203;abbreviation\\nE01BB;VS204;abbreviation\\nE01BC;VS205;abbreviation\\nE01BD;VS206;abbreviation\\nE01BE;VS207;abbreviation\\nE01BF;VS208;abbreviation\\nE01C0;VS209;abbreviation\\nE01C1;VS210;abbreviation\\nE01C2;VS211;abbreviation\\nE01C3;VS212;abbreviation\\nE01C4;VS213;abbreviation\\nE01C5;VS214;abbreviation\\nE01C6;VS215;abbreviation\\nE01C7;VS216;abbreviation\\nE01C8;VS217;abbreviation\\nE01C9;VS218;abbreviation\\nE01CA;VS219;abbreviation\\nE01CB;VS220;abbreviation\\nE01CC;VS221;abbreviation\\nE01CD;VS222;abbreviation\\nE01CE;VS223;abbreviation\\nE01CF;VS224;abbreviation\\nE01D0;VS225;abbreviation\\nE01D1;VS226;abbreviation\\nE01D2;VS227;abbreviation\\nE01D3;VS228;abbreviation\\nE01D4;VS229;abbreviation\\nE01D5;VS230;abbreviation\\nE01D6;VS231;abbreviation\\nE01D7;VS232;abbreviation\\nE01D8;VS233;abbreviation\\nE01D9;VS234;abbreviation\\nE01DA;VS235;abbreviation\\nE01DB;VS236;abbreviation\\nE01DC;VS237;abbreviation\\nE01DD;VS238;abbreviation\\nE01DE;VS239;abbreviation\\nE01DF;VS240;abbreviation\\nE01E0;VS241;abbreviation\\nE01E1;VS242;abbreviation\\nE01E2;VS243;abbreviation\\nE01E3;VS244;abbreviation\\nE01E4;VS245;abbreviation\\nE01E5;VS246;abbreviation\\nE01E6;VS247;abbreviation\\nE01E7;VS248;abbreviation\\nE01E8;VS249;abbreviation\\nE01E9;VS250;abbreviation\\nE01EA;VS251;abbreviation\\nE01EB;VS252;abbreviation\\nE01EC;VS253;abbreviation\\nE01ED;VS254;abbreviation\\nE01EE;VS255;abbreviation\\nE01EF;VS256;abbreviation\\n\\n# EOF\\n\";\n        ALIAS_MAP = (function() {\n            var _$rapyd$_anonfunc = function () {\n                var ans, line, parts, code_point;\n                ans = {};\n                var _$rapyd$_Iter10 = _$rapyd$_Iterable(DB.split(\"\\n\"));\n                for (var _$rapyd$_Index10 = 0; _$rapyd$_Index10 < _$rapyd$_Iter10.length; _$rapyd$_Index10++) {\n                    line = _$rapyd$_Iter10[_$rapyd$_Index10];\n                    line = line.trim();\n                    if (!line || line[0] === \"#\") {\n                        continue;\n                    }\n                    parts = line.split(\";\");\n                    if (parts.length >= 2) {\n                        code_point = parseInt(parts[0], 16);\n                        if (code_point !== undefined && parts[1]) {\n                            ans[parts[1].toLowerCase()] = code_point;\n                        }\n                    }\n                }\n                return ans;\n            };\n            return _$rapyd$_anonfunc;\n        })()();\n        _$rapyd$_modules.unicode_aliases.DB = DB;\n        _$rapyd$_modules.unicode_aliases.ALIAS_MAP = ALIAS_MAP;\n    })();\n\n    (function(){\n        var __name__ = \"ast\";\n        var AST_Token, AST_Node, AST_Statement, AST_Debugger, AST_Directive, AST_SimpleStatement, AST_Block, AST_BlockStatement, AST_EmptyStatement, AST_StatementWithBody, AST_DWLoop, AST_Do, AST_While, AST_ForIn, AST_ForJS, AST_ListComprehension, AST_SetComprehension, AST_DictComprehension, AST_GeneratorComprehension, AST_With, AST_WithClause, AST_Scope, AST_Toplevel, AST_Import, AST_Imports, AST_Decorator, AST_Lambda, AST_Function, AST_Class, AST_Method, AST_Jump, AST_Exit, AST_Return, AST_Yield, AST_Throw, AST_LoopControl, AST_Break, AST_Continue, AST_If, AST_Try, AST_Catch, AST_Except, AST_Finally, AST_Definitions, AST_Var, AST_Const, AST_VarDef, AST_BaseCall, AST_Call, AST_ClassCall, AST_New, AST_Seq, AST_PropAccess, AST_Dot, AST_Sub, AST_ItemAccess, AST_Splice, AST_Unary, AST_UnaryPrefix, AST_UnaryPostfix, AST_Binary, AST_Conditional, AST_Assign, AST_Array, AST_Object, AST_ExpressiveObject, AST_ObjectProperty, AST_ObjectKeyVal, AST_Set, AST_SetItem, AST_Symbol, AST_SymbolAlias, AST_SymbolDeclaration, AST_SymbolVar, AST_ImportedVar, AST_SymbolConst, AST_SymbolNonlocal, AST_SymbolFunarg, AST_SymbolDefun, AST_SymbolLambda, AST_SymbolCatch, AST_SymbolRef, AST_This, AST_Constant, AST_String, AST_Verbatim, AST_Number, AST_RegExp, AST_Atom, AST_Null, AST_NaN, AST_Undefined, AST_Hole, AST_Infinity, AST_Boolean, AST_False, AST_True;\n        var noop = _$rapyd$_modules.utils.noop;\n        var string_template = _$rapyd$_modules.utils.string_template;\n        \n        function DEFNODE(type, props, methods, base) {\n            var self_props, code, i, proto, ctor, _$rapyd$_chain_assign_temp;\n            if (arguments.length < 4) {\n                base = AST_Node;\n            }\n            if (!props) {\n                props = _$rapyd$_list_decorate([]);\n            } else {\n                props = props.split(/\\s+/);\n            }\n            self_props = props;\n            if (base && base.PROPS) {\n                props = props.concat(base.PROPS);\n            }\n            code = \"return function AST_\" + type + \"(props){ if (props) { \";\n            for (var _$rapyd$_Index11 = props.length - 1; _$rapyd$_Index11 > -1; _$rapyd$_Index11-=1) {\n                i = _$rapyd$_Index11;\n                code += \"this.\" + props[i] + \" = props.\" + props[i] + \";\";\n            }\n            proto = base && new base;\n            if (proto && proto.initialize || methods && methods.initialize) {\n                code += \"this.initialize();\";\n            }\n            code += \"}}\";\n            ctor = new Function(code)();\n            if (proto) {\n                ctor.prototype = proto;\n                ctor.BASE = base;\n            }\n            if (base) {\n                base.SUBCLASSES.push(ctor);\n            }\n            ctor.prototype.CTOR = ctor;\n            ctor.PROPS = props || null;\n            ctor.SELF_PROPS = self_props;\n            ctor.SUBCLASSES = _$rapyd$_list_decorate([]);\n            if (type) {\n                _$rapyd$_chain_assign_temp = type;\n                ctor.prototype.TYPE = _$rapyd$_chain_assign_temp;\n                ctor.TYPE = _$rapyd$_chain_assign_temp;\n;\n            }\n            if (methods) {\n                var _$rapyd$_Iter12 = _$rapyd$_Iterable(methods);\n                for (var _$rapyd$_Index12 = 0; _$rapyd$_Index12 < _$rapyd$_Iter12.length; _$rapyd$_Index12++) {\n                    i = _$rapyd$_Iter12[_$rapyd$_Index12];\n                    if (/^\\$/.test(i)) {\n                        ctor[i.substr(1)] = methods[i];\n                    } else {\n                        ctor.prototype[i] = methods[i];\n                    }\n                }\n            }\n            ctor.DEFMETHOD = (function() {\n                var _$rapyd$_anonfunc = function (name, method) {\n                    this.prototype[name] = method;\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"name\", \"method\"];\n                return _$rapyd$_anonfunc;\n            })();\n            return ctor;\n        };\n\n        DEFNODE.__argnames__ = [\"type\", \"props\", \"methods\", \"base\"];\n\n        AST_Token = DEFNODE(\"Token\", \"type value line col pos endpos nlb comments_before file\", {}, null);\n        AST_Node = DEFNODE(\"Node\", \"start end\", {\n            \"clone\": (function() {\n                var _$rapyd$_anonfunc = function () {\n                    return new this.CTOR(this);\n                };\n                return _$rapyd$_anonfunc;\n            })(),\n            \"$documentation\": \"Base class of all AST nodes\",\n            \"$propdoc\": {\n                \"start\": \"[AST_Token] The first token of this node\",\n                \"end\": \"[AST_Token] The last token of this node\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    return visitor._visit(this);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })(),\n            \"walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    return this._walk(visitor);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })(),\n            \"_dump\": (function() {\n                var _$rapyd$_anonfunc = function () {\n                    var depth = (arguments[0] === undefined || ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? _$rapyd$_anonfunc.__defaults__.depth : arguments[0];\n                    var omit = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? _$rapyd$_anonfunc.__defaults__.omit : arguments[1];\n                    var offset = (arguments[2] === undefined || ( 2 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? _$rapyd$_anonfunc.__defaults__.offset : arguments[2];\n                    var include_name = (arguments[3] === undefined || ( 3 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? _$rapyd$_anonfunc.__defaults__.include_name : arguments[3];\n                    var _$rapyd$_kwargs_obj = arguments[arguments.length-1];\n                    if (_$rapyd$_kwargs_obj === null || typeof _$rapyd$_kwargs_obj !== \"object\" || _$rapyd$_kwargs_obj [_$rapyd$_kwargs_symbol] !== true) _$rapyd$_kwargs_obj = {};\n                    if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"depth\")){\n                        depth = _$rapyd$_kwargs_obj.depth;\n                    }\n                    if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"omit\")){\n                        omit = _$rapyd$_kwargs_obj.omit;\n                    }\n                    if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"offset\")){\n                        offset = _$rapyd$_kwargs_obj.offset;\n                    }\n                    if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"include_name\")){\n                        include_name = _$rapyd$_kwargs_obj.include_name;\n                    }\n                    var p, reset, yellow, blue, green, red, magenta, pad, element, property, key;\n                    p = console.log;\n                    reset = \"\\u001b[0m\";\n                    yellow = \"\\u001b[33m\";\n                    blue = \"\\u001b[34m\";\n                    green = \"\\u001b[32m\";\n                    red = \"\\u001b[31m\";\n                    magenta = \"\\u001b[35m\";\n                    pad = new Array(offset + 1).join(\"  \");\n                    if (include_name) {\n                        p(pad + yellow + this.TYPE + reset);\n                    }\n                    var _$rapyd$_Iter13 = _$rapyd$_Iterable(this);\n                    for (var _$rapyd$_Index13 = 0; _$rapyd$_Index13 < _$rapyd$_Iter13.length; _$rapyd$_Index13++) {\n                        key = _$rapyd$_Iter13[_$rapyd$_Index13];\n                        if (_$rapyd$_in(key, omit)) {\n                            continue;\n                        }\n                        if (Array.isArray(this[key])) {\n                            if (this[key].length) {\n                                p(pad + \" \" + blue + key + \": \" + reset + \"[\");\n                                if (depth > 1) {\n                                    var _$rapyd$_Iter14 = _$rapyd$_Iterable(this[key]);\n                                    for (var _$rapyd$_Index14 = 0; _$rapyd$_Index14 < _$rapyd$_Iter14.length; _$rapyd$_Index14++) {\n                                        element = _$rapyd$_Iter14[_$rapyd$_Index14];\n                                        element._dump(depth - 1, omit, offset + 1, true);\n                                    }\n                                } else {\n                                    var _$rapyd$_Iter15 = _$rapyd$_Iterable(this[key]);\n                                    for (var _$rapyd$_Index15 = 0; _$rapyd$_Index15 < _$rapyd$_Iter15.length; _$rapyd$_Index15++) {\n                                        element = _$rapyd$_Iter15[_$rapyd$_Index15];\n                                        p(pad + \"   \" + yellow + element.TYPE + reset);\n                                    }\n                                }\n                                p(pad + \" ]\");\n                            } else {\n                                p(pad + \" \" + blue + key + \": \" + reset + \"[]\");\n                            }\n                        } else if (this[key]) {\n                            if (this[key].TYPE) {\n                                if (this[key].TYPE === \"Token\") {\n                                    p(pad + \" \" + blue + key + \": \" + magenta + this[key].TYPE + reset);\n                                    var _$rapyd$_Iter16 = _$rapyd$_Iterable(this[key]);\n                                    for (var _$rapyd$_Index16 = 0; _$rapyd$_Index16 < _$rapyd$_Iter16.length; _$rapyd$_Index16++) {\n                                        property = _$rapyd$_Iter16[_$rapyd$_Index16];\n                                        p(pad + \"   \" + blue + property + \": \" + reset + this[key][property]);\n                                    }\n                                } else {\n                                    p(pad + \" \" + blue + key + \": \" + yellow + this[key].TYPE + reset);\n                                    if (depth > 1) {\n                                        this[key]._dump(depth - 1, omit, offset + 1, false);\n                                    }\n                                }\n                            } else if (typeof this[key] === \"string\") {\n                                p(pad + \" \" + blue + key + \": \" + green + \"\\\"\" + this[key] + \"\\\"\" + reset);\n                            } else if (typeof this[key] === \"number\") {\n                                p(pad + \" \" + blue + key + \": \" + green + this[key] + reset);\n                            } else {\n                                p(pad + \" \" + blue + key + \": \" + red + this[key] + reset);\n                            }\n                        } else {\n                            p(pad + \" \" + blue + key + \": \" + reset + this[key]);\n                        }\n                    }\n                };\n\n                _$rapyd$_anonfunc.__defaults__ = {\n                    depth:100, \n                    omit:(function(){\n                        var s = _$rapyd$_set();\n                        s.jsset.add(\"start\");\n                        s.jsset.add(\"end\");\n                        return s;\n                    })(), \n                    offset:0, \n                    include_name:true\n                };\n\n                _$rapyd$_anonfunc.__handles_kwarg_interpolation__ = true;\n\n                _$rapyd$_anonfunc.__argnames__ = [\"depth\", \"omit\", \"offset\", \"include_name\"];\n                return _$rapyd$_anonfunc;\n            })(),\n            \"dump\": (function() {\n                var _$rapyd$_anonfunc = function () {\n                    var depth = (arguments[0] === undefined || ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? _$rapyd$_anonfunc.__defaults__.depth : arguments[0];\n                    var omit = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? _$rapyd$_anonfunc.__defaults__.omit : arguments[1];\n                    var _$rapyd$_kwargs_obj = arguments[arguments.length-1];\n                    if (_$rapyd$_kwargs_obj === null || typeof _$rapyd$_kwargs_obj !== \"object\" || _$rapyd$_kwargs_obj [_$rapyd$_kwargs_symbol] !== true) _$rapyd$_kwargs_obj = {};\n                    if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"depth\")){\n                        depth = _$rapyd$_kwargs_obj.depth;\n                    }\n                    if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"omit\")){\n                        omit = _$rapyd$_kwargs_obj.omit;\n                    }\n                    return this._dump(depth, omit, 0, true);\n                };\n\n                _$rapyd$_anonfunc.__defaults__ = {\n                    depth:2, \n                    omit:_$rapyd$_list_decorate([])\n                };\n\n                _$rapyd$_anonfunc.__handles_kwarg_interpolation__ = true;\n\n                _$rapyd$_anonfunc.__argnames__ = [\"depth\", \"omit\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, null);\n        AST_Node.warn_function = null;\n        AST_Node.warn = (function() {\n            var _$rapyd$_anonfunc = function (txt, props) {\n                if (AST_Node.warn_function) {\n                    AST_Node.warn_function(string_template(txt, props));\n                }\n            };\n\n            _$rapyd$_anonfunc.__argnames__ = [\"txt\", \"props\"];\n            return _$rapyd$_anonfunc;\n        })();\n        AST_Statement = DEFNODE(\"Statement\", null, {\n            \"$documentation\": \"Base class of all statements\"\n        });\n        AST_Debugger = DEFNODE(\"Debugger\", null, {\n            \"$documentation\": \"Represents a debugger statement\"\n        }, AST_Statement);\n        AST_Directive = DEFNODE(\"Directive\", \"value scope\", {\n            \"$documentation\": \"Represents a directive, like \\\"use strict\\\";\",\n            \"$propdoc\": {\n                \"value\": \"[string] The value of this directive as a plain string (it's not an AST_String!)\",\n                \"scope\": \"[AST_Scope/S] The scope that this directive affects\"\n            }\n        }, AST_Statement);\n        AST_SimpleStatement = DEFNODE(\"SimpleStatement\", \"body\", {\n            \"$documentation\": \"A statement consisting of an expression, i.e. a = 1 + 2\",\n            \"$propdoc\": {\n                \"body\": \"[AST_Node] an expression node (should not be instanceof AST_Statement)\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.body._walk(visitor);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_Statement);\n        function walk_body(node, visitor) {\n            if (node.body instanceof AST_Statement) {\n                node.body._walk(visitor);\n            } else if (node.body) {\n                node.body.forEach((function() {\n                    var _$rapyd$_anonfunc = function (stat) {\n                        stat._walk(visitor);\n                    };\n\n                    _$rapyd$_anonfunc.__argnames__ = [\"stat\"];\n                    return _$rapyd$_anonfunc;\n                })());\n            }\n        };\n\n        walk_body.__argnames__ = [\"node\", \"visitor\"];\n\n        AST_Block = DEFNODE(\"Block\", \"body\", {\n            \"$documentation\": \"A body of statements (usually bracketed)\",\n            \"$propdoc\": {\n                \"body\": \"[AST_Statement*] an array of statements\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(this, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            walk_body(node, visitor);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_Statement);\n        AST_BlockStatement = DEFNODE(\"BlockStatement\", null, {\n            \"$documentation\": \"A block statement\"\n        }, AST_Block);\n        AST_EmptyStatement = DEFNODE(\"EmptyStatement\", \"stype\", {\n            \"$documentation\": \"The empty statement (empty block or simply a semicolon)\",\n            \"$propdoc\": {\n                \"stype\": \"[string] the type of empty statement. Is ; for semicolons\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    return visitor._visit(this);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_Statement);\n        AST_StatementWithBody = DEFNODE(\"StatementWithBody\", \"body\", {\n            \"$documentation\": \"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`\",\n            \"$propdoc\": {\n                \"body\": \"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.body._walk(visitor);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_Statement);\n        AST_DWLoop = DEFNODE(\"DWLoop\", \"condition\", {\n            \"$documentation\": \"Base class for do/while statements\",\n            \"$propdoc\": {\n                \"condition\": \"[AST_Node] the loop condition.  Should not be instanceof AST_Statement\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.condition._walk(visitor);\n                            node.body._walk(visitor);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_StatementWithBody);\n        AST_Do = DEFNODE(\"Do\", null, {\n            \"$documentation\": \"A `do` statement\"\n        }, AST_DWLoop);\n        AST_While = DEFNODE(\"While\", null, {\n            \"$documentation\": \"A `while` statement\"\n        }, AST_DWLoop);\n        AST_ForIn = DEFNODE(\"ForIn\", \"init name object\", {\n            \"$documentation\": \"A `for ... in` statement\",\n            \"$propdoc\": {\n                \"init\": \"[AST_Node] the `for/in` initialization code\",\n                \"name\": \"[AST_SymbolRef?] the loop variable, only if `init` is AST_Var\",\n                \"object\": \"[AST_Node] the object that we're looping through\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.init._walk(visitor);\n                            if (node.name) node.name._walk(visitor);\n                            node.object._walk(visitor);\n                            if (node.body) {\n                                node.body._walk(visitor);\n                            }\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_StatementWithBody);\n        AST_ForJS = DEFNODE(\"ForJS\", \"condition\", {\n            \"$documentation\": \"A `for ... in` statement\",\n            \"$propdoc\": {\n                \"condition\": \"[AST_Verbatim] raw JavaScript conditional\"\n            }\n        }, AST_StatementWithBody);\n        AST_ListComprehension = DEFNODE(\"ListComprehension\", \"condition statement\", {\n            \"$documentation\": \"A list comprehension expression\",\n            \"$propdoc\": {\n                \"condition\": \"[AST_Node] the `if` condition\",\n                \"statement\": \"[AST_Node] statement to perform on each element before returning it\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.init._walk(visitor);\n                            node.object._walk(visitor);\n                            node.statement._walk(visitor);\n                            if (node.condition) node.condition._walk(visitor);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_ForIn);\n        AST_SetComprehension = DEFNODE(\"SetComprehension\", null, {\n            \"$documentation\": \"A set comprehension\"\n        }, AST_ListComprehension);\n        AST_DictComprehension = DEFNODE(\"DictComprehension\", \"value_statement is_pydict\", {\n            \"$documentation\": \"A set comprehension\",\n            \"$propdoc\": {\n                \"value_statement\": \"[AST_Node] statement to perform on each value before returning it\",\n                \"is_pydict\": \"[bool] True if this comprehension is for a python dict\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.init._walk(visitor);\n                            node.object._walk(visitor);\n                            node.statement._walk(visitor);\n                            node.value_statement._walk(visitor);\n                            if (node.condition) node.condition._walk(visitor);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_ListComprehension);\n        AST_GeneratorComprehension = DEFNODE(\"GeneratorComprehension\", null, {\n            \"$documentation\": \"A generator comprehension\"\n        }, AST_ListComprehension);\n        AST_With = DEFNODE(\"With\", \"clauses\", {\n            \"$documentation\": \"A `with` statement\",\n            \"$propdoc\": {\n                \"clauses\": \"[AST_WithClause*] the `with` clauses (comma separated)\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.clauses.forEach((function() {\n                                var _$rapyd$_anonfunc = function (exp) {\n                                    exp._walk(visitor);\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"exp\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                            node.body._walk(visitor);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_StatementWithBody);\n        AST_WithClause = DEFNODE(\"WithClause\", \"expression alias\", {\n            \"$documentation\": \"A clause in a with statement\",\n            \"$propdoc\": {\n                \"expression\": \"[AST_Node] the expression\",\n                \"alias\": \"[AST_SymbolAlias?] optional alias for this expression\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.expression._walk(visitor);\n                            if (node.alias) {\n                                node.alias._walk(visitor);\n                            }\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_Node);\n        AST_Scope = DEFNODE(\"Scope\", \"directives variables localvars functions uses_with uses_eval parent_scope enclosed cname\", {\n            \"$documentation\": \"Base class for all statements introducing a lexical scope\",\n            \"$propdoc\": {\n                \"directives\": \"[string*/S] an array of directives declared in this scope\",\n                \"variables\": \"[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope\",\n                \"localvars\": \"[SymbolDef*] list of variables local to this scope\",\n                \"functions\": \"[Object/S] like `variables`, but only lists function declarations\",\n                \"uses_with\": \"[boolean/S] tells whether this scope uses the `with` statement\",\n                \"uses_eval\": \"[boolean/S] tells whether this scope contains a direct call to the global `eval`\",\n                \"parent_scope\": \"[AST_Scope?/S] link to the parent scope\",\n                \"enclosed\": \"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes\",\n                \"cname\": \"[integer/S] current index for mangling variables (used internally by the mangler)\"\n            }\n        }, AST_Block);\n        AST_Toplevel = DEFNODE(\"Toplevel\", \"globals baselib imports imported_module_ids shebang import_order module_id exports submodules classes filename srchash\", {\n            \"$documentation\": \"The toplevel scope\",\n            \"$propdoc\": {\n                \"globals\": \"[Object/S] a map of name -> SymbolDef for all undeclared names\",\n                \"baselib\": \"[Object/s] a collection of used parts of baselib\",\n                \"imports\": \"[Object/S] a map of module_id->AST_Toplevel for all imported modules (this represents all imported modules across all source files)\",\n                \"imported_module_ids\": \"[string*] a list of module ids that were imported by this module, specifically\",\n                \"nonlocalvars\": \"[String*] a list of all non-local variable names (names that come from the global scope)\",\n                \"shebang\": \"[string] If #! line is present, it will be stored here\",\n                \"import_order\": \"[number] The global order in which this scope was imported\",\n                \"module_id\": \"[string] The id of this module\",\n                \"exports\": \"[SymbolDef*] list of names exported from this module\",\n                \"submodules\": \"[string*] list of names exported from this module\",\n                \"classes\": \"[Object/S] a map of class names to AST_Class for classes defined in this module\",\n                \"filename\": \"[string] The absolute path to the file from which this module was read\",\n                \"srchash\": \"[string] SHA1 hash of source code, used for caching\"\n            }\n        }, AST_Scope);\n        AST_Import = DEFNODE(\"Import\", \"module key alias argnames body\", {\n            \"$documentation\": \"Container for a single import\",\n            \"$propdoc\": {\n                \"module\": \"[AST_SymbolVar] name of the module we're importing\",\n                \"key\": \"[string] The key by which this module is stored in the global modules mapping\",\n                \"alias\": \"[AST_SymbolAlias] The name this module is imported as, can be None. For import x as y statements.\",\n                \"argnames\": \"[AST_ImportedVar*] names of objects to be imported\",\n                \"body\": \"[AST_TopLevel] parsed contents of the imported file\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            if (node.alias) {\n                                node.alias._walk(visitor);\n                            }\n                            if (node.argnames) {\n                                node.argnames.forEach((function() {\n                                    var _$rapyd$_anonfunc = function (arg) {\n                                        arg._walk(visitor);\n                                    };\n\n                                    _$rapyd$_anonfunc.__argnames__ = [\"arg\"];\n                                    return _$rapyd$_anonfunc;\n                                })());\n                            }\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_Statement);\n        AST_Imports = DEFNODE(\"Imports\", \"imports\", {\n            \"$documentation\": \"Container for a single import\",\n            \"$propdoc\": {\n                \"imports\": \"[AST_Import+] array of imports\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.imports.forEach((function() {\n                                var _$rapyd$_anonfunc = function (imp) {\n                                    imp._walk(visitor);\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"imp\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_Statement);\n        AST_Decorator = DEFNODE(\"Decorator\", \"expression\", {\n            \"$documentation\": \"Class for function decorators\",\n            \"$propdoc\": {\n                \"expression\": \"[AST_Node] the decorator expression\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            if (node.expression) {\n                                node.expression.walk(visitor);\n                            }\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        });\n        AST_Lambda = DEFNODE(\"Lambda\", \"name argnames decorators is_generator is_expression is_anonymous return_annotation\", {\n            \"$documentation\": \"Base class for functions\",\n            \"$propdoc\": {\n                \"name\": \"[AST_SymbolDeclaration?] the name of this function\",\n                \"argnames\": \"[AST_SymbolFunarg*] array of function arguments\",\n                \"decorators\": \"[AST_Decorator*] function decorators, if any\",\n                \"is_generator\": \"[bool*] True iff this function is a generator\",\n                \"is_expression\": \"[bool*] True iff this function is a function expression\",\n                \"is_anonymous\": \"[bool*] True iff this function is an anonymous function\",\n                \"return_annotation\": \"[AST_Node?] The return type annotation provided (if any)\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            var d;\n                            if (node.decorators) {\n                                var _$rapyd$_Iter17 = _$rapyd$_Iterable(node.decorators);\n                                for (var _$rapyd$_Index17 = 0; _$rapyd$_Index17 < _$rapyd$_Iter17.length; _$rapyd$_Index17++) {\n                                    d = _$rapyd$_Iter17[_$rapyd$_Index17];\n                                    d.walk(visitor);\n                                }\n                            }\n                            if (node.name) {\n                                node.name._walk(visitor);\n                            }\n                            node.argnames.forEach((function() {\n                                var _$rapyd$_anonfunc = function (arg) {\n                                    arg._walk(visitor);\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"arg\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                            if (node.argnames.starargs) {\n                                node.argnames.starargs._walk(visitor);\n                            }\n                            if (node.argnames.kwargs) {\n                                node.argnames.kwargs._walk(visitor);\n                            }\n                            walk_body(node, visitor);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_Scope);\n        AST_Function = DEFNODE(\"Function\", null, {\n            \"$documentation\": \"A function expression\"\n        }, AST_Lambda);\n        AST_Class = DEFNODE(\"Class\", \"init name parent static external bound decorators module_id statements dynamic_properties\", {\n            \"$documentation\": \"A class declaration\",\n            \"$propdoc\": {\n                \"name\": \"[AST_SymbolDeclaration?] the name of this class\",\n                \"init\": \"[AST_Function] constructor for the class\",\n                \"parent\": \"[AST_Symbol?] parent class this class inherits from\",\n                \"static\": \"[string*] list of static methods\",\n                \"external\": \"[boolean] true if class is declared elsewhere, but will be within current scope at runtime\",\n                \"bound\": \"[string*] list of methods that need to be bound to behave correctly (function pointers)\",\n                \"decorators\": \"[AST_Decorator*] function decorators, if any\",\n                \"module_id\": \"[string] The id of the module this class is defined in\",\n                \"statements\": \"[AST_Node*] list of statements in the class scope (excluding method definitions)\",\n                \"dynamic_properties\": \"[dict] map of dynamic property names to property descriptors of the form {getter:AST_Method, setter:AST_Method\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            var d;\n                            if (node.decorators) {\n                                var _$rapyd$_Iter18 = _$rapyd$_Iterable(node.decorators);\n                                for (var _$rapyd$_Index18 = 0; _$rapyd$_Index18 < _$rapyd$_Iter18.length; _$rapyd$_Index18++) {\n                                    d = _$rapyd$_Iter18[_$rapyd$_Index18];\n                                    d.walk(visitor);\n                                }\n                            }\n                            node.name._walk(visitor);\n                            walk_body(node, visitor);\n                            if (node.parent) node.parent._walk(visitor);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_Scope);\n        AST_Method = DEFNODE(\"Method\", \"static is_getter is_setter\", {\n            \"$documentation\": \"A class method definition\",\n            \"$propdoc\": {\n                \"static\": \"[boolean] true if method is static\",\n                \"is_getter\": \"[boolean] true if method is a property getter\",\n                \"is_setter\": \"[boolean] true if method is a property setter\"\n            }\n        }, AST_Lambda);\n        AST_Jump = DEFNODE(\"Jump\", null, {\n            \"$documentation\": \"Base class for jumps (for now that's `return`, `throw`, `break` and `continue`)\"\n        }, AST_Statement);\n        AST_Exit = DEFNODE(\"Exit\", \"value\", {\n            \"$documentation\": \"Base class for exits (`return` and `throw`)\",\n            \"$propdoc\": {\n                \"value\": \"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            if (node.value) {\n                                node.value._walk(visitor);\n                            }\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_Jump);\n        AST_Return = DEFNODE(\"Return\", null, {\n            \"$documentation\": \"A `return` statement\"\n        }, AST_Exit);\n        AST_Yield = DEFNODE(\"Yield\", \"is_yield_from\", {\n            \"$documentation\": \"A `yield` statement\",\n            \"$propdoc\": {\n                \"is_yield_from\": \"[bool] True iff this is a yield from, False otherwise\"\n            }\n        }, AST_Return);\n        AST_Throw = DEFNODE(\"Throw\", null, {\n            \"$documentation\": \"A `throw` statement\"\n        }, AST_Exit);\n        AST_LoopControl = DEFNODE(\"LoopControl\", null, {\n            \"$documentation\": \"Base class for loop control statements (`break` and `continue`)\"\n        }, AST_Jump);\n        AST_Break = DEFNODE(\"Break\", null, {\n            \"$documentation\": \"A `break` statement\"\n        }, AST_LoopControl);\n        AST_Continue = DEFNODE(\"Continue\", null, {\n            \"$documentation\": \"A `continue` statement\"\n        }, AST_LoopControl);\n        AST_If = DEFNODE(\"If\", \"condition alternative\", {\n            \"$documentation\": \"A `if` statement\",\n            \"$propdoc\": {\n                \"condition\": \"[AST_Node] the `if` condition\",\n                \"alternative\": \"[AST_Statement?] the `else` part, or null if not present\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.condition._walk(visitor);\n                            node.body._walk(visitor);\n                            if (node.alternative) {\n                                node.alternative._walk(visitor);\n                            }\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_StatementWithBody);\n        AST_Try = DEFNODE(\"Try\", \"bcatch bfinally\", {\n            \"$documentation\": \"A `try` statement\",\n            \"$propdoc\": {\n                \"bcatch\": \"[AST_Catch?] the catch block, or null if not present\",\n                \"bfinally\": \"[AST_Finally?] the finally block, or null if not present\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            walk_body(node, visitor);\n                            if (node.bcatch) {\n                                node.bcatch._walk(visitor);\n                            }\n                            if (node.bfinally) {\n                                node.bfinally._walk(visitor);\n                            }\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_Block);\n        AST_Catch = DEFNODE(\"Catch\", null, {\n            \"$documentation\": \"A `catch` node; only makes sense as part of a `try` statement\",\n            \"$propdoc\": {}\n        }, AST_Block);\n        AST_Except = DEFNODE(\"Except\", \"argname errors\", {\n            \"$documentation\": \"An `except` node for RapydScript, which resides inside the catch block\",\n            \"$propdoc\": {\n                \"argname\": \"[AST_SymbolCatch] symbol for the exception\",\n                \"errors\": \"[AST_SymbolVar*] error classes to catch in this block\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(this, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            var e;\n                            if (node.argname) {\n                                node.argname.walk(visitor);\n                            }\n                            if (node.errors) {\n                                var _$rapyd$_Iter19 = _$rapyd$_Iterable(node.errors);\n                                for (var _$rapyd$_Index19 = 0; _$rapyd$_Index19 < _$rapyd$_Iter19.length; _$rapyd$_Index19++) {\n                                    e = _$rapyd$_Iter19[_$rapyd$_Index19];\n                                    e.walk(visitor);\n                                }\n                            }\n                            walk_body(node, visitor);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_Block);\n        AST_Finally = DEFNODE(\"Finally\", null, {\n            \"$documentation\": \"A `finally` node; only makes sense as part of a `try` statement\"\n        }, AST_Block);\n        AST_Definitions = DEFNODE(\"Definitions\", \"definitions\", {\n            \"$documentation\": \"Base class for `var` or `const` nodes (variable declarations/initializations)\",\n            \"$propdoc\": {\n                \"definitions\": \"[AST_VarDef*] array of variable definitions\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.definitions.forEach((function() {\n                                var _$rapyd$_anonfunc = function (def_) {\n                                    def_._walk(visitor);\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"def_\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_Statement);\n        AST_Var = DEFNODE(\"Var\", null, {\n            \"$documentation\": \"A `var` statement\"\n        }, AST_Definitions);\n        AST_Const = DEFNODE(\"Const\", null, {\n            \"$documentation\": \"A `const` statement\"\n        }, AST_Definitions);\n        AST_VarDef = DEFNODE(\"VarDef\", \"name value\", {\n            \"$documentation\": \"A variable declaration; only appears in a AST_Definitions node\",\n            \"$propdoc\": {\n                \"name\": \"[AST_SymbolVar|AST_SymbolConst|AST_SymbolNonlocal] name of the variable\",\n                \"value\": \"[AST_Node?] initializer, or null if there's no initializer\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.name._walk(visitor);\n                            if (node.value) {\n                                node.value._walk(visitor);\n                            }\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        });\n        AST_BaseCall = DEFNODE(\"BaseCall\", \"args\", {\n            \"$documentation\": \"A base class for function calls\",\n            \"$propdoc\": {\n                \"args\": \"[AST_Node*] array of arguments\"\n            }\n        });\n        AST_Call = DEFNODE(\"Call\", \"expression\", {\n            \"$documentation\": \"A function call expression\",\n            \"$propdoc\": {\n                \"expression\": \"[AST_Node] expression to invoke as function\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.expression._walk(visitor);\n                            node.args.forEach((function() {\n                                var _$rapyd$_anonfunc = function (arg) {\n                                    arg._walk(visitor);\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"arg\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                            if (node.args.kwargs) node.args.kwargs.forEach((function() {\n                                var _$rapyd$_anonfunc = function (arg) {\n                                    arg[0]._walk(visitor);\n                                    arg[1]._walk(visitor);\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"arg\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                            if (node.args.kwarg_items) node.args.kwarg_items.forEach((function() {\n                                var _$rapyd$_anonfunc = function (arg) {\n                                    arg._walk(visitor);\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"arg\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_BaseCall);\n        AST_ClassCall = DEFNODE(\"ClassCall\", \"class method static\", {\n            \"$documentation\": \"A function call expression\",\n            \"$propdoc\": {\n                \"class\": \"[string] name of the class method belongs to\",\n                \"method\": \"[string] class method being called\",\n                \"static\": \"[boolean] defines whether the method is static\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            if (node.expression) node.expression._walk(visitor);\n                            node.args.forEach((function() {\n                                var _$rapyd$_anonfunc = function (arg) {\n                                    arg._walk(visitor);\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"arg\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                            node.args.kwargs.forEach((function() {\n                                var _$rapyd$_anonfunc = function (arg) {\n                                    arg[0]._walk(visitor);\n                                    arg[1]._walk(visitor);\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"arg\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                            node.args.kwarg_items.forEach((function() {\n                                var _$rapyd$_anonfunc = function (arg) {\n                                    arg._walk(visitor);\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"arg\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_BaseCall);\n        AST_New = DEFNODE(\"New\", null, {\n            \"$documentation\": \"An object instantiation. Derives from a function call since it has exactly the same properties\"\n        }, AST_Call);\n        AST_Seq = DEFNODE(\"Seq\", \"car cdr\", {\n            \"$documentation\": \"A sequence expression (two comma-separated expressions)\",\n            \"$propdoc\": {\n                \"car\": \"[AST_Node] first element in sequence\",\n                \"cdr\": \"[AST_Node] second element in sequence\"\n            },\n            \"$cons\": (function() {\n                var _$rapyd$_anonfunc = function (x, y) {\n                    var seq;\n                    seq = new AST_Seq(x);\n                    seq.car = x;\n                    seq.cdr = y;\n                    return seq;\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"x\", \"y\"];\n                return _$rapyd$_anonfunc;\n            })(),\n            \"$from_array\": (function() {\n                var _$rapyd$_anonfunc = function (array) {\n                    var list, i, p;\n                    if (array.length === 0) {\n                        return null;\n                    }\n                    if (array.length === 1) {\n                        return array[0].clone();\n                    }\n                    list = null;\n                    for (var _$rapyd$_Index20 = array.length - 1; _$rapyd$_Index20 > -1; _$rapyd$_Index20-=1) {\n                        i = _$rapyd$_Index20;\n                        list = AST_Seq.cons(array[i], list);\n                    }\n                    p = list;\n                    while (p) {\n                        if (p.cdr && !p.cdr.cdr) {\n                            p.cdr = p.cdr.car;\n                            break;\n                        }\n                        p = p.cdr;\n                    }\n                    return list;\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"array\"];\n                return _$rapyd$_anonfunc;\n            })(),\n            \"to_array\": (function() {\n                var _$rapyd$_anonfunc = function () {\n                    var p, a;\n                    p = this;\n                    a = _$rapyd$_list_decorate([]);\n                    while (p) {\n                        a.push(p.car);\n                        if (p.cdr && !(p.cdr instanceof AST_Seq)) {\n                            a.push(p.cdr);\n                            break;\n                        }\n                        p = p.cdr;\n                    }\n                    return a;\n                };\n                return _$rapyd$_anonfunc;\n            })(),\n            \"add\": (function() {\n                var _$rapyd$_anonfunc = function (node) {\n                    var p, cell;\n                    p = this;\n                    while (p) {\n                        if (!(p.cdr instanceof AST_Seq)) {\n                            cell = AST_Seq.cons(p.cdr, node);\n                            return p.cdr = cell;\n                        }\n                        p = p.cdr;\n                    }\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"node\"];\n                return _$rapyd$_anonfunc;\n            })(),\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.car._walk(visitor);\n                            if (node.cdr) {\n                                node.cdr._walk(visitor);\n                            }\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        });\n        AST_PropAccess = DEFNODE(\"PropAccess\", \"expression property\", {\n            \"$documentation\": \"Base class for property access expressions, i.e. `a.foo` or `a[\\\"foo\\\"]`\",\n            \"$propdoc\": {\n                \"expression\": \"[AST_Node] the container expression\",\n                \"property\": \"[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node\"\n            }\n        });\n        AST_Dot = DEFNODE(\"Dot\", null, {\n            \"$documentation\": \"A dotted property access expression\",\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.expression._walk(visitor);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_PropAccess);\n        AST_Sub = DEFNODE(\"Sub\", null, {\n            \"$documentation\": \"Index-style property access, i.e. `a[\\\"foo\\\"]`\",\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.expression._walk(visitor);\n                            node.property._walk(visitor);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_PropAccess);\n        AST_ItemAccess = DEFNODE(\"ItemAccess\", \"assignment\", {\n            \"$documentation\": \"Python index-style property access, i.e. `a.__getitem__(\\\"foo\\\")`\",\n            \"$propdoc\": {\n                \"assignment\": \"[AST_Node or None] Not None if this is an assignment (a[x] = y) rather than a simple access\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.expression._walk(visitor);\n                            node.property._walk(visitor);\n                            if (node.assignment) {\n                                node.assignment._walk(visitor);\n                            }\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_PropAccess);\n        AST_Splice = DEFNODE(\"Slice\", \"property2 assignment\", {\n            \"$documentation\": \"Index-style property access, i.e. `a[3:5]`\",\n            \"$propdoc\": {\n                \"property2\": \"[AST_Node] the 2nd property to access - typically ending index for the array.\",\n                \"assignment\": \"[AST_Node] The data being spliced in.\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.expression._walk(visitor);\n                            node.property._walk(visitor);\n                            node.property2._walk(visitor);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_PropAccess);\n        AST_Unary = DEFNODE(\"Unary\", \"operator expression\", {\n            \"$documentation\": \"Base class for unary expressions\",\n            \"$propdoc\": {\n                \"operator\": \"[string] the operator\",\n                \"expression\": \"[AST_Node] expression that this unary operator applies to\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.expression._walk(visitor);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        });\n        AST_UnaryPrefix = DEFNODE(\"UnaryPrefix\", null, {\n            \"$documentation\": \"Unary prefix expression, i.e. `typeof i` or `++i`\"\n        }, AST_Unary);\n        AST_UnaryPostfix = DEFNODE(\"UnaryPostfix\", null, {\n            \"$documentation\": \"Unary postfix expression, i.e. `i++`\"\n        }, AST_Unary);\n        AST_Binary = DEFNODE(\"Binary\", \"left operator right\", {\n            \"$documentation\": \"Binary expression, i.e. `a + b`\",\n            \"$propdoc\": {\n                \"left\": \"[AST_Node] left-hand side expression\",\n                \"operator\": \"[string] the operator\",\n                \"right\": \"[AST_Node] right-hand side expression\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.left._walk(visitor);\n                            node.right._walk(visitor);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        });\n        AST_Conditional = DEFNODE(\"Conditional\", \"condition consequent alternative\", {\n            \"$documentation\": \"Conditional expression using the ternary operator, i.e. `a ? b : c`\",\n            \"$propdoc\": {\n                \"condition\": \"[AST_Node]\",\n                \"consequent\": \"[AST_Node]\",\n                \"alternative\": \"[AST_Node]\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.condition._walk(visitor);\n                            node.consequent._walk(visitor);\n                            node.alternative._walk(visitor);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        });\n        AST_Assign = DEFNODE(\"Assign\", null, {\n            \"$documentation\": \"An assignment expression  `a = b + 5`\",\n            \"is_chained\": (function() {\n                var _$rapyd$_anonfunc = function () {\n                    return this.right instanceof AST_Assign || this.right instanceof AST_Seq && (this.right.car instanceof AST_Assign || this.right.cdr instanceof AST_Assign);\n                };\n                return _$rapyd$_anonfunc;\n            })(),\n            \"traverse_chain\": (function() {\n                var _$rapyd$_anonfunc = function () {\n                    var right, left_hand_sides, next, assign;\n                    right = this.right;\n                    while (true) {\n                        if (right instanceof AST_Assign) {\n                            right = right.right;\n                            continue;\n                        }\n                        if (right instanceof AST_Seq) {\n                            if (right.car instanceof AST_Assign) {\n                                right = new AST_Seq({\n                                    \"car\": right.car.right,\n                                    \"cdr\": right.cdr\n                                });\n                                continue;\n                            }\n                            if (right.cdr instanceof AST_Assign) {\n                                right = right.cdr.right;\n                                continue;\n                            }\n                        }\n                        break;\n                    }\n                    left_hand_sides = [this.left];\n                    next = this.right;\n                    while (true) {\n                        if (next instanceof AST_Assign) {\n                            left_hand_sides.push(next.left);\n                            next = next.right;\n                            continue;\n                        }\n                        if (next instanceof AST_Seq) {\n                            if (next.cdr instanceof AST_Assign) {\n                                assign = next.cdr;\n                                left_hand_sides.push(new AST_Seq({\n                                    \"car\": next.car,\n                                    \"cdr\": assign.left\n                                }));\n                                next = assign.right;\n                                continue;\n                            }\n                        }\n                        break;\n                    }\n                    return [left_hand_sides, right];\n                };\n                return _$rapyd$_anonfunc;\n            })()\n        }, AST_Binary);\n        AST_Array = DEFNODE(\"Array\", \"elements\", {\n            \"$documentation\": \"An array literal\",\n            \"$propdoc\": {\n                \"elements\": \"[AST_Node*] array of elements\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.elements.forEach((function() {\n                                var _$rapyd$_anonfunc = function (el) {\n                                    el._walk(visitor);\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"el\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })(),\n            \"flatten\": (function() {\n                var _$rapyd$_anonfunc = function () {\n                    function flatten(arr) {\n                        var ans, value;\n                        ans = _$rapyd$_list_decorate([]);\n                        var _$rapyd$_Iter21 = _$rapyd$_Iterable(arr);\n                        for (var _$rapyd$_Index21 = 0; _$rapyd$_Index21 < _$rapyd$_Iter21.length; _$rapyd$_Index21++) {\n                            value = _$rapyd$_Iter21[_$rapyd$_Index21];\n                            if (value instanceof AST_Seq) {\n                                value = value.to_array();\n                            } else if (value instanceof AST_Array) {\n                                value = value.elements;\n                            }\n                            if (Array.isArray(value)) {\n                                ans = ans.concat(flatten(value));\n                            } else {\n                                ans.push(value);\n                            }\n                        }\n                        return ans;\n                    };\n\n                    flatten.__argnames__ = [\"arr\"];\n\n                    return flatten(this.elements);\n                };\n                return _$rapyd$_anonfunc;\n            })()\n        });\n        AST_Object = DEFNODE(\"Object\", \"properties is_pydict\", {\n            \"$documentation\": \"An object literal\",\n            \"$propdoc\": {\n                \"properties\": \"[AST_ObjectProperty*] array of properties\",\n                \"is_pydict\": \"[bool] True if this object is a python dict literal\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.properties.forEach((function() {\n                                var _$rapyd$_anonfunc = function (prop) {\n                                    prop._walk(visitor);\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"prop\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        });\n        AST_ExpressiveObject = DEFNODE(\"ExpressiveObject\", null, {\n            \"$documentation\": \"An object literal with expressions for some keys\"\n        }, AST_Object);\n        AST_ObjectProperty = DEFNODE(\"ObjectProperty\", \"key value quoted\", {\n            \"$documentation\": \"Base class for literal object properties\",\n            \"$propdoc\": {\n                \"key\": \"[AST_Node] the property expression\",\n                \"value\": \"[AST_Node] property value.  For setters and getters this is an AST_Function.\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.key._walk(visitor);\n                            node.value._walk(visitor);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        });\n        AST_ObjectKeyVal = DEFNODE(\"ObjectKeyVal\", null, {\n            \"$documentation\": \"A key: value object property\"\n        }, AST_ObjectProperty);\n        AST_Set = DEFNODE(\"Set\", \"items\", {\n            \"$documentation\": \"A set literal\",\n            \"$propdoc\": {\n                \"items\": \"[AST_SetItem*] array of items\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.items.forEach((function() {\n                                var _$rapyd$_anonfunc = function (prop) {\n                                    prop._walk(visitor);\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"prop\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        });\n        AST_SetItem = DEFNODE(\"SetItem\", \"value\", {\n            \"$documentation\": \"An item in a set literal\",\n            \"$propdoc\": {\n                \"value\": \"[AST_Node] The value of this item\"\n            },\n            \"_walk\": (function() {\n                var _$rapyd$_anonfunc = function (visitor) {\n                    var node;\n                    node = this;\n                    return visitor._visit(node, (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            node.value._walk(visitor);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"visitor\"];\n                return _$rapyd$_anonfunc;\n            })()\n        });\n        AST_Symbol = DEFNODE(\"Symbol\", \"scope name thedef\", {\n            \"$propdoc\": {\n                \"name\": \"[string] name of this symbol\",\n                \"scope\": \"[AST_Scope/S] the current scope (not necessarily the definition scope)\",\n                \"thedef\": \"[SymbolDef/S] the definition of this symbol\"\n            },\n            \"$documentation\": \"Base class for all symbols\"\n        });\n        AST_SymbolAlias = DEFNODE(\"SymbolAlias\", null, {\n            \"$documentation\": \"An alias used in an import statement or with statement\"\n        }, AST_Symbol);\n        AST_SymbolDeclaration = DEFNODE(\"SymbolDeclaration\", \"init\", {\n            \"$documentation\": \"A declaration symbol (symbol in var/const, function name or argument, symbol in catch)\",\n            \"$propdoc\": {\n                \"init\": \"[AST_Node*/S] array of initializers for this declaration.\"\n            }\n        }, AST_Symbol);\n        AST_SymbolVar = DEFNODE(\"SymbolVar\", null, {\n            \"$documentation\": \"Symbol defining a variable\"\n        }, AST_SymbolDeclaration);\n        AST_ImportedVar = DEFNODE(\"ImportedVar\", \"alias\", {\n            \"$documentation\": \"Symbol defining an imported symbol\",\n            \"$propdoc\": {\n                \"alias\": \"AST_SymbolAlias the alias for this imported symbol\"\n            }\n        }, AST_SymbolVar);\n        AST_SymbolConst = DEFNODE(\"SymbolConst\", null, {\n            \"$documentation\": \"A constant declaration\"\n        }, AST_SymbolDeclaration);\n        AST_SymbolNonlocal = DEFNODE(\"SymbolNonlocal\", null, {\n            \"$documentation\": \"A nonlocal declaration\"\n        }, AST_SymbolDeclaration);\n        AST_SymbolFunarg = DEFNODE(\"SymbolFunarg\", \"annotation\", {\n            \"$documentation\": \"Symbol naming a function argument, possibly with an annotation.\",\n            \"$propdoc\": {\n                \"annotation\": \"[AST_Node?] The annotation provided for this argument (if any)\"\n            }\n        }, AST_SymbolVar);\n        AST_SymbolDefun = DEFNODE(\"SymbolDefun\", null, {\n            \"$documentation\": \"Symbol defining a function\"\n        }, AST_SymbolDeclaration);\n        AST_SymbolLambda = DEFNODE(\"SymbolLambda\", null, {\n            \"$documentation\": \"Symbol naming a function expression\"\n        }, AST_SymbolDeclaration);\n        AST_SymbolCatch = DEFNODE(\"SymbolCatch\", null, {\n            \"$documentation\": \"Symbol naming the exception in catch\"\n        }, AST_SymbolDeclaration);\n        AST_SymbolRef = DEFNODE(\"SymbolRef\", \"parens\", {\n            \"$documentation\": \"Reference to some symbol (not definition/declaration)\",\n            \"$propdoc\": {\n                \"parens\": \"[boolean/S] if true, this variable is wrapped in parentheses\"\n            }\n        }, AST_Symbol);\n        AST_This = DEFNODE(\"This\", null, {\n            \"$documentation\": \"The `this` symbol\"\n        }, AST_Symbol);\n        AST_Constant = DEFNODE(\"Constant\", null, {\n            \"$documentation\": \"Base class for all constants\",\n            \"getValue\": (function() {\n                var _$rapyd$_anonfunc = function () {\n                    return this.value;\n                };\n                return _$rapyd$_anonfunc;\n            })()\n        });\n        AST_String = DEFNODE(\"String\", \"value\", {\n            \"$documentation\": \"A string literal\",\n            \"$propdoc\": {\n                \"value\": \"[string] the contents of this string\"\n            }\n        }, AST_Constant);\n        AST_Verbatim = DEFNODE(\"Verbatim\", \"value\", {\n            \"$documentation\": \"Raw JavaScript code\",\n            \"$propdoc\": {\n                \"value\": \"[string] A string of raw JS code\"\n            }\n        }, AST_Constant);\n        AST_Number = DEFNODE(\"Number\", \"value\", {\n            \"$documentation\": \"A number literal\",\n            \"$propdoc\": {\n                \"value\": \"[number] the numeric value\"\n            }\n        }, AST_Constant);\n        AST_RegExp = DEFNODE(\"RegExp\", \"value\", {\n            \"$documentation\": \"A regexp literal\",\n            \"$propdoc\": {\n                \"value\": \"[RegExp] the actual regexp\"\n            }\n        }, AST_Constant);\n        AST_Atom = DEFNODE(\"Atom\", null, {\n            \"$documentation\": \"Base class for atoms\"\n        }, AST_Constant);\n        AST_Null = DEFNODE(\"Null\", null, {\n            \"$documentation\": \"The `null` atom\",\n            \"value\": null\n        }, AST_Atom);\n        AST_NaN = DEFNODE(\"NaN\", null, {\n            \"$documentation\": \"The impossible value\",\n            \"value\": 0 / 0\n        }, AST_Atom);\n        AST_Undefined = DEFNODE(\"Undefined\", null, {\n            \"$documentation\": \"The `undefined` value\",\n            \"value\": (function() {\n                var _$rapyd$_anonfunc = function () {\n                };\n                return _$rapyd$_anonfunc;\n            })().call(this)\n        }, AST_Atom);\n        AST_Hole = DEFNODE(\"Hole\", null, {\n            \"$documentation\": \"A hole in an array\",\n            \"value\": (function() {\n                var _$rapyd$_anonfunc = function () {\n                };\n                return _$rapyd$_anonfunc;\n            })().call(this)\n        }, AST_Atom);\n        AST_Infinity = DEFNODE(\"Infinity\", null, {\n            \"$documentation\": \"The `Infinity` value\",\n            \"value\": 1 / 0\n        }, AST_Atom);\n        AST_Boolean = DEFNODE(\"Boolean\", null, {\n            \"$documentation\": \"Base class for booleans\"\n        }, AST_Atom);\n        AST_False = DEFNODE(\"False\", null, {\n            \"$documentation\": \"The `false` atom\",\n            \"value\": false\n        }, AST_Boolean);\n        AST_True = DEFNODE(\"True\", null, {\n            \"$documentation\": \"The `true` atom\",\n            \"value\": true\n        }, AST_Boolean);\n        function TreeWalker(callback) {\n            this.visit = callback;\n            this.stack = _$rapyd$_list_decorate([]);\n        };\n\n        TreeWalker.__argnames__ = [\"callback\"];\n\n        TreeWalker.prototype = {\n            \"_visit\": (function() {\n                var _$rapyd$_anonfunc = function (node, descend) {\n                    var ret;\n                    this.stack.push(node);\n                    ret = this.visit(node, (descend) ? (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            descend.call(node);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })() : noop);\n                    if (!ret && descend) {\n                        descend.call(node);\n                    }\n                    this.stack.pop();\n                    return ret;\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"node\", \"descend\"];\n                return _$rapyd$_anonfunc;\n            })(),\n            \"parent\": (function() {\n                var _$rapyd$_anonfunc = function (n) {\n                    return this.stack[this.stack.length - 2 - (n || 0)];\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"n\"];\n                return _$rapyd$_anonfunc;\n            })(),\n            \"push\": (function() {\n                var _$rapyd$_anonfunc = function (node) {\n                    this.stack.push(node);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"node\"];\n                return _$rapyd$_anonfunc;\n            })(),\n            \"pop\": (function() {\n                var _$rapyd$_anonfunc = function () {\n                    return this.stack.pop();\n                };\n                return _$rapyd$_anonfunc;\n            })(),\n            \"self\": (function() {\n                var _$rapyd$_anonfunc = function () {\n                    return this.stack[this.stack.length - 1];\n                };\n                return _$rapyd$_anonfunc;\n            })(),\n            \"find_parent\": (function() {\n                var _$rapyd$_anonfunc = function (type) {\n                    var stack, x, i;\n                    stack = this.stack;\n                    for (var _$rapyd$_Index22 = stack.length - 1; _$rapyd$_Index22 > -1; _$rapyd$_Index22-=1) {\n                        i = _$rapyd$_Index22;\n                        x = stack[i];\n                        if (x instanceof type) {\n                            return x;\n                        }\n                    }\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"type\"];\n                return _$rapyd$_anonfunc;\n            })(),\n            \"in_boolean_context\": (function() {\n                var _$rapyd$_anonfunc = function () {\n                    var stack, i, self, p;\n                    stack = this.stack;\n                    i = stack.length;\n                    self = stack[i -= 1];\n                    while (i > 0) {\n                        p = stack[i -= 1];\n                        if (p instanceof AST_If && p.condition === self || p instanceof AST_Conditional && p.condition === self || p instanceof AST_DWLoop && p.condition === self || p instanceof AST_UnaryPrefix && p.operator === \"!\" && p.expression === self) {\n                            return true;\n                        }\n                        if (!(p instanceof AST_Binary && (p.operator === \"&&\" || p.operator === \"||\"))) {\n                            return false;\n                        }\n                        self = p;\n                    }\n                };\n                return _$rapyd$_anonfunc;\n            })()\n        };\n        function Found() {\n            if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n            Found.prototype.__init__.apply(this, arguments);\n        }\n        _$rapyd$_extends(Found, Exception);\n        Found.prototype.__init__ = function __init__ () {\n            Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n        };\n        Found.prototype.__repr__ = function __repr__ () {\n            return \"<\" + __name__ + \".\" + \"Found\" + \" #\" + this._$rapyd$_object_id + \">\";\n        };\n        Found.prototype.__str__ = function __str__ () {\n            return this.__repr__();\n        };\n        \n\n        function has_calls(expression) {\n            if (!expression) {\n                return false;\n            }\n            try {\n                expression.walk(new TreeWalker((function() {\n                    var _$rapyd$_anonfunc = function (node) {\n                        if ((node instanceof AST_BaseCall || node instanceof AST_ItemAccess)) {\n                            throw new Found;\n                        }\n                    };\n\n                    _$rapyd$_anonfunc.__argnames__ = [\"node\"];\n                    return _$rapyd$_anonfunc;\n                })()));\n            } catch (_$rapyd$_Exception) {\n                if (_$rapyd$_Exception instanceof Found) {\n                    return true;\n                } else {\n                    throw _$rapyd$_Exception;\n                }\n            }\n            return false;\n        };\n\n        has_calls.__argnames__ = [\"expression\"];\n\n        _$rapyd$_modules.ast.AST_Token = AST_Token;\n        _$rapyd$_modules.ast.AST_Node = AST_Node;\n        _$rapyd$_modules.ast.AST_Statement = AST_Statement;\n        _$rapyd$_modules.ast.AST_Debugger = AST_Debugger;\n        _$rapyd$_modules.ast.AST_Directive = AST_Directive;\n        _$rapyd$_modules.ast.AST_SimpleStatement = AST_SimpleStatement;\n        _$rapyd$_modules.ast.AST_Block = AST_Block;\n        _$rapyd$_modules.ast.AST_BlockStatement = AST_BlockStatement;\n        _$rapyd$_modules.ast.AST_EmptyStatement = AST_EmptyStatement;\n        _$rapyd$_modules.ast.AST_StatementWithBody = AST_StatementWithBody;\n        _$rapyd$_modules.ast.AST_DWLoop = AST_DWLoop;\n        _$rapyd$_modules.ast.AST_Do = AST_Do;\n        _$rapyd$_modules.ast.AST_While = AST_While;\n        _$rapyd$_modules.ast.AST_ForIn = AST_ForIn;\n        _$rapyd$_modules.ast.AST_ForJS = AST_ForJS;\n        _$rapyd$_modules.ast.AST_ListComprehension = AST_ListComprehension;\n        _$rapyd$_modules.ast.AST_SetComprehension = AST_SetComprehension;\n        _$rapyd$_modules.ast.AST_DictComprehension = AST_DictComprehension;\n        _$rapyd$_modules.ast.AST_GeneratorComprehension = AST_GeneratorComprehension;\n        _$rapyd$_modules.ast.AST_With = AST_With;\n        _$rapyd$_modules.ast.AST_WithClause = AST_WithClause;\n        _$rapyd$_modules.ast.AST_Scope = AST_Scope;\n        _$rapyd$_modules.ast.AST_Toplevel = AST_Toplevel;\n        _$rapyd$_modules.ast.AST_Import = AST_Import;\n        _$rapyd$_modules.ast.AST_Imports = AST_Imports;\n        _$rapyd$_modules.ast.AST_Decorator = AST_Decorator;\n        _$rapyd$_modules.ast.AST_Lambda = AST_Lambda;\n        _$rapyd$_modules.ast.AST_Function = AST_Function;\n        _$rapyd$_modules.ast.AST_Class = AST_Class;\n        _$rapyd$_modules.ast.AST_Method = AST_Method;\n        _$rapyd$_modules.ast.AST_Jump = AST_Jump;\n        _$rapyd$_modules.ast.AST_Exit = AST_Exit;\n        _$rapyd$_modules.ast.AST_Return = AST_Return;\n        _$rapyd$_modules.ast.AST_Yield = AST_Yield;\n        _$rapyd$_modules.ast.AST_Throw = AST_Throw;\n        _$rapyd$_modules.ast.AST_LoopControl = AST_LoopControl;\n        _$rapyd$_modules.ast.AST_Break = AST_Break;\n        _$rapyd$_modules.ast.AST_Continue = AST_Continue;\n        _$rapyd$_modules.ast.AST_If = AST_If;\n        _$rapyd$_modules.ast.AST_Try = AST_Try;\n        _$rapyd$_modules.ast.AST_Catch = AST_Catch;\n        _$rapyd$_modules.ast.AST_Except = AST_Except;\n        _$rapyd$_modules.ast.AST_Finally = AST_Finally;\n        _$rapyd$_modules.ast.AST_Definitions = AST_Definitions;\n        _$rapyd$_modules.ast.AST_Var = AST_Var;\n        _$rapyd$_modules.ast.AST_Const = AST_Const;\n        _$rapyd$_modules.ast.AST_VarDef = AST_VarDef;\n        _$rapyd$_modules.ast.AST_BaseCall = AST_BaseCall;\n        _$rapyd$_modules.ast.AST_Call = AST_Call;\n        _$rapyd$_modules.ast.AST_ClassCall = AST_ClassCall;\n        _$rapyd$_modules.ast.AST_New = AST_New;\n        _$rapyd$_modules.ast.AST_Seq = AST_Seq;\n        _$rapyd$_modules.ast.AST_PropAccess = AST_PropAccess;\n        _$rapyd$_modules.ast.AST_Dot = AST_Dot;\n        _$rapyd$_modules.ast.AST_Sub = AST_Sub;\n        _$rapyd$_modules.ast.AST_ItemAccess = AST_ItemAccess;\n        _$rapyd$_modules.ast.AST_Splice = AST_Splice;\n        _$rapyd$_modules.ast.AST_Unary = AST_Unary;\n        _$rapyd$_modules.ast.AST_UnaryPrefix = AST_UnaryPrefix;\n        _$rapyd$_modules.ast.AST_UnaryPostfix = AST_UnaryPostfix;\n        _$rapyd$_modules.ast.AST_Binary = AST_Binary;\n        _$rapyd$_modules.ast.AST_Conditional = AST_Conditional;\n        _$rapyd$_modules.ast.AST_Assign = AST_Assign;\n        _$rapyd$_modules.ast.AST_Array = AST_Array;\n        _$rapyd$_modules.ast.AST_Object = AST_Object;\n        _$rapyd$_modules.ast.AST_ExpressiveObject = AST_ExpressiveObject;\n        _$rapyd$_modules.ast.AST_ObjectProperty = AST_ObjectProperty;\n        _$rapyd$_modules.ast.AST_ObjectKeyVal = AST_ObjectKeyVal;\n        _$rapyd$_modules.ast.AST_Set = AST_Set;\n        _$rapyd$_modules.ast.AST_SetItem = AST_SetItem;\n        _$rapyd$_modules.ast.AST_Symbol = AST_Symbol;\n        _$rapyd$_modules.ast.AST_SymbolAlias = AST_SymbolAlias;\n        _$rapyd$_modules.ast.AST_SymbolDeclaration = AST_SymbolDeclaration;\n        _$rapyd$_modules.ast.AST_SymbolVar = AST_SymbolVar;\n        _$rapyd$_modules.ast.AST_ImportedVar = AST_ImportedVar;\n        _$rapyd$_modules.ast.AST_SymbolConst = AST_SymbolConst;\n        _$rapyd$_modules.ast.AST_SymbolNonlocal = AST_SymbolNonlocal;\n        _$rapyd$_modules.ast.AST_SymbolFunarg = AST_SymbolFunarg;\n        _$rapyd$_modules.ast.AST_SymbolDefun = AST_SymbolDefun;\n        _$rapyd$_modules.ast.AST_SymbolLambda = AST_SymbolLambda;\n        _$rapyd$_modules.ast.AST_SymbolCatch = AST_SymbolCatch;\n        _$rapyd$_modules.ast.AST_SymbolRef = AST_SymbolRef;\n        _$rapyd$_modules.ast.AST_This = AST_This;\n        _$rapyd$_modules.ast.AST_Constant = AST_Constant;\n        _$rapyd$_modules.ast.AST_String = AST_String;\n        _$rapyd$_modules.ast.AST_Verbatim = AST_Verbatim;\n        _$rapyd$_modules.ast.AST_Number = AST_Number;\n        _$rapyd$_modules.ast.AST_RegExp = AST_RegExp;\n        _$rapyd$_modules.ast.AST_Atom = AST_Atom;\n        _$rapyd$_modules.ast.AST_Null = AST_Null;\n        _$rapyd$_modules.ast.AST_NaN = AST_NaN;\n        _$rapyd$_modules.ast.AST_Undefined = AST_Undefined;\n        _$rapyd$_modules.ast.AST_Hole = AST_Hole;\n        _$rapyd$_modules.ast.AST_Infinity = AST_Infinity;\n        _$rapyd$_modules.ast.AST_Boolean = AST_Boolean;\n        _$rapyd$_modules.ast.AST_False = AST_False;\n        _$rapyd$_modules.ast.AST_True = AST_True;\n        _$rapyd$_modules.ast.DEFNODE = DEFNODE;\n        _$rapyd$_modules.ast.walk_body = walk_body;\n        _$rapyd$_modules.ast.TreeWalker = TreeWalker;\n        _$rapyd$_modules.ast.Found = Found;\n        _$rapyd$_modules.ast.has_calls = has_calls;\n    })();\n\n    (function(){\n        var __name__ = \"tokenizer\";\n        var RE_HEX_NUMBER, RE_OCT_NUMBER, RE_DEC_NUMBER, UNARY_POSTFIX, OPERATOR_CHARS, INVALID_OPERATORS, ASCII_CONTROL_CHARS, HEX_PAT, NAME_PAT, OPERATORS, OP_MAP, WHITESPACE_CHARS, PUNC_BEFORE_EXPRESSION, PUNC_CHARS, REGEXP_MODIFIERS, KEYWORDS, KEYWORDS_ATOM, RESERVED_WORDS, KEYWORDS_BEFORE_EXPRESSION, ALL_KEYWORDS, IDENTIFIER_PAT, UNICODE, EX_EOF;\n        var ALIAS_MAP = _$rapyd$_modules.unicode_aliases.ALIAS_MAP;\n        \n        var make_predicate = _$rapyd$_modules.utils.make_predicate;\n        var characters = _$rapyd$_modules.utils.characters;\n        \n        var AST_Token = _$rapyd$_modules.ast.AST_Token;\n        \n        var SyntaxError = _$rapyd$_modules.errors.SyntaxError;\n        \n        RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;\n        RE_OCT_NUMBER = /^0[0-7]+$/;\n        RE_DEC_NUMBER = /^\\d*\\.?\\d*(?:e[+-]?\\d*(?:\\d\\.?|\\.?\\d)\\d*)?$/i;\n        UNARY_POSTFIX = make_predicate(_$rapyd$_list_decorate([ \"--\", \"++\" ]));\n        OPERATOR_CHARS = make_predicate(characters(\"+-*&%=<>!?|~^@\"));\n        INVALID_OPERATORS = (function(){\n            var s = _$rapyd$_set();\n            s.jsset.add(\"++\");\n            s.jsset.add(\"--\");\n            s.jsset.add(\"===\");\n            s.jsset.add(\"!==\");\n            return s;\n        })();\n        ASCII_CONTROL_CHARS = {\n            \"a\": 7,\n            \"b\": 8,\n            \"f\": 12,\n            \"n\": 10,\n            \"r\": 13,\n            \"t\": 9,\n            \"v\": 11\n        };\n        HEX_PAT = /[a-fA-F0-9]/;\n        NAME_PAT = /[a-zA-Z ]/;\n        OPERATORS = make_predicate(_$rapyd$_list_decorate([ \"in\", \"instanceof\", \"typeof\", \"new\", \"void\", \"del\", \"++\", \"--\", \"+\", \"-\", \"not\", \"~\", \"&\", \"|\", \"^\", \"**\", \"*\", \"//\", \"/\", \"%\", \">>\", \"<<\", \">>>\", \"<\", \">\", \"<=\", \">=\", \"==\", \"===\", \"is\", \"!=\", \"!==\", \"?\", \"=\", \"+=\", \"-=\", \"//=\", \"/=\", \"*=\", \"%=\", \">>=\", \"<<=\", \">>>=\", \"|=\", \"^=\", \"&=\", \"and\", \"or\", \"@\", \"->\" ]));\n        OP_MAP = {\n            \"or\": \"||\",\n            \"and\": \"&&\",\n            \"not\": \"!\",\n            \"del\": \"delete\",\n            \"None\": \"null\",\n            \"is\": \"===\"\n        };\n        WHITESPACE_CHARS = make_predicate(characters(\" \\n\\r\\t\\f\\u000b\\u202f\"));\n        PUNC_BEFORE_EXPRESSION = make_predicate(characters(\"[{(,.;:\"));\n        PUNC_CHARS = make_predicate(characters(\"[]{}(),;:\"));\n        REGEXP_MODIFIERS = make_predicate(characters(\"gmsiy\"));\n        KEYWORDS = \"as break case class const continue debugger def del do elif else except finally for from if import in instanceof is new nonlocal pass raise return yield switch try typeof var void while with or and not delete default\";\n        KEYWORDS_ATOM = \"False None True\";\n        RESERVED_WORDS = \"abstract await boolean byte char delete default double enum export extends final float goto implements int interface long native package private protected public short static super synchronized this throws transient volatile\" + \" \" + KEYWORDS_ATOM + \" \" + KEYWORDS;\n        KEYWORDS_BEFORE_EXPRESSION = \"return yield new del raise elif else if\";\n        ALL_KEYWORDS = RESERVED_WORDS + \" \" + KEYWORDS_BEFORE_EXPRESSION;\n        KEYWORDS = make_predicate(KEYWORDS);\n        RESERVED_WORDS = make_predicate(RESERVED_WORDS);\n        KEYWORDS_BEFORE_EXPRESSION = make_predicate(KEYWORDS_BEFORE_EXPRESSION);\n        KEYWORDS_ATOM = make_predicate(KEYWORDS_ATOM);\n        IDENTIFIER_PAT = /^[a-z_$][_a-z0-9$]*$/i;\n        function is_string_modifier(val) {\n            var ch;\n            var _$rapyd$_Iter23 = _$rapyd$_Iterable(val);\n            for (var _$rapyd$_Index23 = 0; _$rapyd$_Index23 < _$rapyd$_Iter23.length; _$rapyd$_Index23++) {\n                ch = _$rapyd$_Iter23[_$rapyd$_Index23];\n                if (\"vruVRU\".indexOf(ch) === -1) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        is_string_modifier.__argnames__ = [\"val\"];\n\n        function is_letter(code) {\n            return code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 170 && UNICODE.letter.test(String.fromCharCode(code));\n        };\n\n        is_letter.__argnames__ = [\"code\"];\n\n        function is_digit(code) {\n            return code >= 48 && code <= 57;\n        };\n\n        is_digit.__argnames__ = [\"code\"];\n\n        function is_alphanumeric_char(code) {\n            return is_digit(code) || is_letter(code);\n        };\n\n        is_alphanumeric_char.__argnames__ = [\"code\"];\n\n        function is_unicode_combining_mark(ch) {\n            return UNICODE.non_spacing_mark.test(ch) || UNICODE.space_combining_mark.test(ch);\n        };\n\n        is_unicode_combining_mark.__argnames__ = [\"ch\"];\n\n        function is_unicode_connector_punctuation(ch) {\n            return UNICODE.connector_punctuation.test(ch);\n        };\n\n        is_unicode_connector_punctuation.__argnames__ = [\"ch\"];\n\n        function is_identifier(name) {\n            return !RESERVED_WORDS(name) && IDENTIFIER_PAT.test(name);\n        };\n\n        is_identifier.__argnames__ = [\"name\"];\n\n        function is_identifier_start(code) {\n            return code === 36 || code === 95 || is_letter(code);\n        };\n\n        is_identifier_start.__argnames__ = [\"code\"];\n\n        function is_identifier_char(ch) {\n            var code;\n            code = ch.charCodeAt(0);\n            return is_identifier_start(code) || is_digit(code) || code === 8204 || code === 8205 || is_unicode_combining_mark(ch) || is_unicode_connector_punctuation(ch);\n        };\n\n        is_identifier_char.__argnames__ = [\"ch\"];\n\n        function parse_js_number(num) {\n            if (RE_HEX_NUMBER.test(num)) {\n                return parseInt(num.substr(2), 16);\n            } else if (RE_OCT_NUMBER.test(num)) {\n                return parseInt(num.substr(1), 8);\n            } else if (RE_DEC_NUMBER.test(num)) {\n                return parseFloat(num);\n            }\n        };\n\n        parse_js_number.__argnames__ = [\"num\"];\n\n        UNICODE = {\n            \"letter\": new RegExp(\"[\\\\u0041-\\\\u005A\\\\u0061-\\\\u007A\\\\u00AA\\\\u00B5\\\\u00BA\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02C1\\\\u02C6-\\\\u02D1\\\\u02E0-\\\\u02E4\\\\u02EC\\\\u02EE\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037A-\\\\u037D\\\\u0386\\\\u0388-\\\\u038A\\\\u038C\\\\u038E-\\\\u03A1\\\\u03A3-\\\\u03F5\\\\u03F7-\\\\u0481\\\\u048A-\\\\u0523\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05D0-\\\\u05EA\\\\u05F0-\\\\u05F2\\\\u0621-\\\\u064A\\\\u066E\\\\u066F\\\\u0671-\\\\u06D3\\\\u06D5\\\\u06E5\\\\u06E6\\\\u06EE\\\\u06EF\\\\u06FA-\\\\u06FC\\\\u06FF\\\\u0710\\\\u0712-\\\\u072F\\\\u074D-\\\\u07A5\\\\u07B1\\\\u07CA-\\\\u07EA\\\\u07F4\\\\u07F5\\\\u07FA\\\\u0904-\\\\u0939\\\\u093D\\\\u0950\\\\u0958-\\\\u0961\\\\u0971\\\\u0972\\\\u097B-\\\\u097F\\\\u0985-\\\\u098C\\\\u098F\\\\u0990\\\\u0993-\\\\u09A8\\\\u09AA-\\\\u09B0\\\\u09B2\\\\u09B6-\\\\u09B9\\\\u09BD\\\\u09CE\\\\u09DC\\\\u09DD\\\\u09DF-\\\\u09E1\\\\u09F0\\\\u09F1\\\\u0A05-\\\\u0A0A\\\\u0A0F\\\\u0A10\\\\u0A13-\\\\u0A28\\\\u0A2A-\\\\u0A30\\\\u0A32\\\\u0A33\\\\u0A35\\\\u0A36\\\\u0A38\\\\u0A39\\\\u0A59-\\\\u0A5C\\\\u0A5E\\\\u0A72-\\\\u0A74\\\\u0A85-\\\\u0A8D\\\\u0A8F-\\\\u0A91\\\\u0A93-\\\\u0AA8\\\\u0AAA-\\\\u0AB0\\\\u0AB2\\\\u0AB3\\\\u0AB5-\\\\u0AB9\\\\u0ABD\\\\u0AD0\\\\u0AE0\\\\u0AE1\\\\u0B05-\\\\u0B0C\\\\u0B0F\\\\u0B10\\\\u0B13-\\\\u0B28\\\\u0B2A-\\\\u0B30\\\\u0B32\\\\u0B33\\\\u0B35-\\\\u0B39\\\\u0B3D\\\\u0B5C\\\\u0B5D\\\\u0B5F-\\\\u0B61\\\\u0B71\\\\u0B83\\\\u0B85-\\\\u0B8A\\\\u0B8E-\\\\u0B90\\\\u0B92-\\\\u0B95\\\\u0B99\\\\u0B9A\\\\u0B9C\\\\u0B9E\\\\u0B9F\\\\u0BA3\\\\u0BA4\\\\u0BA8-\\\\u0BAA\\\\u0BAE-\\\\u0BB9\\\\u0BD0\\\\u0C05-\\\\u0C0C\\\\u0C0E-\\\\u0C10\\\\u0C12-\\\\u0C28\\\\u0C2A-\\\\u0C33\\\\u0C35-\\\\u0C39\\\\u0C3D\\\\u0C58\\\\u0C59\\\\u0C60\\\\u0C61\\\\u0C85-\\\\u0C8C\\\\u0C8E-\\\\u0C90\\\\u0C92-\\\\u0CA8\\\\u0CAA-\\\\u0CB3\\\\u0CB5-\\\\u0CB9\\\\u0CBD\\\\u0CDE\\\\u0CE0\\\\u0CE1\\\\u0D05-\\\\u0D0C\\\\u0D0E-\\\\u0D10\\\\u0D12-\\\\u0D28\\\\u0D2A-\\\\u0D39\\\\u0D3D\\\\u0D60\\\\u0D61\\\\u0D7A-\\\\u0D7F\\\\u0D85-\\\\u0D96\\\\u0D9A-\\\\u0DB1\\\\u0DB3-\\\\u0DBB\\\\u0DBD\\\\u0DC0-\\\\u0DC6\\\\u0E01-\\\\u0E30\\\\u0E32\\\\u0E33\\\\u0E40-\\\\u0E46\\\\u0E81\\\\u0E82\\\\u0E84\\\\u0E87\\\\u0E88\\\\u0E8A\\\\u0E8D\\\\u0E94-\\\\u0E97\\\\u0E99-\\\\u0E9F\\\\u0EA1-\\\\u0EA3\\\\u0EA5\\\\u0EA7\\\\u0EAA\\\\u0EAB\\\\u0EAD-\\\\u0EB0\\\\u0EB2\\\\u0EB3\\\\u0EBD\\\\u0EC0-\\\\u0EC4\\\\u0EC6\\\\u0EDC\\\\u0EDD\\\\u0F00\\\\u0F40-\\\\u0F47\\\\u0F49-\\\\u0F6C\\\\u0F88-\\\\u0F8B\\\\u1000-\\\\u102A\\\\u103F\\\\u1050-\\\\u1055\\\\u105A-\\\\u105D\\\\u1061\\\\u1065\\\\u1066\\\\u106E-\\\\u1070\\\\u1075-\\\\u1081\\\\u108E\\\\u10A0-\\\\u10C5\\\\u10D0-\\\\u10FA\\\\u10FC\\\\u1100-\\\\u1159\\\\u115F-\\\\u11A2\\\\u11A8-\\\\u11F9\\\\u1200-\\\\u1248\\\\u124A-\\\\u124D\\\\u1250-\\\\u1256\\\\u1258\\\\u125A-\\\\u125D\\\\u1260-\\\\u1288\\\\u128A-\\\\u128D\\\\u1290-\\\\u12B0\\\\u12B2-\\\\u12B5\\\\u12B8-\\\\u12BE\\\\u12C0\\\\u12C2-\\\\u12C5\\\\u12C8-\\\\u12D6\\\\u12D8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135A\\\\u1380-\\\\u138F\\\\u13A0-\\\\u13F4\\\\u1401-\\\\u166C\\\\u166F-\\\\u1676\\\\u1681-\\\\u169A\\\\u16A0-\\\\u16EA\\\\u1700-\\\\u170C\\\\u170E-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176C\\\\u176E-\\\\u1770\\\\u1780-\\\\u17B3\\\\u17D7\\\\u17DC\\\\u1820-\\\\u1877\\\\u1880-\\\\u18A8\\\\u18AA\\\\u1900-\\\\u191C\\\\u1950-\\\\u196D\\\\u1970-\\\\u1974\\\\u1980-\\\\u19A9\\\\u19C1-\\\\u19C7\\\\u1A00-\\\\u1A16\\\\u1B05-\\\\u1B33\\\\u1B45-\\\\u1B4B\\\\u1B83-\\\\u1BA0\\\\u1BAE\\\\u1BAF\\\\u1C00-\\\\u1C23\\\\u1C4D-\\\\u1C4F\\\\u1C5A-\\\\u1C7D\\\\u1D00-\\\\u1DBF\\\\u1E00-\\\\u1F15\\\\u1F18-\\\\u1F1D\\\\u1F20-\\\\u1F45\\\\u1F48-\\\\u1F4D\\\\u1F50-\\\\u1F57\\\\u1F59\\\\u1F5B\\\\u1F5D\\\\u1F5F-\\\\u1F7D\\\\u1F80-\\\\u1FB4\\\\u1FB6-\\\\u1FBC\\\\u1FBE\\\\u1FC2-\\\\u1FC4\\\\u1FC6-\\\\u1FCC\\\\u1FD0-\\\\u1FD3\\\\u1FD6-\\\\u1FDB\\\\u1FE0-\\\\u1FEC\\\\u1FF2-\\\\u1FF4\\\\u1FF6-\\\\u1FFC\\\\u2071\\\\u207F\\\\u2090-\\\\u2094\\\\u2102\\\\u2107\\\\u210A-\\\\u2113\\\\u2115\\\\u2119-\\\\u211D\\\\u2124\\\\u2126\\\\u2128\\\\u212A-\\\\u212D\\\\u212F-\\\\u2139\\\\u213C-\\\\u213F\\\\u2145-\\\\u2149\\\\u214E\\\\u2183\\\\u2184\\\\u2C00-\\\\u2C2E\\\\u2C30-\\\\u2C5E\\\\u2C60-\\\\u2C6F\\\\u2C71-\\\\u2C7D\\\\u2C80-\\\\u2CE4\\\\u2D00-\\\\u2D25\\\\u2D30-\\\\u2D65\\\\u2D6F\\\\u2D80-\\\\u2D96\\\\u2DA0-\\\\u2DA6\\\\u2DA8-\\\\u2DAE\\\\u2DB0-\\\\u2DB6\\\\u2DB8-\\\\u2DBE\\\\u2DC0-\\\\u2DC6\\\\u2DC8-\\\\u2DCE\\\\u2DD0-\\\\u2DD6\\\\u2DD8-\\\\u2DDE\\\\u2E2F\\\\u3005\\\\u3006\\\\u3031-\\\\u3035\\\\u303B\\\\u303C\\\\u3041-\\\\u3096\\\\u309D-\\\\u309F\\\\u30A1-\\\\u30FA\\\\u30FC-\\\\u30FF\\\\u3105-\\\\u312D\\\\u3131-\\\\u318E\\\\u31A0-\\\\u31B7\\\\u31F0-\\\\u31FF\\\\u3400\\\\u4DB5\\\\u4E00\\\\u9FC3\\\\uA000-\\\\uA48C\\\\uA500-\\\\uA60C\\\\uA610-\\\\uA61F\\\\uA62A\\\\uA62B\\\\uA640-\\\\uA65F\\\\uA662-\\\\uA66E\\\\uA67F-\\\\uA697\\\\uA717-\\\\uA71F\\\\uA722-\\\\uA788\\\\uA78B\\\\uA78C\\\\uA7FB-\\\\uA801\\\\uA803-\\\\uA805\\\\uA807-\\\\uA80A\\\\uA80C-\\\\uA822\\\\uA840-\\\\uA873\\\\uA882-\\\\uA8B3\\\\uA90A-\\\\uA925\\\\uA930-\\\\uA946\\\\uAA00-\\\\uAA28\\\\uAA40-\\\\uAA42\\\\uAA44-\\\\uAA4B\\\\uAC00\\\\uD7A3\\\\uF900-\\\\uFA2D\\\\uFA30-\\\\uFA6A\\\\uFA70-\\\\uFAD9\\\\uFB00-\\\\uFB06\\\\uFB13-\\\\uFB17\\\\uFB1D\\\\uFB1F-\\\\uFB28\\\\uFB2A-\\\\uFB36\\\\uFB38-\\\\uFB3C\\\\uFB3E\\\\uFB40\\\\uFB41\\\\uFB43\\\\uFB44\\\\uFB46-\\\\uFBB1\\\\uFBD3-\\\\uFD3D\\\\uFD50-\\\\uFD8F\\\\uFD92-\\\\uFDC7\\\\uFDF0-\\\\uFDFB\\\\uFE70-\\\\uFE74\\\\uFE76-\\\\uFEFC\\\\uFF21-\\\\uFF3A\\\\uFF41-\\\\uFF5A\\\\uFF66-\\\\uFFBE\\\\uFFC2-\\\\uFFC7\\\\uFFCA-\\\\uFFCF\\\\uFFD2-\\\\uFFD7\\\\uFFDA-\\\\uFFDC]\"),\n            \"non_spacing_mark\": new RegExp(\"[\\\\u0300-\\\\u036F\\\\u0483-\\\\u0487\\\\u0591-\\\\u05BD\\\\u05BF\\\\u05C1\\\\u05C2\\\\u05C4\\\\u05C5\\\\u05C7\\\\u0610-\\\\u061A\\\\u064B-\\\\u065E\\\\u0670\\\\u06D6-\\\\u06DC\\\\u06DF-\\\\u06E4\\\\u06E7\\\\u06E8\\\\u06EA-\\\\u06ED\\\\u0711\\\\u0730-\\\\u074A\\\\u07A6-\\\\u07B0\\\\u07EB-\\\\u07F3\\\\u0816-\\\\u0819\\\\u081B-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082D\\\\u0900-\\\\u0902\\\\u093C\\\\u0941-\\\\u0948\\\\u094D\\\\u0951-\\\\u0955\\\\u0962\\\\u0963\\\\u0981\\\\u09BC\\\\u09C1-\\\\u09C4\\\\u09CD\\\\u09E2\\\\u09E3\\\\u0A01\\\\u0A02\\\\u0A3C\\\\u0A41\\\\u0A42\\\\u0A47\\\\u0A48\\\\u0A4B-\\\\u0A4D\\\\u0A51\\\\u0A70\\\\u0A71\\\\u0A75\\\\u0A81\\\\u0A82\\\\u0ABC\\\\u0AC1-\\\\u0AC5\\\\u0AC7\\\\u0AC8\\\\u0ACD\\\\u0AE2\\\\u0AE3\\\\u0B01\\\\u0B3C\\\\u0B3F\\\\u0B41-\\\\u0B44\\\\u0B4D\\\\u0B56\\\\u0B62\\\\u0B63\\\\u0B82\\\\u0BC0\\\\u0BCD\\\\u0C3E-\\\\u0C40\\\\u0C46-\\\\u0C48\\\\u0C4A-\\\\u0C4D\\\\u0C55\\\\u0C56\\\\u0C62\\\\u0C63\\\\u0CBC\\\\u0CBF\\\\u0CC6\\\\u0CCC\\\\u0CCD\\\\u0CE2\\\\u0CE3\\\\u0D41-\\\\u0D44\\\\u0D4D\\\\u0D62\\\\u0D63\\\\u0DCA\\\\u0DD2-\\\\u0DD4\\\\u0DD6\\\\u0E31\\\\u0E34-\\\\u0E3A\\\\u0E47-\\\\u0E4E\\\\u0EB1\\\\u0EB4-\\\\u0EB9\\\\u0EBB\\\\u0EBC\\\\u0EC8-\\\\u0ECD\\\\u0F18\\\\u0F19\\\\u0F35\\\\u0F37\\\\u0F39\\\\u0F71-\\\\u0F7E\\\\u0F80-\\\\u0F84\\\\u0F86\\\\u0F87\\\\u0F90-\\\\u0F97\\\\u0F99-\\\\u0FBC\\\\u0FC6\\\\u102D-\\\\u1030\\\\u1032-\\\\u1037\\\\u1039\\\\u103A\\\\u103D\\\\u103E\\\\u1058\\\\u1059\\\\u105E-\\\\u1060\\\\u1071-\\\\u1074\\\\u1082\\\\u1085\\\\u1086\\\\u108D\\\\u109D\\\\u135F\\\\u1712-\\\\u1714\\\\u1732-\\\\u1734\\\\u1752\\\\u1753\\\\u1772\\\\u1773\\\\u17B7-\\\\u17BD\\\\u17C6\\\\u17C9-\\\\u17D3\\\\u17DD\\\\u180B-\\\\u180D\\\\u18A9\\\\u1920-\\\\u1922\\\\u1927\\\\u1928\\\\u1932\\\\u1939-\\\\u193B\\\\u1A17\\\\u1A18\\\\u1A56\\\\u1A58-\\\\u1A5E\\\\u1A60\\\\u1A62\\\\u1A65-\\\\u1A6C\\\\u1A73-\\\\u1A7C\\\\u1A7F\\\\u1B00-\\\\u1B03\\\\u1B34\\\\u1B36-\\\\u1B3A\\\\u1B3C\\\\u1B42\\\\u1B6B-\\\\u1B73\\\\u1B80\\\\u1B81\\\\u1BA2-\\\\u1BA5\\\\u1BA8\\\\u1BA9\\\\u1C2C-\\\\u1C33\\\\u1C36\\\\u1C37\\\\u1CD0-\\\\u1CD2\\\\u1CD4-\\\\u1CE0\\\\u1CE2-\\\\u1CE8\\\\u1CED\\\\u1DC0-\\\\u1DE6\\\\u1DFD-\\\\u1DFF\\\\u20D0-\\\\u20DC\\\\u20E1\\\\u20E5-\\\\u20F0\\\\u2CEF-\\\\u2CF1\\\\u2DE0-\\\\u2DFF\\\\u302A-\\\\u302F\\\\u3099\\\\u309A\\\\uA66F\\\\uA67C\\\\uA67D\\\\uA6F0\\\\uA6F1\\\\uA802\\\\uA806\\\\uA80B\\\\uA825\\\\uA826\\\\uA8C4\\\\uA8E0-\\\\uA8F1\\\\uA926-\\\\uA92D\\\\uA947-\\\\uA951\\\\uA980-\\\\uA982\\\\uA9B3\\\\uA9B6-\\\\uA9B9\\\\uA9BC\\\\uAA29-\\\\uAA2E\\\\uAA31\\\\uAA32\\\\uAA35\\\\uAA36\\\\uAA43\\\\uAA4C\\\\uAAB0\\\\uAAB2-\\\\uAAB4\\\\uAAB7\\\\uAAB8\\\\uAABE\\\\uAABF\\\\uAAC1\\\\uABE5\\\\uABE8\\\\uABED\\\\uFB1E\\\\uFE00-\\\\uFE0F\\\\uFE20-\\\\uFE26]\"),\n            \"space_combining_mark\": new RegExp(\"[\\\\u0903\\\\u093E-\\\\u0940\\\\u0949-\\\\u094C\\\\u094E\\\\u0982\\\\u0983\\\\u09BE-\\\\u09C0\\\\u09C7\\\\u09C8\\\\u09CB\\\\u09CC\\\\u09D7\\\\u0A03\\\\u0A3E-\\\\u0A40\\\\u0A83\\\\u0ABE-\\\\u0AC0\\\\u0AC9\\\\u0ACB\\\\u0ACC\\\\u0B02\\\\u0B03\\\\u0B3E\\\\u0B40\\\\u0B47\\\\u0B48\\\\u0B4B\\\\u0B4C\\\\u0B57\\\\u0BBE\\\\u0BBF\\\\u0BC1\\\\u0BC2\\\\u0BC6-\\\\u0BC8\\\\u0BCA-\\\\u0BCC\\\\u0BD7\\\\u0C01-\\\\u0C03\\\\u0C41-\\\\u0C44\\\\u0C82\\\\u0C83\\\\u0CBE\\\\u0CC0-\\\\u0CC4\\\\u0CC7\\\\u0CC8\\\\u0CCA\\\\u0CCB\\\\u0CD5\\\\u0CD6\\\\u0D02\\\\u0D03\\\\u0D3E-\\\\u0D40\\\\u0D46-\\\\u0D48\\\\u0D4A-\\\\u0D4C\\\\u0D57\\\\u0D82\\\\u0D83\\\\u0DCF-\\\\u0DD1\\\\u0DD8-\\\\u0DDF\\\\u0DF2\\\\u0DF3\\\\u0F3E\\\\u0F3F\\\\u0F7F\\\\u102B\\\\u102C\\\\u1031\\\\u1038\\\\u103B\\\\u103C\\\\u1056\\\\u1057\\\\u1062-\\\\u1064\\\\u1067-\\\\u106D\\\\u1083\\\\u1084\\\\u1087-\\\\u108C\\\\u108F\\\\u109A-\\\\u109C\\\\u17B6\\\\u17BE-\\\\u17C5\\\\u17C7\\\\u17C8\\\\u1923-\\\\u1926\\\\u1929-\\\\u192B\\\\u1930\\\\u1931\\\\u1933-\\\\u1938\\\\u19B0-\\\\u19C0\\\\u19C8\\\\u19C9\\\\u1A19-\\\\u1A1B\\\\u1A55\\\\u1A57\\\\u1A61\\\\u1A63\\\\u1A64\\\\u1A6D-\\\\u1A72\\\\u1B04\\\\u1B35\\\\u1B3B\\\\u1B3D-\\\\u1B41\\\\u1B43\\\\u1B44\\\\u1B82\\\\u1BA1\\\\u1BA6\\\\u1BA7\\\\u1BAA\\\\u1C24-\\\\u1C2B\\\\u1C34\\\\u1C35\\\\u1CE1\\\\u1CF2\\\\uA823\\\\uA824\\\\uA827\\\\uA880\\\\uA881\\\\uA8B4-\\\\uA8C3\\\\uA952\\\\uA953\\\\uA983\\\\uA9B4\\\\uA9B5\\\\uA9BA\\\\uA9BB\\\\uA9BD-\\\\uA9C0\\\\uAA2F\\\\uAA30\\\\uAA33\\\\uAA34\\\\uAA4D\\\\uAA7B\\\\uABE3\\\\uABE4\\\\uABE6\\\\uABE7\\\\uABE9\\\\uABEA\\\\uABEC]\"),\n            \"connector_punctuation\": new RegExp(\"[\\\\u005F\\\\u203F\\\\u2040\\\\u2054\\\\uFE33\\\\uFE34\\\\uFE4D-\\\\uFE4F\\\\uFF3F]\")\n        };\n        function is_token(token, type, val) {\n            return token.type === type && (val === null || val === undefined || token.value === val);\n        };\n\n        is_token.__argnames__ = [\"token\", \"type\", \"val\"];\n\n        EX_EOF = {};\n        function tokenizer($TEXT, filename) {\n            var S, read_string, read_regexp;\n            S = {\n                \"text\": $TEXT.replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, \"\\n\").replace(/\\uFEFF/g, \"\"),\n                \"filename\": filename,\n                \"pos\": 0,\n                \"tokpos\": 0,\n                \"line\": 1,\n                \"tokline\": 0,\n                \"col\": 0,\n                \"tokcol\": 0,\n                \"newline_before\": false,\n                \"regex_allowed\": false,\n                \"comments_before\": [],\n                \"whitespace_before\": [],\n                \"newblock\": false,\n                \"endblock\": false,\n                \"indentation_matters\": [ true ],\n                \"cached_whitespace\": \"\",\n                \"prev\": undefined,\n                \"index_or_slice\": [ false ],\n                \"expecting_object_literal_key\": false\n            };\n            function peek() {\n                return S.text.charAt(S.pos);\n            };\n\n            function prevChar() {\n                return S.text.charAt(S.tokpos - 1);\n            };\n\n            function next(signal_eof, in_string) {\n                var ch;\n                ch = S.text.charAt(S.pos);\n                S.pos += 1;\n                if (signal_eof && !ch) {\n                    throw EX_EOF;\n                }\n                if (ch === \"\\n\") {\n                    S.newline_before = S.newline_before || !in_string;\n                    S.line += 1;\n                    S.col = 0;\n                } else {\n                    S.col += 1;\n                }\n                return ch;\n            };\n\n            next.__argnames__ = [\"signal_eof\", \"in_string\"];\n\n            function find(what, signal_eof) {\n                var pos;\n                pos = S.text.indexOf(what, S.pos);\n                if (signal_eof && pos === -1) {\n                    throw EX_EOF;\n                }\n                return pos;\n            };\n\n            find.__argnames__ = [\"what\", \"signal_eof\"];\n\n            function start_token() {\n                S.tokline = S.line;\n                S.tokcol = S.col;\n                S.tokpos = S.pos;\n            };\n\n            function token(type, value, is_comment, keep_newline) {\n                var ret, i;\n                S.regex_allowed = type === \"operator\" && !UNARY_POSTFIX[value] || type === \"keyword\" && KEYWORDS_BEFORE_EXPRESSION(value) || type === \"punc\" && PUNC_BEFORE_EXPRESSION(value);\n                if (type === \"operator\" && value === \"is\" && S.text.substr(S.pos).trimLeft().substr(0, 4).trimRight() === \"not\") {\n                    next_token();\n                    value = \"!==\";\n                }\n                if (type === \"operator\" && OP_MAP[value]) {\n                    value = OP_MAP[value];\n                }\n                ret = {\n                    \"type\": type,\n                    \"value\": value,\n                    \"line\": S.tokline,\n                    \"col\": S.tokcol,\n                    \"pos\": S.tokpos,\n                    \"endpos\": S.pos,\n                    \"nlb\": S.newline_before,\n                    \"file\": filename\n                };\n                if (!is_comment) {\n                    ret.comments_before = S.comments_before;\n                    S.comments_before = [];\n                    for (var _$rapyd$_Index24 = 0; _$rapyd$_Index24 < ret.comments_before.length; _$rapyd$_Index24++) {\n                        i = _$rapyd$_Index24;\n                        ret.nlb = ret.nlb || ret.comments_before[i].nlb;\n                    }\n                }\n                if (!keep_newline) {\n                    S.newline_before = false;\n                }\n                if (type === \"punc\") {\n                    if (value === \":\" && !S.index_or_slice[S.index_or_slice.length-1] && !S.expecting_object_literal_key && (!S.text.substring(S.pos + 1, find(\"\\n\")).trim() || !S.text.substring(S.pos + 1, find(\"#\")).trim())) {\n                        S.newblock = true;\n                        S.indentation_matters.push(true);\n                    }\n                    if (value === \"[\") {\n                        if (S.prev && (S.prev.type === \"name\" || S.prev.type === \"punc\" && \")]\".indexOf(S.prev.value) !== -1)) {\n                            S.index_or_slice.push(true);\n                        } else {\n                            S.index_or_slice.push(false);\n                        }\n                        S.indentation_matters.push(false);\n                    } else if (value === \"{\" || value === \"(\") {\n                        S.indentation_matters.push(false);\n                    } else if (value === \"]\") {\n                        S.index_or_slice.pop();\n                        S.indentation_matters.pop();\n                    } else if (value === \"}\" || value === \")\") {\n                        S.indentation_matters.pop();\n                    }\n                }\n                S.prev = new AST_Token(ret);\n                return S.prev;\n            };\n\n            token.__argnames__ = [\"type\", \"value\", \"is_comment\", \"keep_newline\"];\n\n            function parse_whitespace() {\n                var leading_whitespace, whitespace_exists, ch;\n                leading_whitespace = \"\";\n                whitespace_exists = false;\n                while (WHITESPACE_CHARS(peek())) {\n                    whitespace_exists = true;\n                    ch = next();\n                    if (ch === \"\\n\") {\n                        leading_whitespace = \"\";\n                    } else {\n                        leading_whitespace += ch;\n                    }\n                }\n                if (peek() !== \"#\") {\n                    if (!whitespace_exists) {\n                        leading_whitespace = S.cached_whitespace;\n                    } else {\n                        S.cached_whitespace = leading_whitespace;\n                    }\n                    if (S.newline_before || S.endblock) {\n                        return test_indent_token(leading_whitespace);\n                    }\n                }\n            };\n\n            function test_indent_token(leading_whitespace) {\n                var most_recent;\n                most_recent = S.whitespace_before[S.whitespace_before.length-1] || \"\";\n                S.endblock = false;\n                if (S.indentation_matters[S.indentation_matters.length-1] && leading_whitespace !== most_recent) {\n                    if (S.newblock && leading_whitespace && leading_whitespace.indexOf(most_recent) === 0) {\n                        S.newblock = false;\n                        S.whitespace_before.push(leading_whitespace);\n                        return 1;\n                    } else if (most_recent && most_recent.indexOf(leading_whitespace) === 0) {\n                        S.endblock = true;\n                        S.whitespace_before.pop();\n                        return -1;\n                    } else {\n                        parse_error(\"Inconsistent indentation\");\n                    }\n                } else {\n                    return 0;\n                }\n            };\n\n            test_indent_token.__argnames__ = [\"leading_whitespace\"];\n\n            function read_while(pred) {\n                var ret, i, ch;\n                ret = \"\";\n                i = 0;\n                ch = \"\";\n                while ((ch = peek()) && pred(ch, i)) {\n                    i += 1;\n                    ret += next();\n                }\n                return ret;\n            };\n\n            read_while.__argnames__ = [\"pred\"];\n\n            function parse_error(err, is_eof) {\n                throw new SyntaxError(err, filename, S.tokline, S.tokcol, S.tokpos, is_eof);\n            };\n\n            parse_error.__argnames__ = [\"err\", \"is_eof\"];\n\n            function read_num(prefix) {\n                var has_e, has_x, has_dot, num, valid, seen;\n                has_e = false;\n                has_x = false;\n                has_dot = prefix === \".\";\n                if (!prefix && peek() === \"0\" && S.text.charAt(S.pos + 1) === \"b\") {\n                    [next(), next()];\n                    num = read_while((function() {\n                        var _$rapyd$_anonfunc = function (ch) {\n                            return ch === \"0\" || ch === \"1\";\n                        };\n\n                        _$rapyd$_anonfunc.__argnames__ = [\"ch\"];\n                        return _$rapyd$_anonfunc;\n                    })());\n                    valid = parseInt(num, 2);\n                    if (isNaN(valid)) {\n                        parse_error(\"Invalid syntax for a binary number\");\n                    }\n                    return token(\"num\", valid);\n                }\n                seen = [];\n                num = read_while((function() {\n                    var _$rapyd$_anonfunc = function (ch, i) {\n                        seen.push(ch);\n                        if (ch === \"x\" || ch === \"X\") {\n                            if (has_x || seen.length !== 2 || seen[0] !== \"0\") {\n                                return false;\n                            }\n                            has_x = true;\n                            return true;\n                        } else if (ch === \"e\" || ch === \"E\") {\n                            if (has_x) {\n                                return true;\n                            }\n                            if (has_e || (i === 0 || typeof i === \"object\" && _$rapyd$_equals(i, 0))) {\n                                return false;\n                            }\n                            has_e = true;\n                            return true;\n                        } else if (ch === \"-\") {\n                            if (i === 0 && !prefix) {\n                                return true;\n                            }\n                            if (has_e && seen[i - 1].toLowerCase() === \"e\") {\n                                return true;\n                            }\n                            return false;\n                        } else if (ch === \"+\") {\n                            if (has_e && seen[i - 1].toLowerCase() === \"e\") {\n                                return true;\n                            }\n                            return false;\n                        } else if (ch === \".\") {\n                            return (!has_dot && !has_x && !has_e) ? has_dot = true : false;\n                        }\n                        return is_alphanumeric_char(ch.charCodeAt(0));\n                    };\n\n                    _$rapyd$_anonfunc.__argnames__ = [\"ch\", \"i\"];\n                    return _$rapyd$_anonfunc;\n                })());\n                if (prefix) {\n                    num = prefix + num;\n                }\n                valid = parse_js_number(num);\n                if (!isNaN(valid)) {\n                    return token(\"num\", valid);\n                } else {\n                    parse_error(\"Invalid syntax: \" + num);\n                }\n            };\n\n            read_num.__argnames__ = [\"prefix\"];\n\n            function read_hex_digits(count) {\n                var ans, nval;\n                ans = \"\";\n                while (count > 0) {\n                    count -= 1;\n                    if (!HEX_PAT.test(peek())) {\n                        return ans;\n                    }\n                    ans += next();\n                }\n                nval = parseInt(ans, 16);\n                if (nval > 1114111) {\n                    return ans;\n                }\n                return nval;\n            };\n\n            read_hex_digits.__argnames__ = [\"count\"];\n\n            function read_escape_sequence() {\n                var q, octal, code, name, key;\n                q = next(true);\n                if (q === \"\\n\") {\n                    return \"\";\n                }\n                if (q === \"\\\\\") {\n                    return q;\n                }\n                if (\"\\\"'\".indexOf(q) !== -1) {\n                    return q;\n                }\n                if (ASCII_CONTROL_CHARS.hasOwnProperty(q)) {\n                    return String.fromCharCode(ASCII_CONTROL_CHARS[q]);\n                }\n                if (\"0\" <= q && q <= \"7\") {\n                    octal = q;\n                    if (\"0\" <= (_$rapyd$_cond_temp = peek()) && _$rapyd$_cond_temp <= \"7\") {\n                        octal += next();\n                    }\n                    if (\"0\" <= (_$rapyd$_cond_temp = peek()) && _$rapyd$_cond_temp <= \"7\") {\n                        octal += next();\n                    }\n                    code = parseInt(octal, 8);\n                    if (isNaN(code)) {\n                        return \"\\\\\" + octal;\n                    }\n                    return String.fromCharCode(code);\n                }\n                if (q === \"x\") {\n                    code = read_hex_digits(2);\n                    if (typeof code === \"number\") {\n                        return String.fromCharCode(code);\n                    }\n                    return \"\\\\x\" + code;\n                }\n                if (q === \"u\") {\n                    code = read_hex_digits(4);\n                    if (typeof code === \"number\") {\n                        return String.fromCharCode(code);\n                    }\n                    return \"\\\\u\" + code;\n                }\n                if (q === \"U\") {\n                    code = read_hex_digits(8);\n                    if (typeof code === \"number\") {\n                        if (code <= 65535) {\n                            return String.fromCharCode(code);\n                        }\n                        code -= 65536;\n                        return String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n                    }\n                    return \"\\\\U\" + code;\n                }\n                if (q === \"N\" && peek() === \"{\") {\n                    next();\n                    name = read_while((function() {\n                        var _$rapyd$_anonfunc = function (ch) {\n                            return NAME_PAT.test(ch);\n                        };\n\n                        _$rapyd$_anonfunc.__argnames__ = [\"ch\"];\n                        return _$rapyd$_anonfunc;\n                    })());\n                    if (peek() !== \"}\") {\n                        return \"\\\\N{\" + name;\n                    }\n                    next();\n                    key = (name || \"\").toLowerCase();\n                    if (!name || !Object.prototype.hasOwnProperty.call(ALIAS_MAP, key)) {\n                        return \"\\\\N{\" + name + \"}\";\n                    }\n                    code = ALIAS_MAP[key];\n                    if (code <= 65535) {\n                        return String.fromCharCode(code);\n                    }\n                    code -= 65536;\n                    return String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n                }\n                return \"\\\\\" + q;\n            };\n\n            function with_eof_error(eof_error, cont) {\n                return (function() {\n                    var _$rapyd$_anonfunc = function () {\n                        try {\n                            return cont.apply(null, arguments);\n                        } catch (_$rapyd$_Exception) {\n                            var ex = _$rapyd$_Exception;\n                            if (ex === EX_EOF) {\n                                parse_error(eof_error, true);\n                            } else {\n                                throw _$rapyd$_Exception;\n                            }\n                        }\n                    };\n                    return _$rapyd$_anonfunc;\n                })();\n            };\n\n            with_eof_error.__argnames__ = [\"eof_error\", \"cont\"];\n\n            read_string = with_eof_error(\"Unterminated string constant\", (function() {\n                var _$rapyd$_anonfunc = function (is_raw_literal, is_js_literal) {\n                    var quote, tok_type, ret, is_multiline, ch;\n                    quote = next();\n                    tok_type = (is_js_literal) ? \"js\" : \"string\";\n                    ret = \"\";\n                    is_multiline = false;\n                    if (peek() === quote) {\n                        next(true);\n                        if (peek() === quote) {\n                            next(true);\n                            is_multiline = true;\n                        } else {\n                            return token(tok_type, \"\");\n                        }\n                    }\n                    while (ch = next(true)) {\n                        if (ch === \"\\n\" && !is_multiline) {\n                            parse_error(\"End of line while scanning string literal\");\n                        }\n                        if (ch === \"\\\\\") {\n                            ret += (is_raw_literal) ? \"\\\\\" + next(true) : read_escape_sequence();\n                            continue;\n                        }\n                        if (ch === quote) {\n                            if (!is_multiline) {\n                                break;\n                            }\n                            if (peek() === quote) {\n                                next();\n                                if (peek() === quote) {\n                                    next();\n                                    break;\n                                } else {\n                                    ch += quote;\n                                }\n                            }\n                        }\n                        ret += ch;\n                    }\n                    return token(tok_type, ret);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"is_raw_literal\", \"is_js_literal\"];\n                return _$rapyd$_anonfunc;\n            })());\n            function read_line_comment() {\n                var shebang = (arguments[0] === undefined || ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? read_line_comment.__defaults__.shebang : arguments[0];\n                var _$rapyd$_kwargs_obj = arguments[arguments.length-1];\n                if (_$rapyd$_kwargs_obj === null || typeof _$rapyd$_kwargs_obj !== \"object\" || _$rapyd$_kwargs_obj [_$rapyd$_kwargs_symbol] !== true) _$rapyd$_kwargs_obj = {};\n                if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"shebang\")){\n                    shebang = _$rapyd$_kwargs_obj.shebang;\n                }\n                var i, ret;\n                if (!shebang) {\n                    next();\n                }\n                i = find(\"\\n\");\n                if (i === -1) {\n                    ret = S.text.substr(S.pos);\n                    S.pos = S.text.length;\n                } else {\n                    ret = S.text.substring(S.pos, i);\n                    S.pos = i;\n                }\n                return token((shebang) ? \"shebang\" : \"comment1\", ret, true);\n            };\n\n            read_line_comment.__defaults__ = {\n                shebang:false\n            };\n\n            read_line_comment.__handles_kwarg_interpolation__ = true;\n\n            read_line_comment.__argnames__ = [\"shebang\"];\n\n            function read_name() {\n                var name, ch, _$rapyd$_chain_assign_temp;\n                _$rapyd$_chain_assign_temp = \"\";\n                name = _$rapyd$_chain_assign_temp;\n                ch = _$rapyd$_chain_assign_temp;\n;\n                while ((ch = peek()) !== null) {\n                    if (ch === \"\\\\\") {\n                        if (S.text.charAt(S.pos + 1) === \"\\n\") {\n                            S.pos += 2;\n                            continue;\n                        }\n                        break;\n                    } else if (is_identifier_char(ch)) {\n                        name += next();\n                    } else {\n                        break;\n                    }\n                }\n                return name;\n            };\n\n            read_regexp = with_eof_error(\"Unterminated regular expression\", (function() {\n                var _$rapyd$_anonfunc = function () {\n                    var prev_backslash, regexp, ch, _$rapyd$_chain_assign_temp, in_class, verbose_regexp, in_comment, mods;\n                    prev_backslash = false;\n                    _$rapyd$_chain_assign_temp = \"\";\n                    regexp = _$rapyd$_chain_assign_temp;\n                    ch = _$rapyd$_chain_assign_temp;\n;\n                    in_class = false;\n                    verbose_regexp = false;\n                    in_comment = false;\n                    if (peek() === \"/\") {\n                        next(true);\n                        if (peek() === \"/\") {\n                            verbose_regexp = true;\n                            next(true);\n                        } else {\n                            mods = read_name();\n                            return token(\"regexp\", new RegExp(regexp, mods));\n                        }\n                    }\n                    while (ch = next(true)) {\n                        if (in_comment) {\n                            if (ch === \"\\n\") {\n                                in_comment = false;\n                            }\n                            continue;\n                        }\n                        if (prev_backslash) {\n                            regexp += \"\\\\\" + ch;\n                            prev_backslash = false;\n                        } else if (ch === \"[\") {\n                            in_class = true;\n                            regexp += ch;\n                        } else if (ch === \"]\" && in_class) {\n                            in_class = false;\n                            regexp += ch;\n                        } else if (ch === \"/\" && !in_class) {\n                            if (verbose_regexp) {\n                                if (peek() !== \"/\") {\n                                    regexp += \"\\\\/\";\n                                    continue;\n                                }\n                                next(true);\n                                if (peek() !== \"/\") {\n                                    regexp += \"\\\\/\\\\/\";\n                                    continue;\n                                }\n                                next(true);\n                            }\n                            break;\n                        } else if (ch === \"\\\\\") {\n                            prev_backslash = true;\n                        } else if (verbose_regexp && !in_class && \" \\n\\r\\t\".indexOf(ch) !== -1) {\n                        } else if (verbose_regexp && !in_class && ch === \"#\") {\n                            in_comment = true;\n                        } else {\n                            regexp += ch;\n                        }\n                    }\n                    mods = read_name();\n                    return token(\"regexp\", new RegExp(regexp, mods));\n                };\n                return _$rapyd$_anonfunc;\n            })());\n            function read_operator(prefix) {\n                var op;\n                function grow(op) {\n                    var bigger;\n                    if (!peek()) {\n                        return op;\n                    }\n                    bigger = op + peek();\n                    if (OPERATORS(bigger)) {\n                        next();\n                        return grow(bigger);\n                    } else {\n                        return op;\n                    }\n                };\n\n                grow.__argnames__ = [\"op\"];\n\n                op = grow(prefix || next());\n                if (INVALID_OPERATORS.has(op)) {\n                    parse_error(\"Invalid operator \" + op + \"\");\n                } else if (op === \"->\") {\n                    return token(\"punc\", op);\n                }\n                return token(\"operator\", op);\n            };\n\n            read_operator.__argnames__ = [\"prefix\"];\n\n            function handle_slash() {\n                next();\n                return (S.regex_allowed) ? read_regexp(\"\") : read_operator(\"/\");\n            };\n\n            function handle_dot() {\n                next();\n                return (is_digit(peek().charCodeAt(0))) ? read_num(\".\") : token(\"punc\", \".\");\n            };\n\n            function read_word() {\n                var word;\n                word = read_name();\n                return (KEYWORDS_ATOM(word)) ? token(\"atom\", word) : (!KEYWORDS(word)) ? token(\"name\", word) : (OPERATORS(word) && prevChar() !== \".\") ? token(\"operator\", word) : token(\"keyword\", word);\n            };\n\n            function next_token() {\n                var indent, ch, code, tmp_, regex_allowed, tok, mods, stok;\n                indent = parse_whitespace();\n                if (indent === -1) {\n                    return token(\"punc\", \"}\", false, true);\n                }\n                start_token();\n                ch = peek();\n                if (!ch) {\n                    return token(\"eof\");\n                }\n                code = ch.charCodeAt(0);\n                tmp_ = code;\n                if (tmp_ === 34 || tmp_ === 39) {\n                    return read_string(false);\n                } else if (tmp_ === 35) {\n                    if (S.pos === 0 && S.text.charAt(1) === \"!\") {\n                        return read_line_comment(true);\n                    }\n                    regex_allowed = S.regex_allowed;\n                    S.comments_before.push(read_line_comment());\n                    S.regex_allowed = regex_allowed;\n                    return next_token();\n                } else if (tmp_ === 46) {\n                    return handle_dot();\n                } else if (tmp_ === 47) {\n                    return handle_slash();\n                }\n                if (is_digit(code)) {\n                    return read_num();\n                }\n                if (PUNC_CHARS(ch)) {\n                    return token(\"punc\", next());\n                }\n                if (OPERATOR_CHARS(ch)) {\n                    return read_operator();\n                }\n                if (code === 92 && S.text.charAt(S.pos + 1) === \"\\n\") {\n                    next();\n                    next();\n                    S.newline_before = false;\n                    return next_token();\n                }\n                if (is_identifier_start(code)) {\n                    tok = read_word();\n                    if (\"'\\\"\".indexOf(peek()) !== -1 && is_string_modifier(tok.value)) {\n                        mods = tok.value.toLowerCase();\n                        stok = read_string(mods.indexOf(\"r\") !== -1, mods.indexOf(\"v\") !== -1);\n                        tok.endpos = stok.endpos;\n                        tok.value = stok.value;\n                        tok.type = stok.type;\n                    }\n                    return tok;\n                }\n                parse_error(\"Unexpected character \" + ch + \"\");\n            };\n\n            next_token.context = (function() {\n                var _$rapyd$_anonfunc = function (nc) {\n                    if (nc) {\n                        S = nc;\n                    }\n                    return S;\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"nc\"];\n                return _$rapyd$_anonfunc;\n            })();\n            return next_token;\n        };\n\n        tokenizer.__argnames__ = [\"$TEXT\", \"filename\"];\n\n        _$rapyd$_modules.tokenizer.RE_HEX_NUMBER = RE_HEX_NUMBER;\n        _$rapyd$_modules.tokenizer.RE_OCT_NUMBER = RE_OCT_NUMBER;\n        _$rapyd$_modules.tokenizer.RE_DEC_NUMBER = RE_DEC_NUMBER;\n        _$rapyd$_modules.tokenizer.UNARY_POSTFIX = UNARY_POSTFIX;\n        _$rapyd$_modules.tokenizer.OPERATOR_CHARS = OPERATOR_CHARS;\n        _$rapyd$_modules.tokenizer.INVALID_OPERATORS = INVALID_OPERATORS;\n        _$rapyd$_modules.tokenizer.ASCII_CONTROL_CHARS = ASCII_CONTROL_CHARS;\n        _$rapyd$_modules.tokenizer.HEX_PAT = HEX_PAT;\n        _$rapyd$_modules.tokenizer.NAME_PAT = NAME_PAT;\n        _$rapyd$_modules.tokenizer.OPERATORS = OPERATORS;\n        _$rapyd$_modules.tokenizer.OP_MAP = OP_MAP;\n        _$rapyd$_modules.tokenizer.WHITESPACE_CHARS = WHITESPACE_CHARS;\n        _$rapyd$_modules.tokenizer.PUNC_BEFORE_EXPRESSION = PUNC_BEFORE_EXPRESSION;\n        _$rapyd$_modules.tokenizer.PUNC_CHARS = PUNC_CHARS;\n        _$rapyd$_modules.tokenizer.REGEXP_MODIFIERS = REGEXP_MODIFIERS;\n        _$rapyd$_modules.tokenizer.KEYWORDS = KEYWORDS;\n        _$rapyd$_modules.tokenizer.KEYWORDS_ATOM = KEYWORDS_ATOM;\n        _$rapyd$_modules.tokenizer.RESERVED_WORDS = RESERVED_WORDS;\n        _$rapyd$_modules.tokenizer.KEYWORDS_BEFORE_EXPRESSION = KEYWORDS_BEFORE_EXPRESSION;\n        _$rapyd$_modules.tokenizer.ALL_KEYWORDS = ALL_KEYWORDS;\n        _$rapyd$_modules.tokenizer.IDENTIFIER_PAT = IDENTIFIER_PAT;\n        _$rapyd$_modules.tokenizer.UNICODE = UNICODE;\n        _$rapyd$_modules.tokenizer.EX_EOF = EX_EOF;\n        _$rapyd$_modules.tokenizer.is_string_modifier = is_string_modifier;\n        _$rapyd$_modules.tokenizer.is_letter = is_letter;\n        _$rapyd$_modules.tokenizer.is_digit = is_digit;\n        _$rapyd$_modules.tokenizer.is_alphanumeric_char = is_alphanumeric_char;\n        _$rapyd$_modules.tokenizer.is_unicode_combining_mark = is_unicode_combining_mark;\n        _$rapyd$_modules.tokenizer.is_unicode_connector_punctuation = is_unicode_connector_punctuation;\n        _$rapyd$_modules.tokenizer.is_identifier = is_identifier;\n        _$rapyd$_modules.tokenizer.is_identifier_start = is_identifier_start;\n        _$rapyd$_modules.tokenizer.is_identifier_char = is_identifier_char;\n        _$rapyd$_modules.tokenizer.parse_js_number = parse_js_number;\n        _$rapyd$_modules.tokenizer.is_token = is_token;\n        _$rapyd$_modules.tokenizer.tokenizer = tokenizer;\n    })();\n\n    (function(){\n        var __name__ = \"parse\";\n        var has_prop, COMPILER_VERSION, PYTHON_FLAGS, NATIVE_CLASSES, ERROR_CLASSES, COMMON_STATIC, UNARY_PREFIX, ASSIGNMENT, PRECEDENCE, STATEMENTS_WITH_LABELS, ATOMIC_START_TOKEN, compile_time_decorators;\n        var make_predicate = _$rapyd$_modules.utils.make_predicate;\n        var array_to_hash = _$rapyd$_modules.utils.array_to_hash;\n        var defaults = _$rapyd$_modules.utils.defaults;\n        \n        var SyntaxError = _$rapyd$_modules.errors.SyntaxError;\n        var ImportError = _$rapyd$_modules.errors.ImportError;\n        \n        var AST_Array = _$rapyd$_modules.ast.AST_Array;\n        var AST_Assign = _$rapyd$_modules.ast.AST_Assign;\n        var AST_Binary = _$rapyd$_modules.ast.AST_Binary;\n        var AST_BlockStatement = _$rapyd$_modules.ast.AST_BlockStatement;\n        var AST_Break = _$rapyd$_modules.ast.AST_Break;\n        var AST_Call = _$rapyd$_modules.ast.AST_Call;\n        var AST_Catch = _$rapyd$_modules.ast.AST_Catch;\n        var AST_Class = _$rapyd$_modules.ast.AST_Class;\n        var AST_ClassCall = _$rapyd$_modules.ast.AST_ClassCall;\n        var AST_Conditional = _$rapyd$_modules.ast.AST_Conditional;\n        var AST_Const = _$rapyd$_modules.ast.AST_Const;\n        var AST_Constant = _$rapyd$_modules.ast.AST_Constant;\n        var AST_Continue = _$rapyd$_modules.ast.AST_Continue;\n        var AST_DWLoop = _$rapyd$_modules.ast.AST_DWLoop;\n        var AST_Debugger = _$rapyd$_modules.ast.AST_Debugger;\n        var AST_Decorator = _$rapyd$_modules.ast.AST_Decorator;\n        var AST_Definitions = _$rapyd$_modules.ast.AST_Definitions;\n        var AST_DictComprehension = _$rapyd$_modules.ast.AST_DictComprehension;\n        var AST_Directive = _$rapyd$_modules.ast.AST_Directive;\n        var AST_Do = _$rapyd$_modules.ast.AST_Do;\n        var AST_Dot = _$rapyd$_modules.ast.AST_Dot;\n        var AST_EmptyStatement = _$rapyd$_modules.ast.AST_EmptyStatement;\n        var AST_Except = _$rapyd$_modules.ast.AST_Except;\n        var AST_ExpressiveObject = _$rapyd$_modules.ast.AST_ExpressiveObject;\n        var AST_False = _$rapyd$_modules.ast.AST_False;\n        var AST_Finally = _$rapyd$_modules.ast.AST_Finally;\n        var AST_ForIn = _$rapyd$_modules.ast.AST_ForIn;\n        var AST_ForJS = _$rapyd$_modules.ast.AST_ForJS;\n        var AST_Function = _$rapyd$_modules.ast.AST_Function;\n        var AST_GeneratorComprehension = _$rapyd$_modules.ast.AST_GeneratorComprehension;\n        var AST_Hole = _$rapyd$_modules.ast.AST_Hole;\n        var AST_If = _$rapyd$_modules.ast.AST_If;\n        var AST_Import = _$rapyd$_modules.ast.AST_Import;\n        var AST_ImportedVar = _$rapyd$_modules.ast.AST_ImportedVar;\n        var AST_Imports = _$rapyd$_modules.ast.AST_Imports;\n        var AST_ListComprehension = _$rapyd$_modules.ast.AST_ListComprehension;\n        var AST_Method = _$rapyd$_modules.ast.AST_Method;\n        var AST_New = _$rapyd$_modules.ast.AST_New;\n        var AST_Null = _$rapyd$_modules.ast.AST_Null;\n        var AST_Number = _$rapyd$_modules.ast.AST_Number;\n        var AST_Object = _$rapyd$_modules.ast.AST_Object;\n        var AST_ObjectKeyVal = _$rapyd$_modules.ast.AST_ObjectKeyVal;\n        var AST_PropAccess = _$rapyd$_modules.ast.AST_PropAccess;\n        var AST_RegExp = _$rapyd$_modules.ast.AST_RegExp;\n        var AST_Return = _$rapyd$_modules.ast.AST_Return;\n        var AST_Scope = _$rapyd$_modules.ast.AST_Scope;\n        var AST_Set = _$rapyd$_modules.ast.AST_Set;\n        var AST_SetComprehension = _$rapyd$_modules.ast.AST_SetComprehension;\n        var AST_SetItem = _$rapyd$_modules.ast.AST_SetItem;\n        var AST_Seq = _$rapyd$_modules.ast.AST_Seq;\n        var AST_SimpleStatement = _$rapyd$_modules.ast.AST_SimpleStatement;\n        var AST_Splice = _$rapyd$_modules.ast.AST_Splice;\n        var AST_String = _$rapyd$_modules.ast.AST_String;\n        var AST_Sub = _$rapyd$_modules.ast.AST_Sub;\n        var AST_ItemAccess = _$rapyd$_modules.ast.AST_ItemAccess;\n        var AST_SymbolAlias = _$rapyd$_modules.ast.AST_SymbolAlias;\n        var AST_SymbolCatch = _$rapyd$_modules.ast.AST_SymbolCatch;\n        var AST_SymbolConst = _$rapyd$_modules.ast.AST_SymbolConst;\n        var AST_SymbolDefun = _$rapyd$_modules.ast.AST_SymbolDefun;\n        var AST_SymbolFunarg = _$rapyd$_modules.ast.AST_SymbolFunarg;\n        var AST_SymbolLambda = _$rapyd$_modules.ast.AST_SymbolLambda;\n        var AST_SymbolNonlocal = _$rapyd$_modules.ast.AST_SymbolNonlocal;\n        var AST_SymbolRef = _$rapyd$_modules.ast.AST_SymbolRef;\n        var AST_SymbolVar = _$rapyd$_modules.ast.AST_SymbolVar;\n        var AST_This = _$rapyd$_modules.ast.AST_This;\n        var AST_Throw = _$rapyd$_modules.ast.AST_Throw;\n        var AST_Toplevel = _$rapyd$_modules.ast.AST_Toplevel;\n        var AST_True = _$rapyd$_modules.ast.AST_True;\n        var AST_Try = _$rapyd$_modules.ast.AST_Try;\n        var AST_UnaryPostfix = _$rapyd$_modules.ast.AST_UnaryPostfix;\n        var AST_UnaryPrefix = _$rapyd$_modules.ast.AST_UnaryPrefix;\n        var AST_Undefined = _$rapyd$_modules.ast.AST_Undefined;\n        var AST_Var = _$rapyd$_modules.ast.AST_Var;\n        var AST_VarDef = _$rapyd$_modules.ast.AST_VarDef;\n        var AST_Verbatim = _$rapyd$_modules.ast.AST_Verbatim;\n        var AST_While = _$rapyd$_modules.ast.AST_While;\n        var AST_With = _$rapyd$_modules.ast.AST_With;\n        var AST_WithClause = _$rapyd$_modules.ast.AST_WithClause;\n        var AST_Yield = _$rapyd$_modules.ast.AST_Yield;\n        \n        var tokenizer = _$rapyd$_modules.tokenizer.tokenizer;\n        var is_token = _$rapyd$_modules.tokenizer.is_token;\n        var UNARY_POSTFIX = _$rapyd$_modules.tokenizer.UNARY_POSTFIX;\n        \n        has_prop = Object.prototype.hasOwnProperty;\n        COMPILER_VERSION = \"486ddd9bd8213f389e886c70f2939884b91337c5\";\n        PYTHON_FLAGS = {\n            \"dict_literals\": true,\n            \"overload_getitem\": true\n        };\n        NATIVE_CLASSES = {\n            \"Image\": {},\n            \"RegExp\": {},\n            \"Error\": {},\n            \"EvalError\": {},\n            \"InternalError\": {},\n            \"RangeError\": {},\n            \"ReferenceError\": {},\n            \"SyntaxError\": {},\n            \"TypeError\": {},\n            \"URIError\": {},\n            \"Object\": {\n                \"static\": _$rapyd$_list_decorate([ \"getOwnPropertyNames\", \"keys\", \"create\", \"defineProperty\", \"defineProperties\", \"getPrototypeOf\", \"setPrototypeOf\", \"assign\" ])\n            },\n            \"String\": {\n                \"static\": _$rapyd$_list_decorate([ \"fromCharCode\" ])\n            },\n            \"Array\": {\n                \"static\": _$rapyd$_list_decorate([ \"isArray\", \"from\", \"of\" ])\n            },\n            \"Function\": {},\n            \"Date\": {\n                \"static\": _$rapyd$_list_decorate([ \"UTC\", \"now\", \"parse\" ])\n            },\n            \"ArrayBuffer\": {},\n            \"DataView\": {},\n            \"Float32Array\": {},\n            \"Float64Array\": {},\n            \"Int16Array\": {},\n            \"Int32Array\": {},\n            \"Int8Array\": {},\n            \"Uint16Array\": {},\n            \"Uint32Array\": {},\n            \"Uint8Array\": {},\n            \"Uint8ClampedArray\": {},\n            \"Map\": {},\n            \"WeakMap\": {},\n            \"Set\": {},\n            \"WeakSet\": {},\n            \"XMLHttpRequest\": {},\n            \"TextEncoder\": {},\n            \"TextDecoder\": {},\n            \"MouseEvent\": {},\n            \"Event\": {},\n            \"CustomEvent\": {},\n            \"Blob\": {}\n        };\n        ERROR_CLASSES = {\n            \"Exception\": {},\n            \"AttributeError\": {},\n            \"IndexError\": {},\n            \"KeyError\": {},\n            \"ValueError\": {}\n        };\n        COMMON_STATIC = _$rapyd$_list_decorate([ \"call\", \"apply\", \"bind\", \"toString\" ]);\n        UNARY_PREFIX = make_predicate(_$rapyd$_list_decorate([ \"typeof\", \"void\", \"delete\", \"--\", \"++\", \"!\", \"~\", \"-\", \"+\", \"@\" ]));\n        ASSIGNMENT = make_predicate(_$rapyd$_list_decorate([ \"=\", \"+=\", \"-=\", \"/=\", \"//=\", \"*=\", \"%=\", \">>=\", \"<<=\", \">>>=\", \"|=\", \"^=\", \"&=\" ]));\n        PRECEDENCE = (function() {\n            var _$rapyd$_anonfunc = function (a, ret) {\n                var b, j, i;\n                for (var _$rapyd$_Index25 = 0; _$rapyd$_Index25 < a.length; _$rapyd$_Index25++) {\n                    i = _$rapyd$_Index25;\n                    b = a[i];\n                    for (var _$rapyd$_Index26 = 0; _$rapyd$_Index26 < b.length; _$rapyd$_Index26++) {\n                        j = _$rapyd$_Index26;\n                        ret[b[j]] = i + 1;\n                    }\n                }\n                return ret;\n            };\n\n            _$rapyd$_anonfunc.__argnames__ = [\"a\", \"ret\"];\n            return _$rapyd$_anonfunc;\n        })()(_$rapyd$_list_decorate([ _$rapyd$_list_decorate([ \"||\" ]), _$rapyd$_list_decorate([ \"&&\" ]), _$rapyd$_list_decorate([ \"|\" ]), _$rapyd$_list_decorate([ \"^\" ]), _$rapyd$_list_decorate([ \"&\" ]), _$rapyd$_list_decorate([ \"==\", \"===\", \"!=\", \"!==\" ]), _$rapyd$_list_decorate([ \"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\" ]), _$rapyd$_list_decorate([ \">>\", \"<<\", \">>>\" ]), _$rapyd$_list_decorate([ \"+\", \"-\" ]), _$rapyd$_list_decorate([ \"*\", \"/\", \"//\", \"%\" ]), _$rapyd$_list_decorate([ \"**\" ]) ]), {});\n        STATEMENTS_WITH_LABELS = array_to_hash(_$rapyd$_list_decorate([ \"for\", \"do\", \"while\", \"switch\" ]));\n        ATOMIC_START_TOKEN = array_to_hash(_$rapyd$_list_decorate([ \"atom\", \"num\", \"string\", \"regexp\", \"name\", \"js\" ]));\n        compile_time_decorators = _$rapyd$_list_decorate([ \"staticmethod\", \"external\", \"property\" ]);\n        function has_simple_decorator(decorators, name) {\n            var remove, s;\n            remove = [];\n            for (var i = 0; i < decorators.length; i++) {\n                s = decorators[i];\n                if (s instanceof AST_SymbolRef && !s.parens && s.name === name) {\n                    remove.push(i);\n                }\n            }\n            if (remove.length) {\n                remove.reverse();\n                for (var i = 0; i < remove.length; i++) {\n                    decorators.splice(remove[i], 1);\n                }\n                return true;\n            }\n            return false;\n        };\n\n        has_simple_decorator.__argnames__ = [\"decorators\", \"name\"];\n\n        function has_setter_decorator(decorators, name) {\n            var remove, s;\n            remove = [];\n            for (var i = 0; i < decorators.length; i++) {\n                s = decorators[i];\n                if (s instanceof AST_Dot && s.expression instanceof AST_SymbolRef && s.expression.name === name && s.property === \"setter\") {\n                    remove.push(i);\n                }\n            }\n            if (remove.length) {\n                remove.reverse();\n                for (var i = 0; i < remove.length; i++) {\n                    decorators.splice(remove[i], 1);\n                }\n                return true;\n            }\n            return false;\n        };\n\n        has_setter_decorator.__argnames__ = [\"decorators\", \"name\"];\n\n        function create_parser_ctx(S, import_dirs, module_id, baselib_items, imported_module_ids, imported_modules, importing_modules, options) {\n            function next() {\n                S.prev = S.token;\n                if (S.peeked.length) {\n                    S.token = S.peeked.shift();\n                } else {\n                    S.token = S.input();\n                }\n                return S.token;\n            };\n\n            function is_(type, value) {\n                return is_token(S.token, type, value);\n            };\n\n            is_.__argnames__ = [\"type\", \"value\"];\n\n            function peek() {\n                if (!S.peeked.length) {\n                    S.peeked.push(S.input());\n                }\n                return S.peeked[0];\n            };\n\n            function prev() {\n                return S.prev;\n            };\n\n            function croak(msg, line, col, pos, is_eof) {\n                var ctx;\n                ctx = S.input.context();\n                throw new SyntaxError(msg, ctx.filename, (line !== undefined) ? line : ctx.tokline, (col !== undefined) ? col : ctx.tokcol, (pos !== undefined) ? pos : ctx.tokpos, is_eof);\n            };\n\n            croak.__argnames__ = [\"msg\", \"line\", \"col\", \"pos\", \"is_eof\"];\n\n            function token_error(token, msg) {\n                var is_eof;\n                is_eof = (token.type === \"eof\") ? true : false;\n                croak(msg, token.line, token.col, undefined, is_eof);\n            };\n\n            token_error.__argnames__ = [\"token\", \"msg\"];\n\n            function unexpected(token) {\n                if (token === undefined) {\n                    token = S.token;\n                }\n                token_error(token, \"Unexpected token: \" + token.type + \" \" + token.value + \"\");\n            };\n\n            unexpected.__argnames__ = [\"token\"];\n\n            function expect_token(type, val) {\n                if (is_(type, val)) {\n                    return next();\n                }\n                token_error(S.token, \"Unexpected token \" + S.token.type + \" \" + S.token.value + \"\" + \", expected \" + type + \" \" + val + \"\");\n            };\n\n            expect_token.__argnames__ = [\"type\", \"val\"];\n\n            function expect(punc) {\n                return expect_token(\"punc\", punc);\n            };\n\n            expect.__argnames__ = [\"punc\"];\n\n            function can_insert_semicolon() {\n                return S.token.nlb || is_(\"eof\") || is_(\"punc\", \"}\");\n            };\n\n            function semicolon() {\n                if (is_(\"punc\", \";\")) {\n                    next();\n                    S.token.nlb = true;\n                }\n            };\n\n            function embed_tokens(parser) {\n                function with_embedded_tokens() {\n                    var start, expr, end;\n                    start = S.token;\n                    expr = parser();\n                    if (expr === undefined) {\n                        unexpected();\n                    }\n                    end = prev();\n                    expr.start = start;\n                    expr.end = end;\n                    return expr;\n                };\n\n                return with_embedded_tokens;\n            };\n\n            embed_tokens.__argnames__ = [\"parser\"];\n\n            function scan_for_top_level_callables(body) {\n                var ans, opt, x, obj;\n                ans = [];\n                if (Array.isArray(body)) {\n                    var _$rapyd$_Iter27 = _$rapyd$_Iterable(body);\n                    for (var _$rapyd$_Index27 = 0; _$rapyd$_Index27 < _$rapyd$_Iter27.length; _$rapyd$_Index27++) {\n                        obj = _$rapyd$_Iter27[_$rapyd$_Index27];\n                        if (obj instanceof AST_Function || obj instanceof AST_Class) {\n                            if (obj.name) {\n                                ans.push(obj.name.name);\n                            } else {\n                                token_error(obj.start, \"Top-level functions must have names\");\n                            }\n                        } else {\n                            if (obj instanceof AST_Scope) {\n                                continue;\n                            }\n                            var _$rapyd$_Iter28 = _$rapyd$_Iterable(_$rapyd$_list_decorate([ \"body\", \"alternative\" ]));\n                            for (var _$rapyd$_Index28 = 0; _$rapyd$_Index28 < _$rapyd$_Iter28.length; _$rapyd$_Index28++) {\n                                x = _$rapyd$_Iter28[_$rapyd$_Index28];\n                                opt = obj[x];\n                                if (opt) {\n                                    ans = ans.concat(scan_for_top_level_callables(opt));\n                                }\n                                if (opt instanceof AST_Assign && !(opt.right instanceof AST_Scope)) {\n                                    ans = ans.concat(scan_for_top_level_callables(opt.right));\n                                }\n                            }\n                        }\n                    }\n                } else if (body.body) {\n                    ans = ans.concat(scan_for_top_level_callables(body.body));\n                    if (body.alternative) {\n                        ans = ans.concat(scan_for_top_level_callables(body.alternative));\n                    }\n                }\n                return ans;\n            };\n\n            scan_for_top_level_callables.__argnames__ = [\"body\"];\n\n            function scan_for_classes(body) {\n                var ans, obj;\n                ans = {};\n                var _$rapyd$_Iter29 = _$rapyd$_Iterable(body);\n                for (var _$rapyd$_Index29 = 0; _$rapyd$_Index29 < _$rapyd$_Iter29.length; _$rapyd$_Index29++) {\n                    obj = _$rapyd$_Iter29[_$rapyd$_Index29];\n                    if (obj instanceof AST_Class) {\n                        ans[obj.name.name] = obj;\n                    }\n                }\n                return ans;\n            };\n\n            scan_for_classes.__argnames__ = [\"body\"];\n\n            function scan_for_local_vars(body) {\n                var localvars, seen, clause, stmt, lhs;\n                \"\\n        Pick out all variables being assigned to from within this scope, we'll mark them as local\\n\\n        body        body to be scanned\\n        \";\n                localvars = [];\n                seen = {};\n                function push(x) {\n                    if (has_prop.call(seen, x)) {\n                        return;\n                    }\n                    seen[x] = true;\n                    localvars.push(x);\n                };\n\n                push.__argnames__ = [\"x\"];\n\n                function extend(arr) {\n                    var x;\n                    var _$rapyd$_Iter30 = _$rapyd$_Iterable(arr);\n                    for (var _$rapyd$_Index30 = 0; _$rapyd$_Index30 < _$rapyd$_Iter30.length; _$rapyd$_Index30++) {\n                        x = _$rapyd$_Iter30[_$rapyd$_Index30];\n                        push(x);\n                    }\n                };\n\n                extend.__argnames__ = [\"arr\"];\n\n                function scan_in_array(arr) {\n                    var x;\n                    var _$rapyd$_Iter31 = _$rapyd$_Iterable(arr);\n                    for (var _$rapyd$_Index31 = 0; _$rapyd$_Index31 < _$rapyd$_Iter31.length; _$rapyd$_Index31++) {\n                        x = _$rapyd$_Iter31[_$rapyd$_Index31];\n                        if (x instanceof AST_Seq) {\n                            x = x.to_array();\n                        } else if (x instanceof AST_Array) {\n                            x = x.elements;\n                        }\n                        if (Array.isArray(x)) {\n                            scan_in_array(x);\n                        } else {\n                            if (!(x instanceof AST_PropAccess)) {\n                                push(x.name);\n                            }\n                        }\n                    }\n                };\n\n                scan_in_array.__argnames__ = [\"arr\"];\n\n                function add_assign_lhs(lhs) {\n                    if (lhs instanceof AST_Seq) {\n                        lhs = new AST_Array({\n                            \"elements\": lhs.to_array()\n                        });\n                    }\n                    if (lhs instanceof AST_Array) {\n                        push(\"_$rapyd$_unpack\");\n                        scan_in_array(lhs.elements);\n                    } else if (lhs.name) {\n                        push(lhs.name);\n                    }\n                };\n\n                add_assign_lhs.__argnames__ = [\"lhs\"];\n\n                function add_for_in(stmt) {\n                    if (stmt.init instanceof AST_Array) {\n                        push(\"_$rapyd$_unpack\");\n                        scan_in_array(stmt.init.elements);\n                    } else {\n                        push(stmt.init.name);\n                    }\n                };\n\n                add_for_in.__argnames__ = [\"stmt\"];\n\n                if (Array.isArray(body)) {\n                    var _$rapyd$_Iter32 = _$rapyd$_Iterable(body);\n                    for (var _$rapyd$_Index32 = 0; _$rapyd$_Index32 < _$rapyd$_Iter32.length; _$rapyd$_Index32++) {\n                        stmt = _$rapyd$_Iter32[_$rapyd$_Index32];\n                        if (stmt instanceof AST_Scope) {\n                            continue;\n                        }\n                        [ \"body\", \"alternative\" ].forEach((function() {\n                            var _$rapyd$_anonfunc = function (option) {\n                                var opt;\n                                opt = stmt[option];\n                                if (opt) {\n                                    extend(scan_for_local_vars(opt));\n                                }\n                                if (opt instanceof AST_Assign && !(opt.right instanceof AST_Scope)) {\n                                    extend(scan_for_local_vars(opt.right));\n                                }\n                            };\n\n                            _$rapyd$_anonfunc.__argnames__ = [\"option\"];\n                            return _$rapyd$_anonfunc;\n                        })());\n                        if (stmt instanceof AST_ForIn) {\n                            add_for_in(stmt);\n                        } else if (stmt instanceof AST_DWLoop) {\n                            extend(scan_for_local_vars(stmt));\n                        } else if (stmt instanceof AST_With) {\n                            [push(\"_$rapyd$_with_exception\"), push(\"_$rapyd$_with_suppress\")];\n                            var _$rapyd$_Iter33 = _$rapyd$_Iterable(stmt.clauses);\n                            for (var _$rapyd$_Index33 = 0; _$rapyd$_Index33 < _$rapyd$_Iter33.length; _$rapyd$_Index33++) {\n                                clause = _$rapyd$_Iter33[_$rapyd$_Index33];\n                                if (clause.alias) {\n                                    push(clause.alias.name);\n                                }\n                            }\n                        }\n                    }\n                } else if (body.body) {\n                    extend(scan_for_local_vars(body.body));\n                    if (body.alternative) {\n                        extend(scan_for_local_vars(body.alternative));\n                    }\n                } else if (body instanceof AST_Assign) {\n                    if (body.is_chained()) {\n                        var _$rapyd$_Iter34 = _$rapyd$_Iterable(body.traverse_chain()[0]);\n                        for (var _$rapyd$_Index34 = 0; _$rapyd$_Index34 < _$rapyd$_Iter34.length; _$rapyd$_Index34++) {\n                            lhs = _$rapyd$_Iter34[_$rapyd$_Index34];\n                            add_assign_lhs(lhs);\n                        }\n                        push(\"_$rapyd$_chain_assign_temp\");\n                    } else {\n                        add_assign_lhs(body.left);\n                    }\n                    if (!(body.right instanceof AST_Scope)) {\n                        extend(scan_for_local_vars(body.right));\n                    }\n                } else if (body instanceof AST_ForIn) {\n                    add_for_in(body);\n                }\n                return localvars;\n            };\n\n            scan_for_local_vars.__argnames__ = [\"body\"];\n\n            function scan_for_nonlocal_defs(body) {\n                var vars, stmt;\n                vars = [];\n                if (Array.isArray(body)) {\n                    var _$rapyd$_Iter35 = _$rapyd$_Iterable(body);\n                    for (var _$rapyd$_Index35 = 0; _$rapyd$_Index35 < _$rapyd$_Iter35.length; _$rapyd$_Index35++) {\n                        stmt = _$rapyd$_Iter35[_$rapyd$_Index35];\n                        if (stmt instanceof AST_Scope) {\n                            continue;\n                        }\n                        if (stmt instanceof AST_Definitions) {\n                            stmt.definitions.forEach((function() {\n                                var _$rapyd$_anonfunc = function (vardef) {\n                                    vars.push(vardef.name.name);\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"vardef\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                        }\n                        [ \"body\", \"alternative\" ].forEach((function() {\n                            var _$rapyd$_anonfunc = function (option) {\n                                var opt;\n                                opt = stmt[option];\n                                if (opt) {\n                                    vars = vars.concat(scan_for_nonlocal_defs(opt));\n                                }\n                            };\n\n                            _$rapyd$_anonfunc.__argnames__ = [\"option\"];\n                            return _$rapyd$_anonfunc;\n                        })());\n                    }\n                } else if (body.body) {\n                    vars = vars.concat(scan_for_nonlocal_defs(body.body));\n                    if (body.alternative) {\n                        vars = vars.concat(scan_for_nonlocal_defs(body.alternative));\n                    }\n                }\n                return vars;\n            };\n\n            scan_for_nonlocal_defs.__argnames__ = [\"body\"];\n\n            \n            var statement = embed_tokens((function() {\n                var _$rapyd$_anonfunc = function statement() {\n                    var tmp_, start, func, chain, tmp;\n                    if (S.token.type === \"operator\" && S.token.value.substr(0, 1) === \"/\") {\n                        token_error(S.token, \"RapydScript does not support statements starting with regexp literals\");\n                    }\n                    S.statement_starting_token = S.token;\n                    tmp_ = S.token.type;\n                    if (tmp_ === \"string\") {\n                        return simple_statement();\n                    } else if (tmp_ === \"shebang\") {\n                        tmp_ = S.token.value;\n                        next();\n                        return new AST_Directive({\n                            \"value\": tmp_\n                        });\n                    } else if (tmp_ === \"num\" || tmp_ === \"regexp\" || tmp_ === \"operator\" || tmp_ === \"atom\" || tmp_ === \"js\") {\n                        return simple_statement();\n                    } else if (tmp_ === \"punc\") {\n                        tmp_ = S.token.value;\n                        if (tmp_ === \":\") {\n                            return new AST_BlockStatement({\n                                \"start\": S.token,\n                                \"body\": block_(),\n                                \"end\": prev()\n                            });\n                        } else if (tmp_ === \"{\" || tmp_ === \"[\" || tmp_ === \"(\") {\n                            return simple_statement();\n                        } else if (tmp_ === \";\") {\n                            next();\n                            return new AST_EmptyStatement({\n                                \"stype\": \";\",\n                                \"start\": prev(),\n                                \"end\": prev()\n                            });\n                        } else {\n                            unexpected();\n                        }\n                    } else if (tmp_ === \"name\") {\n                        if (is_token(peek(), \"punc\", \":\")) token_error(peek(), \"invalid syntax, colon not allowed here\");\n                        return simple_statement();\n                    } else if (tmp_ === \"keyword\") {\n                        tmp_ = S.token.value;\n                        next();\n                        if (tmp_ === \"break\") {\n                            return break_cont(AST_Break);\n                        } else if (tmp_ === \"continue\") {\n                            return break_cont(AST_Continue);\n                        } else if (tmp_ === \"debugger\") {\n                            semicolon();\n                            return new AST_Debugger;\n                        } else if (tmp_ === \"do\") {\n                            return new AST_Do({\n                                \"body\": in_loop(statement),\n                                \"condition\": (function() {\n                                    var _$rapyd$_anonfunc = function () {\n                                        var tmp;\n                                        expect(\".\");\n                                        expect_token(\"keyword\", \"while\");\n                                        tmp = expression(true);\n                                        semicolon();\n                                        return tmp;\n                                    };\n                                    return _$rapyd$_anonfunc;\n                                })()()\n                            });\n                        } else if (tmp_ === \"while\") {\n                            return new AST_While({\n                                \"condition\": expression(true),\n                                \"body\": in_loop(statement)\n                            });\n                        } else if (tmp_ === \"for\") {\n                            if (is_(\"js\")) {\n                                return for_js();\n                            }\n                            return for_();\n                        } else if (tmp_ === \"from\") {\n                            return import_(true);\n                        } else if (tmp_ === \"import\") {\n                            return import_(false);\n                        } else if (tmp_ === \"class\") {\n                            return class_();\n                        } else if (tmp_ === \"def\") {\n                            start = prev();\n                            func = function_(S.in_class[S.in_class.length-1], false);\n                            func.start = start;\n                            func.end = prev();\n                            chain = subscripts(func, true);\n                            if (chain === func) {\n                                return func;\n                            } else {\n                                return new AST_SimpleStatement({\n                                    \"start\": start,\n                                    \"body\": chain,\n                                    \"end\": prev()\n                                });\n                            }\n                        } else if (tmp_ === \"if\") {\n                            return if_();\n                        } else if (tmp_ === \"pass\") {\n                            semicolon();\n                            return new AST_EmptyStatement({\n                                \"stype\": \"pass\",\n                                \"start\": prev(),\n                                \"end\": prev()\n                            });\n                        } else if (tmp_ === \"return\") {\n                            if (S.in_function === 0) {\n                                croak(\"'return' outside of function\");\n                            }\n                            if (S.functions[S.functions.length-1].is_generator) {\n                                croak(\"'return' not allowed in a function with yield\");\n                            }\n                            S.functions[S.functions.length-1].is_generator = false;\n                            return new AST_Return({\n                                \"value\": (is_(\"punc\", \";\")) ? (function() {\n                                    var _$rapyd$_anonfunc = function () {\n                                        semicolon();\n                                        return null;\n                                    };\n                                    return _$rapyd$_anonfunc;\n                                })()() : (can_insert_semicolon()) ? null : (function() {\n                                    var _$rapyd$_anonfunc = function () {\n                                        var tmp;\n                                        tmp = expression(true);\n                                        semicolon();\n                                        return tmp;\n                                    };\n                                    return _$rapyd$_anonfunc;\n                                })()()\n                            });\n                        } else if (tmp_ === \"yield\") {\n                            return yield_();\n                        } else if (tmp_ === \"raise\") {\n                            if (S.token.nlb) {\n                                return new AST_Throw({\n                                    \"value\": new AST_SymbolCatch({\n                                        \"name\": \"_$rapyd$_Exception\"\n                                    })\n                                });\n                            }\n                            tmp = expression(true);\n                            semicolon();\n                            return new AST_Throw({\n                                \"value\": tmp\n                            });\n                        } else if (tmp_ === \"try\") {\n                            return try_();\n                        } else if (tmp_ === \"nonlocal\") {\n                            tmp = nonlocal_();\n                            semicolon();\n                            return tmp;\n                        } else if (tmp_ === \"const\") {\n                            tmp = const_();\n                            semicolon();\n                            return tmp;\n                        } else if (tmp_ === \"with\") {\n                            return with_();\n                        } else {\n                            unexpected();\n                        }\n                    }\n                };\n                return _$rapyd$_anonfunc;\n            })());\n\n            function with_() {\n                var clauses, start, expr, alias, body;\n                clauses = [];\n                start = S.token;\n                while (true) {\n                    if (is_(\"eof\")) {\n                        unexpected();\n                    }\n                    expr = expression();\n                    alias = null;\n                    if (is_(\"keyword\", \"as\")) {\n                        next();\n                        alias = as_symbol(AST_SymbolAlias);\n                    }\n                    clauses.push(new AST_WithClause({\n                        \"expression\": expr,\n                        \"alias\": alias\n                    }));\n                    if (is_(\"punc\", \",\")) {\n                        next();\n                        continue;\n                    }\n                    if (!is_(\"punc\", \":\")) {\n                        unexpected();\n                    }\n                    break;\n                }\n                if (!clauses.length) {\n                    token_error(start, \"with statement must have at least one clause\");\n                }\n                body = statement();\n                return new AST_With({\n                    \"clauses\": clauses,\n                    \"body\": body\n                });\n            };\n\n            function simple_statement(tmp) {\n                tmp = expression(true);\n                semicolon();\n                return new AST_SimpleStatement({\n                    \"body\": tmp\n                });\n            };\n\n            simple_statement.__argnames__ = [\"tmp\"];\n\n            function break_cont(type) {\n                if (S.in_loop === 0) {\n                    croak(type.TYPE + \" not inside a loop or switch\");\n                }\n                semicolon();\n                return new type;\n            };\n\n            break_cont.__argnames__ = [\"type\"];\n\n            function yield_() {\n                var is_yield_from;\n                if (S.in_function === 0) {\n                    croak(\"'yield' outside of function\");\n                }\n                if (S.functions[S.functions.length-1].is_generator === false) {\n                    croak(\"'yield' not allowed in a function with return\");\n                }\n                S.functions[S.functions.length-1].is_generator = true;\n                is_yield_from = is_(\"keyword\", \"from\");\n                if (is_yield_from) {\n                    next();\n                }\n                return new AST_Yield({\n                    \"is_yield_from\": is_yield_from,\n                    \"value\": (is_(\"punc\", \";\")) ? (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            semicolon();\n                            return null;\n                        };\n                        return _$rapyd$_anonfunc;\n                    })()() : (can_insert_semicolon()) ? null : (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            var tmp;\n                            tmp = expression(true);\n                            semicolon();\n                            return tmp;\n                        };\n                        return _$rapyd$_anonfunc;\n                    })()()\n                });\n            };\n\n            function for_(list_comp) {\n                var init, tmp;\n                init = null;\n                if (!is_(\"punc\", \";\")) {\n                    init = expression(true, true);\n                    if (init instanceof AST_Seq) {\n                        if (init.car instanceof AST_SymbolRef && init.cdr instanceof AST_SymbolRef) {\n                            tmp = init.to_array();\n                        } else {\n                            tmp = _$rapyd$_list_decorate([ init ]);\n                        }\n                        init = new AST_Array({\n                            \"start\": init.start,\n                            \"elements\": tmp,\n                            \"end\": init.end\n                        });\n                    }\n                    if (is_(\"operator\", \"in\")) {\n                        if (init instanceof AST_Var && init.definitions.length > 1) {\n                            croak(\"Only one variable declaration allowed in for..in loop\");\n                        }\n                        next();\n                        return for_in(init, list_comp);\n                    }\n                }\n                unexpected();\n            };\n\n            for_.__argnames__ = [\"list_comp\"];\n\n            function for_in(init, list_comp) {\n                var lhs, obj;\n                lhs = (init instanceof AST_Var) ? init.definitions[0].name : null;\n                obj = expression(true);\n                if (list_comp) {\n                    return {\n                        \"init\": init,\n                        \"name\": lhs,\n                        \"object\": obj\n                    };\n                }\n                return new AST_ForIn({\n                    \"init\": init,\n                    \"name\": lhs,\n                    \"object\": obj,\n                    \"body\": in_loop(statement)\n                });\n            };\n\n            for_in.__argnames__ = [\"init\", \"list_comp\"];\n\n            function for_js() {\n                var condition;\n                condition = as_atom_node();\n                return new AST_ForJS({\n                    \"condition\": condition,\n                    \"body\": in_loop(statement)\n                });\n            };\n\n            function get_class_in_scope(expr) {\n                var s, referenced_path, class_name;\n                if (expr instanceof AST_SymbolRef) {\n                    if (NATIVE_CLASSES.hasOwnProperty(expr.name)) {\n                        return NATIVE_CLASSES[expr.name];\n                    }\n                    if (ERROR_CLASSES.hasOwnProperty(expr.name)) {\n                        return ERROR_CLASSES[expr.name];\n                    }\n                    for (var _$rapyd$_Index36 = S.classes.length - 1; _$rapyd$_Index36 > -1; _$rapyd$_Index36-=1) {\n                        s = _$rapyd$_Index36;\n                        if (S.classes[s].hasOwnProperty(expr.name)) {\n                            return S.classes[s][expr.name];\n                        }\n                    }\n                } else if (expr instanceof AST_Dot) {\n                    referenced_path = _$rapyd$_list_decorate([]);\n                    while (expr instanceof AST_Dot) {\n                        referenced_path.unshift(expr.property);\n                        expr = expr.expression;\n                    }\n                    if (expr instanceof AST_SymbolRef) {\n                        referenced_path.unshift(expr.name);\n                        if (len(referenced_path) > 1) {\n                            class_name = referenced_path.join(\".\");\n                            for (var _$rapyd$_Index37 = S.classes.length - 1; _$rapyd$_Index37 > -1; _$rapyd$_Index37-=1) {\n                                s = _$rapyd$_Index37;\n                                if (S.classes[s].hasOwnProperty(class_name)) {\n                                    return S.classes[s][class_name];\n                                }\n                            }\n                        }\n                    }\n                }\n                return false;\n            };\n\n            get_class_in_scope.__argnames__ = [\"expr\"];\n\n            function import_error(message) {\n                var ctx;\n                ctx = S.input.context();\n                throw new ImportError(message, ctx.filename, ctx.tokline, ctx.tokcol, ctx.tokpos);\n            };\n\n            import_error.__argnames__ = [\"message\"];\n\n            function do_import(key) {\n                var package_module_id, src_code, filename, _$rapyd$_chain_assign_temp, modpath, _$rapyd$_unpack, data, location, cached, srchash, ikey, bitem;\n                if (imported_modules.hasOwnProperty(key)) {\n                    return;\n                }\n                if (importing_modules.hasOwnProperty(key) && importing_modules[key]) {\n                    import_error(\"Detected a recursive import of: \" + key + \" while importing: \" + module_id);\n                }\n                package_module_id = key.split(\".\").slice(0, -1).join(\".\");\n                if (len(package_module_id) > 0) {\n                    do_import(package_module_id);\n                }\n                if (options.for_linting) {\n                    imported_modules[key] = {\n                        \"is_cached\": true,\n                        \"classes\": {},\n                        \"module_id\": key,\n                        \"exports\": _$rapyd$_list_decorate([]),\n                        \"submodules\": _$rapyd$_list_decorate([]),\n                        \"nonlocalvars\": _$rapyd$_list_decorate([]),\n                        \"baselib\": {},\n                        \"outputs\": {}\n                    };\n                    if (len(package_module_id) > 0) {\n                        imported_modules[package_module_id].submodules.push(key);\n                    }\n                    return;\n                }\n                function safe_read(base_path) {\n                    var _$rapyd$_unpack, i, path;\n                    var _$rapyd$_Iter38 = _$rapyd$_Iterable(enumerate(_$rapyd$_list_decorate([ base_path + \".pyj\", base_path + \"/__init__.pyj\" ])));\n                    for (var _$rapyd$_Index38 = 0; _$rapyd$_Index38 < _$rapyd$_Iter38.length; _$rapyd$_Index38++) {\n                        _$rapyd$_unpack = _$rapyd$_Iter38[_$rapyd$_Index38];\n                        i = _$rapyd$_unpack[0];\n                        path = _$rapyd$_unpack[1];\n                        try {\n                            return _$rapyd$_list_decorate([ readfile(path, \"utf-8\"), path ]);\n                        } catch (_$rapyd$_Exception) {\n                            var e = _$rapyd$_Exception;\n                            if (e.code === \"ENOENT\" || e.code === \"EPERM\" || e.code === \"EACCESS\") {\n                                if (i === 1) {\n                                    return [null, null];\n                                }\n                            }\n                            if (i === 1) {\n                                throw _$rapyd$_Exception;\n                            }\n                        }\n                    }\n                };\n\n                safe_read.__argnames__ = [\"base_path\"];\n\n                _$rapyd$_chain_assign_temp = null;\n                src_code = _$rapyd$_chain_assign_temp;\n                filename = _$rapyd$_chain_assign_temp;\n;\n                modpath = key.replace(\".\", \"/\");\n                var _$rapyd$_Iter39 = _$rapyd$_Iterable(import_dirs);\n                for (var _$rapyd$_Index39 = 0; _$rapyd$_Index39 < _$rapyd$_Iter39.length; _$rapyd$_Index39++) {\n                    location = _$rapyd$_Iter39[_$rapyd$_Index39];\n                    if (location) {\n                        _$rapyd$_unpack = safe_read(location + \"/\" + modpath);\n                        data = _$rapyd$_unpack[0];\n                        filename = _$rapyd$_unpack[1];\n                        if (data !== null) {\n                            src_code = data;\n                            break;\n                        }\n                    }\n                }\n                if (src_code === null) {\n                    import_error(\"Failed Import: '\" + key + \"' module doesn't exist in any of the import directories: \" + import_dirs.join(\":\"));\n                }\n                try {\n                    cached = JSON.parse(readfile(filename + \"-cached\", \"utf-8\"));\n                } catch (_$rapyd$_Exception) {\n                    cached = null;\n                }\n                srchash = sha1sum(src_code);\n                if (cached && cached[\"version\"] === COMPILER_VERSION && cached[\"signature\"] === srchash) {\n                    var _$rapyd$_Iter40 = _$rapyd$_Iterable(cached.imported_module_ids);\n                    for (var _$rapyd$_Index40 = 0; _$rapyd$_Index40 < _$rapyd$_Iter40.length; _$rapyd$_Index40++) {\n                        ikey = _$rapyd$_Iter40[_$rapyd$_Index40];\n                        do_import(ikey);\n                    }\n                    imported_modules[key] = {\n                        \"is_cached\": true,\n                        \"classes\": cached[\"classes\"],\n                        \"outputs\": cached[\"outputs\"],\n                        \"module_id\": key,\n                        \"import_order\": Object.keys(imported_modules).length,\n                        \"submodules\": _$rapyd$_list_decorate([]),\n                        \"nonlocalvars\": cached[\"nonlocalvars\"],\n                        \"baselib\": cached[\"baselib\"],\n                        \"exports\": cached.exports\n                    };\n                } else {\n                    parse(src_code, {\n                        \"filename\": filename,\n                        \"toplevel\": null,\n                        \"basedir\": options.basedir,\n                        \"libdir\": options.libdir,\n                        \"import_dirs\": options.import_dirs,\n                        \"module_id\": key,\n                        \"imported_modules\": imported_modules,\n                        \"importing_modules\": importing_modules\n                    });\n                }\n                imported_modules[key].srchash = srchash;\n                if (len(package_module_id) > 0) {\n                    imported_modules[package_module_id].submodules.push(key);\n                }\n                var _$rapyd$_Iter41 = _$rapyd$_Iterable(Object.keys(imported_modules[key].baselib));\n                for (var _$rapyd$_Index41 = 0; _$rapyd$_Index41 < _$rapyd$_Iter41.length; _$rapyd$_Index41++) {\n                    bitem = _$rapyd$_Iter41[_$rapyd$_Index41];\n                    baselib_items[bitem] = true;\n                }\n                imported_module_ids.push(key);\n            };\n\n            do_import.__argnames__ = [\"key\"];\n\n            function read_python_flags() {\n                var bracketed, name, val;\n                expect_token(\"keyword\", \"import\");\n                bracketed = is_(\"punc\", \"(\");\n                if (bracketed) {\n                    next();\n                }\n                while (true) {\n                    if (!is_(\"name\")) {\n                        croak(\"Name expected\");\n                    }\n                    name = S.token.value;\n                    val = (name.startsWith(\"no_\")) ? false : true;\n                    if (!val) {\n                        name = name.slice(3);\n                    }\n                    if (!has_prop.call(PYTHON_FLAGS, name)) {\n                        croak(\"Unknown __python__ flag: \" + name);\n                    }\n                    S.scoped_flags.set(name, val);\n                    next();\n                    if (is_(\"punc\", \",\")) {\n                        next();\n                    } else {\n                        if (bracketed) {\n                            if (is_(\"punc\", \")\")) {\n                                next();\n                            } else {\n                                continue;\n                            }\n                        }\n                        break;\n                    }\n                }\n                return new AST_EmptyStatement({\n                    \"stype\": \"scoped_flags\",\n                    \"start\": prev(),\n                    \"end\": prev()\n                });\n            };\n\n            function import_(from_import) {\n                var ans, tok, tmp, name, last_tok, _$rapyd$_chain_assign_temp, key, alias, aimp, _$rapyd$_unpack, classes, argnames, bracketed, exports, symdef, aname, obj, argvar, cname, imp;\n                ans = new AST_Imports({\n                    \"imports\": _$rapyd$_list_decorate([])\n                });\n                while (true) {\n                    _$rapyd$_chain_assign_temp = expression(false);\n                    tok = _$rapyd$_chain_assign_temp;\n                    tmp = _$rapyd$_chain_assign_temp;\n                    name = _$rapyd$_chain_assign_temp;\n                    last_tok = _$rapyd$_chain_assign_temp;\n;\n                    key = \"\";\n                    while (tmp instanceof AST_Dot) {\n                        key = \".\" + tmp.property + key;\n                        _$rapyd$_chain_assign_temp = tmp.expression;\n                        tmp = _$rapyd$_chain_assign_temp;\n                        last_tok = _$rapyd$_chain_assign_temp;\n;\n                    }\n                    key = tmp.name + key;\n                    if (from_import && key === \"__python__\") {\n                        return read_python_flags();\n                    }\n                    alias = null;\n                    if (!from_import && is_(\"keyword\", \"as\")) {\n                        next();\n                        alias = as_symbol(AST_SymbolAlias);\n                    }\n                    aimp = new AST_Import({\n                        \"module\": name,\n                        \"key\": key,\n                        \"alias\": alias,\n                        \"argnames\": null,\n                        \"body\": (function() {\n                            var _$rapyd$_anonfunc = function () {\n                                return imported_modules[key];\n                            };\n                            return _$rapyd$_anonfunc;\n                        })()\n                    });\n                    _$rapyd$_unpack = [tok.start, last_tok.end];\n                    aimp.start = _$rapyd$_unpack[0];\n                    aimp.end = _$rapyd$_unpack[1];\n                    ans.imports.push(aimp);\n                    if (from_import) {\n                        break;\n                    }\n                    if (is_(\"punc\", \",\")) {\n                        next();\n                    } else {\n                        break;\n                    }\n                }\n                var _$rapyd$_Iter42 = _$rapyd$_Iterable(ans[\"imports\"]);\n                for (var _$rapyd$_Index42 = 0; _$rapyd$_Index42 < _$rapyd$_Iter42.length; _$rapyd$_Index42++) {\n                    imp = _$rapyd$_Iter42[_$rapyd$_Index42];\n                    do_import(imp.key);\n                    classes = imported_modules[key].classes;\n                    if (from_import) {\n                        expect_token(\"keyword\", \"import\");\n                        _$rapyd$_chain_assign_temp = _$rapyd$_list_decorate([]);\n                        imp.argnames = _$rapyd$_chain_assign_temp;\n                        argnames = _$rapyd$_chain_assign_temp;\n;\n                        bracketed = is_(\"punc\", \"(\");\n                        if (bracketed) {\n                            next();\n                        }\n                        exports = {};\n                        var _$rapyd$_Iter43 = _$rapyd$_Iterable(imported_modules[key].exports);\n                        for (var _$rapyd$_Index43 = 0; _$rapyd$_Index43 < _$rapyd$_Iter43.length; _$rapyd$_Index43++) {\n                            symdef = _$rapyd$_Iter43[_$rapyd$_Index43];\n                            exports[symdef.name] = true;\n                        }\n                        while (true) {\n                            aname = as_symbol(AST_ImportedVar);\n                            if (!options.for_linting && !exports.hasOwnProperty(aname.name)) {\n                                import_error(\"The symbol \\\"\" + aname.name + \"\\\" is not exported from the module: \" + key);\n                            }\n                            if (is_(\"keyword\", \"as\")) {\n                                next();\n                                aname.alias = as_symbol(AST_SymbolAlias);\n                            }\n                            argnames.push(aname);\n                            if (is_(\"punc\", \",\")) {\n                                next();\n                            } else {\n                                if (bracketed) {\n                                    if (is_(\"punc\", \")\")) {\n                                        next();\n                                    } else {\n                                        continue;\n                                    }\n                                }\n                                break;\n                            }\n                        }\n                        var _$rapyd$_Iter44 = _$rapyd$_Iterable(argnames);\n                        for (var _$rapyd$_Index44 = 0; _$rapyd$_Index44 < _$rapyd$_Iter44.length; _$rapyd$_Index44++) {\n                            argvar = _$rapyd$_Iter44[_$rapyd$_Index44];\n                            obj = classes[argvar.name];\n                            if (obj) {\n                                key = (argvar.alias) ? argvar.alias.name : argvar.name;\n                                S.classes[S.classes.length-1][key] = {\n                                    \"static\": obj.static,\n                                    \"bound\": obj.bound\n                                };\n                            }\n                        }\n                    } else {\n                        var _$rapyd$_Iter45 = _$rapyd$_Iterable(Object.keys(classes));\n                        for (var _$rapyd$_Index45 = 0; _$rapyd$_Index45 < _$rapyd$_Iter45.length; _$rapyd$_Index45++) {\n                            cname = _$rapyd$_Iter45[_$rapyd$_Index45];\n                            obj = classes[cname];\n                            key = (imp.alias) ? imp.alias.name : imp.key;\n                            S.classes[S.classes.length-1][key + \".\" + obj.name.name] = {\n                                \"static\": obj.static,\n                                \"bound\": obj.bound\n                            };\n                        }\n                    }\n                }\n                return ans;\n            };\n\n            import_.__argnames__ = [\"from_import\"];\n\n            function class_() {\n                var name, externaldecorator, class_details, definition, descriptor, _$rapyd$_chain_assign_temp, stmt, class_var_names, visitor;\n                name = as_symbol(AST_SymbolDefun);\n                if (!name) {\n                    unexpected();\n                }\n                externaldecorator = has_simple_decorator(S.decorators, \"external\");\n                class_details = {\n                    \"static\": _$rapyd$_list_decorate([]),\n                    \"bound\": {}\n                };\n                definition = new AST_Class({\n                    \"name\": name,\n                    \"module_id\": module_id,\n                    \"dynamic_properties\": {},\n                    \"parent\": (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            var a;\n                            if (is_(\"punc\", \"(\")) {\n                                S.in_parenthesized_expr = true;\n                                next();\n                                if (is_(\"punc\", \")\")) {\n                                    S.in_parenthesized_expr = false;\n                                    next();\n                                    return null;\n                                }\n                                a = expr_atom(false);\n                                expect(\")\");\n                                S.in_parenthesized_expr = false;\n                                return a;\n                            } else {\n                                return null;\n                            }\n                        };\n                        return _$rapyd$_anonfunc;\n                    })()(),\n                    \"localvars\": _$rapyd$_list_decorate([]),\n                    \"static\": class_details.static,\n                    \"external\": externaldecorator,\n                    \"bound\": class_details.bound,\n                    \"statements\": _$rapyd$_list_decorate([]),\n                    \"decorators\": (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            var d;\n                            d = _$rapyd$_list_decorate([]);\n                            S.decorators.forEach((function() {\n                                var _$rapyd$_anonfunc = function (decorator) {\n                                    d.push(new AST_Decorator({\n                                        \"expression\": decorator\n                                    }));\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"decorator\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                            S.decorators = [];\n                            return d;\n                        };\n                        return _$rapyd$_anonfunc;\n                    })()(),\n                    \"body\": (function() {\n                        var _$rapyd$_anonfunc = function (loop, labels) {\n                            var a;\n                            S.in_class.push(name.name);\n                            S.classes[S.classes.length - 1][name.name] = class_details;\n                            S.classes.push({});\n                            S.scoped_flags.push();\n                            S.in_function += 1;\n                            S.in_loop = 0;\n                            S.labels = _$rapyd$_list_decorate([]);\n                            a = block_();\n                            S.in_function -= 1;\n                            S.scoped_flags.pop();\n                            S.classes.pop();\n                            S.in_class.pop();\n                            S.in_loop = loop;\n                            S.labels = labels;\n                            return a;\n                        };\n\n                        _$rapyd$_anonfunc.__argnames__ = [\"loop\", \"labels\"];\n                        return _$rapyd$_anonfunc;\n                    })()(S.in_loop, S.labels)\n                });\n                var _$rapyd$_Iter46 = _$rapyd$_Iterable(definition.body);\n                for (var _$rapyd$_Index46 = 0; _$rapyd$_Index46 < _$rapyd$_Iter46.length; _$rapyd$_Index46++) {\n                    stmt = _$rapyd$_Iter46[_$rapyd$_Index46];\n                    if (stmt instanceof AST_Method) {\n                        if (stmt.is_getter || stmt.is_setter) {\n                            descriptor = definition.dynamic_properties[stmt.name.name];\n                            if (!descriptor) {\n                                _$rapyd$_chain_assign_temp = {};\n                                descriptor = _$rapyd$_chain_assign_temp;\n                                definition.dynamic_properties[stmt.name.name] = _$rapyd$_chain_assign_temp;\n;\n                            }\n                            descriptor[(stmt.is_getter) ? \"getter\" : \"setter\"] = stmt;\n                        } else if (stmt.name.name === \"__init__\") {\n                            definition.init = stmt;\n                        }\n                    }\n                }\n                class_var_names = {};\n                function walker() {\n                    function visit_node(node, descend) {\n                        if (node instanceof AST_Method) {\n                            class_var_names[node.name.name] = true;\n                            return;\n                        } else if (node instanceof AST_Assign && node.left instanceof AST_SymbolRef) {\n                            class_var_names[node.left.name] = true;\n                        } else if (node instanceof AST_SymbolRef && has_prop.call(class_var_names, node.name)) {\n                            node.thedef = new AST_SymbolDefun({\n                                \"name\": name.name + \".prototype.\" + node.name\n                            });\n                        }\n                        if (descend) {\n                            descend.call(node);\n                        }\n                    };\n\n                    visit_node.__argnames__ = [\"node\", \"descend\"];\n\n                    this._visit = visit_node;\n                };\n\n                visitor = new walker;\n                var _$rapyd$_Iter47 = _$rapyd$_Iterable(definition.body);\n                for (var _$rapyd$_Index47 = 0; _$rapyd$_Index47 < _$rapyd$_Iter47.length; _$rapyd$_Index47++) {\n                    stmt = _$rapyd$_Iter47[_$rapyd$_Index47];\n                    if (!(stmt instanceof AST_Class)) {\n                        stmt.walk(visitor);\n                        definition.statements.push(stmt);\n                    }\n                }\n                return definition;\n            };\n\n            function function_(in_class, is_expression) {\n                var name, is_anonymous, staticmethod, property_getter, property_setter, _$rapyd$_chain_assign_temp, staticloc, ctor, return_annotation, is_generator, definition, assignments, j, i, nonlocals;\n                name = (is_(\"name\")) ? as_symbol((in_class) ? AST_SymbolDefun : AST_SymbolLambda) : null;\n                if (in_class && !name) {\n                    croak(\"Cannot use anonymous function as class methods\");\n                }\n                is_anonymous = !name;\n                _$rapyd$_chain_assign_temp = false;\n                staticmethod = _$rapyd$_chain_assign_temp;\n                property_getter = _$rapyd$_chain_assign_temp;\n                property_setter = _$rapyd$_chain_assign_temp;\n;\n                if (in_class) {\n                    staticloc = has_simple_decorator(S.decorators, \"staticmethod\");\n                    property_getter = has_simple_decorator(S.decorators, \"property\");\n                    property_setter = has_setter_decorator(S.decorators, name.name);\n                    if (staticloc) {\n                        if (property_getter || property_setter) {\n                            croak(\"A method cannot be both static and a property getter/setter\");\n                        }\n                        S.classes[S.classes.length - 2][in_class].static.push(name.name);\n                        staticmethod = true;\n                    } else if (name.name !== \"__init__\" && options.auto_bind) {\n                        S.classes[S.classes.length - 2][in_class].bound[name.name] = true;\n                    }\n                }\n                expect(\"(\");\n                S.in_parenthesized_expr = true;\n                ctor = (in_class) ? AST_Method : AST_Function;\n                return_annotation = null;\n                is_generator = [];\n                definition = new ctor({\n                    \"name\": name,\n                    \"is_expression\": is_expression,\n                    \"is_anonymous\": is_anonymous,\n                    \"argnames\": (function() {\n                        var _$rapyd$_anonfunc = function (a) {\n                            var defaults, first, seen_names, def_line, val;\n                            defaults = {};\n                            first = true;\n                            seen_names = {};\n                            def_line = S.input.context().tokline;\n                            function get_arg() {\n                                var name_token, name_ctx, ntok, annotation, sym;\n                                if (has_prop.call(seen_names, S.token.value)) {\n                                    token_error(prev(), \"Can't repeat parameter names\");\n                                }\n                                if (S.token.value === \"arguments\") {\n                                    token_error(prev(), \"Can't use the name arguments as a parameter name, it is reserved by JavaScript\");\n                                }\n                                seen_names[S.token.value] = true;\n                                name_token = S.token;\n                                name_ctx = S.input.context();\n                                ntok = peek();\n                                if (ntok.type === \"punc\" && ntok.value === \":\") {\n                                    next();\n                                    expect(\":\");\n                                    annotation = maybe_conditional();\n                                    if (!is_token(name_token, \"name\")) {\n                                        croak(\"Name expected\", name_ctx.tokline);\n                                        return null;\n                                    }\n                                    sym = new AST_SymbolFunarg({\n                                        \"name\": name_token.value,\n                                        \"start\": S.token,\n                                        \"end\": S.token,\n                                        \"annotation\": annotation\n                                    });\n                                    return sym;\n                                } else {\n                                    if (!is_(\"name\")) {\n                                        if (S.input.context().tokline !== def_line) {\n                                            croak(\"Name expected\", def_line);\n                                        } else {\n                                            croak(\"Name expected\");\n                                        }\n                                        return null;\n                                    }\n                                    sym = new AST_SymbolFunarg({\n                                        \"name\": S.token.value,\n                                        \"start\": S.token,\n                                        \"end\": S.token,\n                                        \"annotation\": null\n                                    });\n                                    next();\n                                    return sym;\n                                }\n                            };\n\n                            while (!is_(\"punc\", \")\")) {\n                                if (first) {\n                                    first = false;\n                                } else {\n                                    expect(\",\");\n                                    if (is_(\"punc\", \")\")) {\n                                        break;\n                                    }\n                                }\n                                if (is_(\"operator\", \"**\")) {\n                                    next();\n                                    if (a.kwargs) {\n                                        token_error(prev(), \"Can't define multiple **kwargs in function definition\");\n                                    }\n                                    a.kwargs = get_arg();\n                                } else if (is_(\"operator\", \"*\")) {\n                                    next();\n                                    if (a.starargs) {\n                                        token_error(prev(), \"Can't define multiple *args in function definition\");\n                                    }\n                                    if (a.kwargs) {\n                                        token_error(prev(), \"Can't define *args after **kwargs in function definition\");\n                                    }\n                                    a.starargs = get_arg();\n                                } else {\n                                    if (a.starargs || a.kwargs) {\n                                        token_error(prev(), \"Can't define a formal parameter after *args or **kwargs\");\n                                    }\n                                    a.push(get_arg());\n                                    if (is_(\"operator\", \"=\")) {\n                                        if (a.kwargs) {\n                                            token_error(prev(), \"Can't define an optional formal parameter after **kwargs\");\n                                        }\n                                        val = prev().value;\n                                        next();\n                                        defaults[val] = expression(false);\n                                        a.has_defaults = true;\n                                    } else {\n                                        if (a.has_defaults) {\n                                            token_error(prev(), \"Can't define required formal parameters after optional formal parameters\");\n                                        }\n                                    }\n                                }\n                            }\n                            next();\n                            if (is_(\"punc\", \"->\")) {\n                                next();\n                                return_annotation = maybe_conditional();\n                            }\n                            S.in_parenthesized_expr = false;\n                            a.defaults = defaults;\n                            a.is_simple_func = !a.starargs && !a.kwargs && !a.has_defaults;\n                            return a;\n                        };\n\n                        _$rapyd$_anonfunc.__argnames__ = [\"a\"];\n                        return _$rapyd$_anonfunc;\n                    })()([]),\n                    \"localvars\": _$rapyd$_list_decorate([]),\n                    \"decorators\": (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            var d;\n                            d = [];\n                            S.decorators.forEach((function() {\n                                var _$rapyd$_anonfunc = function (decorator) {\n                                    d.push(new AST_Decorator({\n                                        \"expression\": decorator\n                                    }));\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"decorator\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                            S.decorators = [];\n                            return d;\n                        };\n                        return _$rapyd$_anonfunc;\n                    })()(),\n                    \"body\": (function() {\n                        var _$rapyd$_anonfunc = function (loop, labels) {\n                            var a;\n                            S.in_class.push(false);\n                            S.classes.push({});\n                            S.scoped_flags.push();\n                            S.in_function += 1;\n                            S.functions.push({});\n                            S.in_loop = 0;\n                            S.labels = _$rapyd$_list_decorate([]);\n                            a = block_();\n                            S.in_function -= 1;\n                            S.scoped_flags.pop();\n                            is_generator.push(bool(S.functions.pop().is_generator));\n                            S.classes.pop();\n                            S.in_class.pop();\n                            S.in_loop = loop;\n                            S.labels = labels;\n                            return a;\n                        };\n\n                        _$rapyd$_anonfunc.__argnames__ = [\"loop\", \"labels\"];\n                        return _$rapyd$_anonfunc;\n                    })()(S.in_loop, S.labels)\n                });\n                definition.return_annotation = return_annotation;\n                definition.is_generator = is_generator[0];\n                if (definition instanceof AST_Method) {\n                    definition.static = staticmethod;\n                    definition.is_getter = property_getter;\n                    definition.is_setter = property_setter;\n                    if (definition.argnames.length < 1 && !definition.static) {\n                        croak(\"Methods of a class must have at least one argument, traditionally named self\");\n                    }\n                    if (definition.name && definition.name.name === \"__init__\") {\n                        if (definition.is_generator) {\n                            croak(\"The __init__ method of a class cannot be a generator (yield not allowed)\");\n                        }\n                        if (property_getter || property_setter) {\n                            croak(\"The __init__ method of a class cannot be a property getter/setter\");\n                        }\n                    }\n                }\n                if (definition.is_generator) {\n                    baselib_items[\"yield\"] = true;\n                }\n                assignments = scan_for_local_vars(definition.body);\n                for (var _$rapyd$_Index48 = 0; _$rapyd$_Index48 < assignments.length; _$rapyd$_Index48++) {\n                    i = _$rapyd$_Index48;\n                    for (var _$rapyd$_Index49 = 0; _$rapyd$_Index49 < definition.argnames.length + 1; _$rapyd$_Index49++) {\n                        j = _$rapyd$_Index49;\n                        if (j === definition.argnames.length) {\n                            definition.localvars.push(new_symbol(AST_SymbolVar, assignments[i]));\n                        } else if (j < definition.argnames.length && assignments[i] === definition.argnames[j].name) {\n                            break;\n                        }\n                    }\n                }\n                nonlocals = scan_for_nonlocal_defs(definition.body);\n                nonlocals = (function() {\n                    var _$rapyd$_Iter = _$rapyd$_Iterable(nonlocals), _$rapyd$_Result = _$rapyd$_set(), name;\n                    for (var _$rapyd$_Index = 0; _$rapyd$_Index < _$rapyd$_Iter.length; _$rapyd$_Index++) {\n                        name = _$rapyd$_Iter[_$rapyd$_Index];\n                        _$rapyd$_Result.add(name);\n                    }\n                    return _$rapyd$_Result;\n                })();\n                definition.localvars = definition.localvars.filter((function() {\n                    var _$rapyd$_anonfunc = function (v) {\n                        return !nonlocals.has(v.name);\n                    };\n\n                    _$rapyd$_anonfunc.__argnames__ = [\"v\"];\n                    return _$rapyd$_anonfunc;\n                })());\n                return definition;\n            };\n\n            function_.__argnames__ = [\"in_class\", \"is_expression\"];\n\n            function if_() {\n                var cond, body, belse;\n                cond = expression(true);\n                body = statement();\n                belse = null;\n                if (is_(\"keyword\", \"elif\") || is_(\"keyword\", \"else\")) {\n                    if (is_(\"keyword\", \"else\")) {\n                        next();\n                    } else {\n                        S.token.value = \"if\";\n                    }\n                    belse = statement();\n                }\n                return new AST_If({\n                    \"condition\": cond,\n                    \"body\": body,\n                    \"alternative\": belse\n                });\n            };\n\n            function block_() {\n                var a;\n                expect(\":\");\n                a = [];\n                if (!S.token.nlb) {\n                    while (!S.token.nlb) {\n                        if (is_(\"eof\")) {\n                            unexpected();\n                        }\n                        a.push(statement());\n                    }\n                } else {\n                    while (!is_(\"punc\", \"}\")) {\n                        if (is_(\"eof\")) {\n                            return a;\n                        }\n                        a.push(statement());\n                    }\n                    next();\n                }\n                return a;\n            };\n\n            function try_() {\n                var body, bcatch, bfinally, start, exceptions, name;\n                body = block_();\n                bcatch = _$rapyd$_list_decorate([]);\n                bfinally = null;\n                while (is_(\"keyword\", \"except\")) {\n                    start = S.token;\n                    next();\n                    exceptions = _$rapyd$_list_decorate([]);\n                    if (!is_(\"punc\", \":\") && !is_(\"keyword\", \"as\")) {\n                        exceptions.push(as_symbol(AST_SymbolVar));\n                        while (is_(\"punc\", \",\")) {\n                            next();\n                            exceptions.push(as_symbol(AST_SymbolVar));\n                        }\n                    }\n                    name = null;\n                    if (is_(\"keyword\", \"as\")) {\n                        next();\n                        name = as_symbol(AST_SymbolCatch);\n                    }\n                    bcatch.push(new AST_Except({\n                        \"start\": start,\n                        \"argname\": name,\n                        \"errors\": exceptions,\n                        \"body\": block_(),\n                        \"end\": prev()\n                    }));\n                }\n                if (is_(\"keyword\", \"finally\")) {\n                    start = S.token;\n                    next();\n                    bfinally = new AST_Finally({\n                        \"start\": start,\n                        \"body\": block_(),\n                        \"end\": prev()\n                    });\n                }\n                if (!bcatch.length && !bfinally) {\n                    croak(\"Missing except/finally blocks\");\n                }\n                return new AST_Try({\n                    \"body\": body,\n                    \"bcatch\": (bcatch.length) ? new AST_Catch({\n                        \"body\": bcatch\n                    }) : null,\n                    \"bfinally\": bfinally\n                });\n            };\n\n            function vardefs(no_in, in_const, in_nonlocal) {\n                var a;\n                a = _$rapyd$_list_decorate([]);\n                while (true) {\n                    a.push(new AST_VarDef({\n                        \"start\": S.token,\n                        \"name\": as_symbol((in_const) ? AST_SymbolConst : (in_nonlocal) ? AST_SymbolNonlocal : AST_SymbolVar),\n                        \"value\": (is_(\"operator\", \"=\")) ? (next(), expression(false, no_in)) : null,\n                        \"end\": prev()\n                    }));\n                    if (!is_(\"punc\", \",\")) {\n                        break;\n                    }\n                    next();\n                }\n                return a;\n            };\n\n            vardefs.__argnames__ = [\"no_in\", \"in_const\", \"in_nonlocal\"];\n\n            function nonlocal_(no_in) {\n                return new AST_Var({\n                    \"start\": prev(),\n                    \"definitions\": vardefs(no_in, false, true),\n                    \"end\": prev()\n                });\n            };\n\n            nonlocal_.__argnames__ = [\"no_in\"];\n\n            function const_() {\n                return new AST_Const({\n                    \"start\": prev(),\n                    \"definitions\": vardefs(false, true),\n                    \"end\": prev()\n                });\n            };\n\n            function new_() {\n                var start, newexp, args;\n                start = S.token;\n                expect_token(\"operator\", \"new\");\n                newexp = expr_atom(false);\n                if (is_(\"punc\", \"(\")) {\n                    S.in_parenthesized_expr = true;\n                    next();\n                    args = func_call_list();\n                    S.in_parenthesized_expr = false;\n                } else {\n                    args = func_call_list(true);\n                }\n                return subscripts(new AST_New({\n                    \"start\": start,\n                    \"expression\": newexp,\n                    \"args\": args,\n                    \"end\": prev()\n                }), true);\n            };\n\n            function string_() {\n                var strings, start;\n                strings = [];\n                start = S.token;\n                while (true) {\n                    strings.push(S.token.value);\n                    if (peek().type !== \"string\") {\n                        break;\n                    }\n                    next();\n                }\n                return new AST_String({\n                    \"start\": start,\n                    \"end\": S.token,\n                    \"value\": strings.join(\"\")\n                });\n            };\n\n            function token_as_atom_node() {\n                var tok, tmp_, tmp__;\n                tok = S.token;\n                tmp_ = tok.type;\n                if (tmp_ === \"name\") {\n                    return token_as_symbol(tok, AST_SymbolRef);\n                } else if (tmp_ === \"num\") {\n                    return new AST_Number({\n                        \"start\": tok,\n                        \"end\": tok,\n                        \"value\": tok.value\n                    });\n                } else if (tmp_ === \"string\") {\n                    return string_();\n                } else if (tmp_ === \"regexp\") {\n                    return new AST_RegExp({\n                        \"start\": tok,\n                        \"end\": tok,\n                        \"value\": tok.value\n                    });\n                } else if (tmp_ === \"atom\") {\n                    tmp__ = tok.value;\n                    if (tmp__ === \"False\") {\n                        return new AST_False({\n                            \"start\": tok,\n                            \"end\": tok\n                        });\n                    } else if (tmp__ === \"True\") {\n                        return new AST_True({\n                            \"start\": tok,\n                            \"end\": tok\n                        });\n                    } else if (tmp__ === \"None\") {\n                        return new AST_Null({\n                            \"start\": tok,\n                            \"end\": tok\n                        });\n                    }\n                } else if (tmp_ === \"js\") {\n                    return new AST_Verbatim({\n                        \"start\": tok,\n                        \"end\": tok,\n                        \"value\": tok.value\n                    });\n                }\n                token_error(tok, \"Expecting an atomic token (number/string/bool/regexp/js/None)\");\n            };\n\n            function as_atom_node() {\n                var ret;\n                ret = token_as_atom_node();\n                next();\n                return ret;\n            };\n\n            function expr_atom(allow_calls) {\n                var start, tmp_, ex, ret, cls, func;\n                if (is_(\"operator\", \"new\")) {\n                    return new_();\n                }\n                start = S.token;\n                if (is_(\"punc\")) {\n                    tmp_ = start.value;\n                    if (tmp_ === \"(\") {\n                        S.in_parenthesized_expr = true;\n                        next();\n                        if (is_(\"punc\", \")\")) {\n                            next();\n                            return new AST_Array({\n                                \"elements\": _$rapyd$_list_decorate([])\n                            });\n                        }\n                        ex = expression(true);\n                        if (is_(\"keyword\", \"for\")) {\n                            ret = read_comprehension(new AST_GeneratorComprehension({\n                                \"statement\": ex\n                            }), \")\");\n                            S.in_parenthesized_expr = false;\n                            return ret;\n                        }\n                        ex.start = start;\n                        ex.end = S.token;\n                        if (ex instanceof AST_SymbolRef) {\n                            ex.parens = true;\n                        }\n                        if (!(ex instanceof AST_GeneratorComprehension)) {\n                            expect(\")\");\n                        }\n                        S.in_parenthesized_expr = false;\n                        return subscripts(ex, allow_calls);\n                    } else if (tmp_ === \"[\") {\n                        return subscripts(array_(), allow_calls);\n                    } else if (tmp_ === \"{\") {\n                        return subscripts(object_(), allow_calls);\n                    }\n                    unexpected();\n                }\n                if (is_(\"keyword\", \"class\")) {\n                    next();\n                    cls = class_();\n                    cls.start = start;\n                    cls.end = prev();\n                    return subscripts(cls, allow_calls);\n                }\n                if (is_(\"keyword\", \"def\")) {\n                    next();\n                    func = function_(false, true);\n                    func.start = start;\n                    func.end = prev();\n                    return subscripts(func, allow_calls);\n                }\n                if (is_(\"keyword\", \"yield\")) {\n                    next();\n                    return yield_();\n                }\n                if (ATOMIC_START_TOKEN[S.token.type]) {\n                    return subscripts(as_atom_node(), allow_calls);\n                }\n                unexpected();\n            };\n\n            expr_atom.__argnames__ = [\"allow_calls\"];\n\n            function expr_list(closing, allow_trailing_comma, allow_empty, func_call) {\n                var first, a, saw_starargs, tmp, arg;\n                first = true;\n                a = _$rapyd$_list_decorate([]);\n                saw_starargs = false;\n                while (!is_(\"punc\", closing)) {\n                    if (saw_starargs) {\n                        token_error(prev(), \"*args must be the last argument in a function call\");\n                    }\n                    if (first) {\n                        first = false;\n                    } else {\n                        expect(\",\");\n                    }\n                    if (allow_trailing_comma && is_(\"punc\", closing)) {\n                        break;\n                    }\n                    if (is_(\"operator\", \"*\") && func_call) {\n                        saw_starargs = true;\n                        next();\n                    }\n                    if (is_(\"punc\", \",\") && allow_empty) {\n                        a.push(new AST_Hole({\n                            \"start\": S.token,\n                            \"end\": S.token\n                        }));\n                    } else {\n                        a.push(expression(false));\n                    }\n                }\n                if (func_call) {\n                    tmp = _$rapyd$_list_decorate([]);\n                    tmp.kwargs = _$rapyd$_list_decorate([]);\n                    var _$rapyd$_Iter50 = _$rapyd$_Iterable(a);\n                    for (var _$rapyd$_Index50 = 0; _$rapyd$_Index50 < _$rapyd$_Iter50.length; _$rapyd$_Index50++) {\n                        arg = _$rapyd$_Iter50[_$rapyd$_Index50];\n                        if (arg instanceof AST_Assign) {\n                            tmp.kwargs.push(_$rapyd$_list_decorate([ arg.left, arg.right ]));\n                        } else {\n                            tmp.push(arg);\n                        }\n                    }\n                    a = tmp;\n                }\n                next();\n                if (saw_starargs) {\n                    a.starargs = true;\n                }\n                return a;\n            };\n\n            expr_list.__argnames__ = [\"closing\", \"allow_trailing_comma\", \"allow_empty\", \"func_call\"];\n\n            function func_call_list(empty) {\n                var a, first, single_comprehension, arg;\n                a = [];\n                first = true;\n                a.kwargs = [];\n                a.kwarg_items = [];\n                a.starargs = false;\n                if (empty) {\n                    return a;\n                }\n                single_comprehension = false;\n                while (!is_(\"punc\", \")\") && !is_(\"eof\")) {\n                    if (!first) {\n                        expect(\",\");\n                        if (is_(\"punc\", \")\")) {\n                            break;\n                        }\n                    }\n                    if (is_(\"operator\", \"*\")) {\n                        next();\n                        arg = expression(false);\n                        arg.is_array = true;\n                        a.push(arg);\n                        a.starargs = true;\n                    } else if (is_(\"operator\", \"**\")) {\n                        next();\n                        a.kwarg_items.push(as_symbol(AST_SymbolRef, false));\n                        a.starargs = true;\n                    } else {\n                        arg = expression(false);\n                        if (arg instanceof AST_Assign) {\n                            a.kwargs.push(_$rapyd$_list_decorate([ arg.left, arg.right ]));\n                        } else {\n                            if (is_(\"keyword\", \"for\")) {\n                                if (!first) {\n                                    croak(\"Generator expression must be parenthesized if not sole argument\");\n                                }\n                                a.push(read_comprehension(new AST_GeneratorComprehension({\n                                    \"statement\": arg\n                                }), \")\"));\n                                single_comprehension = true;\n                                break;\n                            }\n                            a.push(arg);\n                        }\n                    }\n                    first = false;\n                }\n                if (!single_comprehension) {\n                    next();\n                }\n                return a;\n            };\n\n            func_call_list.__argnames__ = [\"empty\"];\n\n            \n            var array_ = embed_tokens((function() {\n                var _$rapyd$_anonfunc = function array_() {\n                    var expr;\n                    expect(\"[\");\n                    expr = _$rapyd$_list_decorate([]);\n                    if (!is_(\"punc\", \"]\")) {\n                        expr.push(expression(false));\n                        if (is_(\"keyword\", \"for\")) {\n                            return read_comprehension(new AST_ListComprehension({\n                                \"statement\": expr[0]\n                            }), \"]\");\n                        }\n                        if (!is_(\"punc\", \"]\")) {\n                            expect(\",\");\n                        }\n                    }\n                    return new AST_Array({\n                        \"elements\": expr.concat(expr_list(\"]\", true, true))\n                    });\n                };\n                return _$rapyd$_anonfunc;\n            })());\n\n            \n            var object_ = embed_tokens((function() {\n                var _$rapyd$_anonfunc = function object_() {\n                    var first, has_non_const_keys, is_pydict, a, start, ctx, orig, left, end;\n                    expect(\"{\");\n                    first = true;\n                    has_non_const_keys = false;\n                    is_pydict = S.scoped_flags.get(\"dict_literals\", false);\n                    a = _$rapyd$_list_decorate([]);\n                    while (!is_(\"punc\", \"}\")) {\n                        if (!first) {\n                            expect(\",\");\n                        }\n                        if (is_(\"punc\", \"}\")) {\n                            break;\n                        }\n                        first = false;\n                        start = S.token;\n                        ctx = S.input.context();\n                        orig = ctx.expecting_object_literal_key;\n                        ctx.expecting_object_literal_key = true;\n                        try {\n                            left = expression(false);\n                        } finally {\n                            ctx.expecting_object_literal_key = orig;\n                        }\n                        if (is_(\"keyword\", \"for\")) {\n                            return read_comprehension(new AST_SetComprehension({\n                                \"statement\": left\n                            }), \"}\");\n                        }\n                        if (a.length === 0 && (is_(\"punc\", \",\") || is_(\"punc\", \"}\"))) {\n                            end = prev();\n                            return set_(start, end, left);\n                        }\n                        if (!(left instanceof AST_Constant)) {\n                            has_non_const_keys = true;\n                        }\n                        expect(\":\");\n                        a.push(new AST_ObjectKeyVal({\n                            \"start\": start,\n                            \"key\": left,\n                            \"value\": expression(false),\n                            \"end\": prev()\n                        }));\n                        if (a.length === 1 && is_(\"keyword\", \"for\")) {\n                            return dict_comprehension(a, is_pydict);\n                        }\n                    }\n                    next();\n                    return new ((has_non_const_keys) ? AST_ExpressiveObject : AST_Object)({\n                        \"properties\": a,\n                        \"is_pydict\": is_pydict\n                    });\n                };\n                return _$rapyd$_anonfunc;\n            })());\n\n            function set_(start, end, expr) {\n                var ostart, a;\n                ostart = start;\n                a = _$rapyd$_list_decorate([ new AST_SetItem({\n                    \"start\": start,\n                    \"end\": end,\n                    \"value\": expr\n                }) ]);\n                while (!is_(\"punc\", \"}\")) {\n                    expect(\",\");\n                    start = S.token;\n                    if (is_(\"punc\", \"}\")) {\n                        break;\n                    }\n                    a.push(new AST_SetItem({\n                        \"start\": start,\n                        \"value\": expression(false),\n                        \"end\": prev()\n                    }));\n                }\n                next();\n                return new AST_Set({\n                    \"items\": a,\n                    \"start\": ostart,\n                    \"end\": prev()\n                });\n            };\n\n            set_.__argnames__ = [\"start\", \"end\", \"expr\"];\n\n            function read_comprehension(obj, terminator) {\n                var forloop;\n                if (obj instanceof AST_GeneratorComprehension) {\n                    baselib_items[\"yield\"] = true;\n                }\n                S.in_comprehension = true;\n                S.in_parenthesized_expr = false;\n                expect_token(\"keyword\", \"for\");\n                forloop = for_(true);\n                obj.init = forloop.init;\n                obj.name = forloop.name;\n                obj.object = forloop.object;\n                obj.condition = (is_(\"punc\", terminator)) ? null : (expect_token(\"keyword\", \"if\"), \n                expression(true));\n                expect(terminator);\n                S.in_comprehension = false;\n                return obj;\n            };\n\n            read_comprehension.__argnames__ = [\"obj\", \"terminator\"];\n\n            function dict_comprehension(a, is_pydict) {\n                var _$rapyd$_unpack, left, right;\n                if (a.length) {\n                    _$rapyd$_unpack = [a[0].key, a[0].value];\n                    left = _$rapyd$_unpack[0];\n                    right = _$rapyd$_unpack[1];\n                } else {\n                    left = expression(false);\n                    if (!is_(\"punc\", \":\")) {\n                        return read_comprehension(new AST_SetComprehension({\n                            \"statement\": left\n                        }), \"}\");\n                    }\n                    expect(\":\");\n                    right = expression(false);\n                }\n                return read_comprehension(new AST_DictComprehension({\n                    \"statement\": left,\n                    \"value_statement\": right,\n                    \"is_pydict\": is_pydict\n                }), \"}\");\n            };\n\n            dict_comprehension.__argnames__ = [\"a\", \"is_pydict\"];\n\n            function as_name() {\n                var tmp, tmp_;\n                tmp = S.token;\n                next();\n                tmp_ = tmp.type;\n                if (tmp_ === \"name\" || tmp_ === \"operator\" || tmp_ === \"keyword\" || tmp_ === \"atom\") {\n                    return tmp.value;\n                } else {\n                    unexpected();\n                }\n            };\n\n            function token_as_symbol(tok, ttype) {\n                var name;\n                name = tok.value;\n                return new ((name === \"this\") ? AST_This : ttype)({\n                    \"name\": String(tok.value),\n                    \"start\": tok,\n                    \"end\": tok\n                });\n            };\n\n            token_as_symbol.__argnames__ = [\"tok\", \"ttype\"];\n\n            function as_symbol(ttype, noerror) {\n                var sym;\n                if (!is_(\"name\")) {\n                    if (!noerror) {\n                        croak(\"Name expected\");\n                    }\n                    return null;\n                }\n                sym = token_as_symbol(S.token, ttype);\n                next();\n                return sym;\n            };\n\n            as_symbol.__argnames__ = [\"ttype\", \"noerror\"];\n\n            function new_symbol(type, name) {\n                var sym;\n                sym = new ((name === \"this\") ? AST_This : type)({\n                    \"name\": String(name),\n                    \"start\": null,\n                    \"end\": null\n                });\n                return sym;\n            };\n\n            new_symbol.__argnames__ = [\"type\", \"name\"];\n\n            function is_static_method(cls, method) {\n                if (COMMON_STATIC.indexOf(method) !== -1 || cls.static && cls.static.indexOf(method) !== -1) {\n                    return true;\n                } else {\n                    return false;\n                }\n            };\n\n            is_static_method.__argnames__ = [\"cls\", \"method\"];\n\n            function subscripts(expr, allow_calls) {\n                var start, is_py_sub, slice_bounds, is_slice, i, assignment, ret, c, funcname, tmp_, args;\n                start = expr.start;\n                if (is_(\"punc\", \".\")) {\n                    next();\n                    return subscripts(new AST_Dot({\n                        \"start\": start,\n                        \"expression\": expr,\n                        \"property\": as_name(),\n                        \"end\": prev()\n                    }), allow_calls);\n                }\n                if (is_(\"punc\", \"[\") && !S.token.nlb) {\n                    next();\n                    is_py_sub = S.scoped_flags.get(\"overload_getitem\", false);\n                    slice_bounds = _$rapyd$_list_decorate([]);\n                    is_slice = false;\n                    if (is_(\"punc\", \":\")) {\n                        slice_bounds.push(null);\n                    } else {\n                        slice_bounds.push(expression(false));\n                    }\n                    if (is_(\"punc\", \":\")) {\n                        is_slice = true;\n                        next();\n                        if (is_(\"punc\", \":\")) {\n                            slice_bounds.push(null);\n                        } else if (!is_(\"punc\", \"]\")) {\n                            slice_bounds.push(expression(false));\n                        }\n                    }\n                    if (is_(\"punc\", \":\")) {\n                        next();\n                        if (is_(\"punc\", \"]\")) {\n                            unexpected();\n                        } else {\n                            slice_bounds.push(expression(false));\n                        }\n                    }\n                    expect(\"]\");\n                    if (is_slice) {\n                        if (is_(\"operator\") && S.token.value === \"=\") {\n                            next();\n                            return subscripts(new AST_Splice({\n                                \"start\": start,\n                                \"expression\": expr,\n                                \"property\": slice_bounds[0] || new AST_Number({\n                                    \"value\": 0\n                                }),\n                                \"property2\": slice_bounds[1],\n                                \"assignment\": expression(true),\n                                \"end\": prev()\n                            }), allow_calls);\n                        } else if (slice_bounds.length === 3) {\n                            slice_bounds.unshift(slice_bounds.pop());\n                            if (!slice_bounds[slice_bounds.length-1]) {\n                                slice_bounds.pop();\n                                if (!slice_bounds[slice_bounds.length-1]) {\n                                    slice_bounds.pop();\n                                }\n                            } else if (!slice_bounds[slice_bounds.length-2]) {\n                                slice_bounds[slice_bounds.length-2] = new AST_Undefined;\n                            }\n                            return subscripts(new AST_Call({\n                                \"start\": start,\n                                \"expression\": new AST_SymbolRef({\n                                    \"name\": \"_$rapyd$_eslice\"\n                                }),\n                                \"args\": _$rapyd$_list_decorate([ expr ]).concat(slice_bounds),\n                                \"end\": prev()\n                            }), allow_calls);\n                        } else {\n                            slice_bounds = (function() {\n                                var _$rapyd$_Iter = _$rapyd$_Iterable(slice_bounds), _$rapyd$_Result = [], i;\n                                for (var _$rapyd$_Index = 0; _$rapyd$_Index < _$rapyd$_Iter.length; _$rapyd$_Index++) {\n                                    i = _$rapyd$_Iter[_$rapyd$_Index];\n                                    _$rapyd$_Result.push((i === null) ? new AST_Number({\n                                        \"value\": 0\n                                    }) : i);\n                                }\n                                _$rapyd$_Result = _$rapyd$_list_constructor(_$rapyd$_Result);\n                                return _$rapyd$_Result;\n                            })();\n                            return subscripts(new AST_Call({\n                                \"start\": start,\n                                \"expression\": new AST_Dot({\n                                    \"start\": start,\n                                    \"expression\": expr,\n                                    \"property\": \"slice\",\n                                    \"end\": prev()\n                                }),\n                                \"args\": slice_bounds,\n                                \"end\": prev()\n                            }), allow_calls);\n                        }\n                    } else {\n                        if (is_py_sub) {\n                            assignment = null;\n                            if (is_(\"operator\") && S.token.value === \"=\") {\n                                next();\n                                assignment = expression(true);\n                            }\n                            return subscripts(new AST_ItemAccess({\n                                \"start\": start,\n                                \"expression\": expr,\n                                \"property\": slice_bounds[0] || new AST_Number({\n                                    \"value\": 0\n                                }),\n                                \"assignment\": assignment,\n                                \"end\": prev()\n                            }), allow_calls);\n                        }\n                        return subscripts(new AST_Sub({\n                            \"start\": start,\n                            \"expression\": expr,\n                            \"property\": slice_bounds[0] || new AST_Number({\n                                \"value\": 0\n                            }),\n                            \"end\": prev()\n                        }), allow_calls);\n                    }\n                }\n                if (allow_calls && is_(\"punc\", \"(\") && !S.token.nlb) {\n                    S.in_parenthesized_expr = true;\n                    next();\n                    if (!expr.parens && get_class_in_scope(expr)) {\n                        ret = subscripts(new AST_New({\n                            \"start\": start,\n                            \"expression\": expr,\n                            \"args\": func_call_list(),\n                            \"end\": prev()\n                        }), true);\n                        S.in_parenthesized_expr = false;\n                        return ret;\n                    } else {\n                        if (expr instanceof AST_Dot) {\n                            c = get_class_in_scope(expr.expression);\n                        }\n                        if (c) {\n                            funcname = expr;\n                            if (funcname.property === \"__init__\") {\n                                funcname.property = \"constructor\";\n                            }\n                            ret = subscripts(new AST_ClassCall({\n                                \"start\": start,\n                                \"class\": expr.expression,\n                                \"method\": funcname.property,\n                                \"static\": is_static_method(c, funcname.property),\n                                \"args\": func_call_list(),\n                                \"end\": prev()\n                            }), true);\n                            S.in_parenthesized_expr = false;\n                            return ret;\n                        } else if (expr instanceof AST_SymbolRef) {\n                            tmp_ = expr.name;\n                            if (tmp_ === \"type\") {\n                                ret = new AST_UnaryPrefix({\n                                    \"start\": start,\n                                    \"operator\": \"typeof\",\n                                    \"expression\": func_call_list()[0],\n                                    \"end\": prev()\n                                });\n                                S.in_parenthesized_expr = false;\n                                return ret;\n                            } else if (tmp_ === \"isinstance\") {\n                                args = func_call_list();\n                                if (args.length !== 2) {\n                                    croak(\"isinstance() must be called with exactly two arguments\");\n                                }\n                                ret = new AST_Binary({\n                                    \"start\": start,\n                                    \"left\": args[0],\n                                    \"operator\": \"instanceof\",\n                                    \"right\": args[1],\n                                    \"end\": prev()\n                                });\n                                S.in_parenthesized_expr = false;\n                                return ret;\n                            }\n                        }\n                        ret = subscripts(new AST_Call({\n                            \"start\": start,\n                            \"expression\": expr,\n                            \"args\": func_call_list(),\n                            \"end\": prev()\n                        }), true);\n                        S.in_parenthesized_expr = false;\n                        return ret;\n                    }\n                }\n                return expr;\n            };\n\n            subscripts.__argnames__ = [\"expr\", \"allow_calls\"];\n\n            function maybe_unary(allow_calls) {\n                var start, expr, ex, val;\n                start = S.token;\n                if (is_(\"operator\", \"@\")) {\n                    if (S.parsing_decorator) {\n                        croak(\"Nested decorators are not allowed\");\n                    }\n                    next();\n                    S.parsing_decorator = true;\n                    expr = expression();\n                    S.parsing_decorator = false;\n                    S.decorators.push(expr);\n                    return new AST_EmptyStatement({\n                        \"stype\": \"@\",\n                        \"start\": prev(),\n                        \"end\": prev()\n                    });\n                }\n                if (is_(\"operator\") && UNARY_PREFIX(start.value)) {\n                    next();\n                    ex = make_unary(AST_UnaryPrefix, start.value, maybe_unary(allow_calls));\n                    ex.start = start;\n                    ex.end = prev();\n                    return ex;\n                }\n                val = expr_atom(allow_calls);\n                while (is_(\"operator\") && UNARY_POSTFIX(S.token.value) && !S.token.nlb) {\n                    val = make_unary(AST_UnaryPostfix, S.token.value, val);\n                    val.start = start;\n                    val.end = S.token;\n                    next();\n                }\n                return val;\n            };\n\n            maybe_unary.__argnames__ = [\"allow_calls\"];\n\n            function make_unary(ctor, op, expr) {\n                return new ctor({\n                    \"operator\": op,\n                    \"expression\": expr\n                });\n            };\n\n            make_unary.__argnames__ = [\"ctor\", \"op\", \"expr\"];\n\n            function expr_op(left, min_prec, no_in) {\n                var op, not_in, prec, right, ret;\n                op = (is_(\"operator\")) ? S.token.value : null;\n                not_in = false;\n                if (op === \"!\" && peek().type === \"operator\" && peek().value === \"in\") {\n                    next();\n                    op = \"in\";\n                    not_in = true;\n                }\n                if (op === \"in\") {\n                    if (no_in) {\n                        op = null;\n                    }\n                }\n                prec = (op !== null) ? PRECEDENCE[op] : null;\n                if (prec !== null && prec > min_prec) {\n                    next();\n                    right = expr_op(maybe_unary(true), prec, no_in);\n                    ret = new AST_Binary({\n                        \"start\": left.start,\n                        \"left\": left,\n                        \"operator\": op,\n                        \"right\": right,\n                        \"end\": right.end\n                    });\n                    if (not_in) {\n                        ret = new AST_UnaryPrefix({\n                            \"start\": left.start,\n                            \"operator\": \"!\",\n                            \"expression\": ret,\n                            \"end\": right.end\n                        });\n                    }\n                    return expr_op(ret, min_prec, no_in);\n                }\n                return left;\n            };\n\n            expr_op.__argnames__ = [\"left\", \"min_prec\", \"no_in\"];\n\n            function expr_ops(no_in) {\n                return expr_op(maybe_unary(true), 0, no_in);\n            };\n\n            expr_ops.__argnames__ = [\"no_in\"];\n\n            function maybe_conditional(no_in) {\n                var start, expr, pystyle, ne, conditional, yes;\n                start = S.token;\n                expr = expr_ops(no_in);\n                if (is_(\"operator\", \"?\") || is_(\"keyword\", \"if\") && (S.in_parenthesized_expr || S.statement_starting_token !== S.token && !S.in_comprehension && !S.token.nlb)) {\n                    pystyle = is_(\"keyword\", \"if\");\n                    next();\n                    ne = expression(false);\n                    if (pystyle) {\n                        expect_token(\"keyword\", \"else\");\n                        conditional = new AST_Conditional({\n                            \"start\": start,\n                            \"condition\": ne,\n                            \"consequent\": expr,\n                            \"alternative\": expression(false, no_in),\n                            \"end\": peek()\n                        });\n                    } else {\n                        yes = ne;\n                        expect(\":\");\n                        conditional = new AST_Conditional({\n                            \"start\": start,\n                            \"condition\": expr,\n                            \"consequent\": yes,\n                            \"alternative\": expression(false, no_in),\n                            \"end\": peek()\n                        });\n                    }\n                    return conditional;\n                }\n                return expr;\n            };\n\n            maybe_conditional.__argnames__ = [\"no_in\"];\n\n            function create_assign(data) {\n                if (data.right && data.right instanceof AST_Seq && (data.right.car instanceof AST_Assign || data.right.cdr instanceof AST_Assign) && data.operator !== \"=\") {\n                    token_error(data.start, \"Invalid assignment operator for chained assignment: \" + data.operator);\n                }\n                return new AST_Assign(data);\n            };\n\n            create_assign.__argnames__ = [\"data\"];\n\n            function maybe_assign(no_in, only_plain_assignment) {\n                var start, left, val;\n                start = S.token;\n                left = maybe_conditional(no_in);\n                val = S.token.value;\n                if (is_(\"operator\") && ASSIGNMENT(val)) {\n                    if (only_plain_assignment && val !== \"=\") {\n                        croak(\"Invalid assignment operator for chained assignment: \" + val);\n                    }\n                    next();\n                    return create_assign({\n                        \"start\": start,\n                        \"left\": left,\n                        \"operator\": val,\n                        \"right\": maybe_assign(no_in, true),\n                        \"end\": prev()\n                    });\n                }\n                return left;\n            };\n\n            maybe_assign.__argnames__ = [\"no_in\", \"only_plain_assignment\"];\n\n            function expression(commas, no_in) {\n                var start, expr, left;\n                start = S.token;\n                expr = maybe_assign(no_in);\n                function build_seq(a) {\n                    if (a.length === 1) {\n                        return a[0];\n                    }\n                    return new AST_Seq({\n                        \"start\": start,\n                        \"car\": a.shift(),\n                        \"cdr\": build_seq(a),\n                        \"end\": peek()\n                    });\n                };\n\n                build_seq.__argnames__ = [\"a\"];\n\n                if (commas) {\n                    left = [ expr ];\n                    while (is_(\"punc\", \",\") && !peek().nlb) {\n                        next();\n                        if (expr instanceof AST_Assign) {\n                            left[left.length-1] = left[left.length-1].left;\n                            return create_assign({\n                                \"start\": start,\n                                \"left\": (left.length === 1) ? left[0] : new AST_Array({\n                                    \"elements\": left\n                                }),\n                                \"operator\": expr.operator,\n                                \"right\": new AST_Seq({\n                                    \"car\": expr.right,\n                                    \"cdr\": expression(true, no_in)\n                                }),\n                                \"end\": peek()\n                            });\n                        }\n                        expr = maybe_assign(no_in);\n                        left.push(expr);\n                    }\n                    if (left.length > 1 && left[left.length-1] instanceof AST_Assign) {\n                        left[left.length-1] = left[left.length-1].left;\n                        return create_assign({\n                            \"start\": start,\n                            \"left\": new AST_Array({\n                                \"elements\": left\n                            }),\n                            \"operator\": expr.operator,\n                            \"right\": expr.right,\n                            \"end\": peek()\n                        });\n                    }\n                    return build_seq(left);\n                }\n                return expr;\n            };\n\n            expression.__argnames__ = [\"commas\", \"no_in\"];\n\n            function in_loop(cont) {\n                var ret;\n                S.in_loop += 1;\n                ret = cont();\n                S.in_loop -= 1;\n                return ret;\n            };\n\n            in_loop.__argnames__ = [\"cont\"];\n\n            function run_parser() {\n                var start, _$rapyd$_chain_assign_temp, body, first_token, element, shebang, end, toplevel, seen_exports;\n                _$rapyd$_chain_assign_temp = next();\n                start = _$rapyd$_chain_assign_temp;\n                S.token = _$rapyd$_chain_assign_temp;\n;\n                body = _$rapyd$_list_decorate([]);\n                first_token = true;\n                while (!is_(\"eof\")) {\n                    element = statement();\n                    if (first_token && element instanceof AST_Directive && element.value.indexOf(\"#!\") === 0) {\n                        shebang = element.value;\n                    } else {\n                        body.push(element);\n                    }\n                    first_token = false;\n                }\n                end = prev();\n                toplevel = options.toplevel;\n                if (toplevel) {\n                    toplevel.body = toplevel.body.concat(body);\n                    toplevel.end = end;\n                } else {\n                    toplevel = new AST_Toplevel({\n                        \"start\": start,\n                        \"body\": body,\n                        \"shebang\": shebang,\n                        \"end\": end\n                    });\n                }\n                toplevel.nonlocalvars = scan_for_nonlocal_defs(toplevel.body);\n                toplevel.localvars = _$rapyd$_list_decorate([]);\n                toplevel.exports = _$rapyd$_list_decorate([]);\n                seen_exports = {};\n                function add_item(item, isvar) {\n                    var symbol;\n                    if (toplevel.nonlocalvars.indexOf(item) < 0) {\n                        symbol = new_symbol(AST_SymbolVar, item);\n                        if (isvar) {\n                            toplevel.localvars.push(symbol);\n                        }\n                        if (!has_prop.call(seen_exports, item)) {\n                            toplevel.exports.push(symbol);\n                            seen_exports[item] = true;\n                        }\n                    }\n                };\n\n                add_item.__argnames__ = [\"item\", \"isvar\"];\n\n                scan_for_local_vars(toplevel.body).forEach((function() {\n                    var _$rapyd$_anonfunc = function (item) {\n                        add_item(item, true);\n                    };\n\n                    _$rapyd$_anonfunc.__argnames__ = [\"item\"];\n                    return _$rapyd$_anonfunc;\n                })());\n                scan_for_top_level_callables(toplevel.body).forEach((function() {\n                    var _$rapyd$_anonfunc = function (item) {\n                        add_item(item, false);\n                    };\n\n                    _$rapyd$_anonfunc.__argnames__ = [\"item\"];\n                    return _$rapyd$_anonfunc;\n                })());\n                toplevel.filename = options.filename;\n                toplevel.submodules = _$rapyd$_list_decorate([]);\n                toplevel.imported_module_ids = imported_module_ids;\n                toplevel.classes = scan_for_classes(toplevel.body);\n                toplevel.import_order = Object.keys(imported_modules).length;\n                toplevel.module_id = module_id;\n                imported_modules[module_id] = toplevel;\n                toplevel.imports = imported_modules;\n                toplevel.baselib = baselib_items;\n                toplevel.scoped_flags = S.scoped_flags.stack[0];\n                importing_modules[module_id] = false;\n                return toplevel;\n            };\n\n            return run_parser;\n        };\n\n        create_parser_ctx.__argnames__ = [\"S\", \"import_dirs\", \"module_id\", \"baselib_items\", \"imported_module_ids\", \"imported_modules\", \"importing_modules\", \"options\"];\n\n        function parse(text, options) {\n            var import_dirs, x, location, module_id, baselib_items, imported_module_ids, imported_modules, importing_modules, S, obj, cname;\n            options = defaults(options, {\n                \"filename\": null,\n                \"auto_bind\": false,\n                \"module_id\": \"__main__\",\n                \"toplevel\": null,\n                \"for_linting\": false,\n                \"import_dirs\": [],\n                \"classes\": undefined,\n                \"scoped_flags\": {}\n            });\n            import_dirs = (function() {\n                var _$rapyd$_Iter = _$rapyd$_Iterable(options.import_dirs), _$rapyd$_Result = [], x;\n                for (var _$rapyd$_Index = 0; _$rapyd$_Index < _$rapyd$_Iter.length; _$rapyd$_Index++) {\n                    x = _$rapyd$_Iter[_$rapyd$_Index];\n                    _$rapyd$_Result.push(x);\n                }\n                _$rapyd$_Result = _$rapyd$_list_constructor(_$rapyd$_Result);\n                return _$rapyd$_Result;\n            })();\n            var _$rapyd$_Iter51 = _$rapyd$_Iterable([options.libdir, options.basedir]);\n            for (var _$rapyd$_Index51 = 0; _$rapyd$_Index51 < _$rapyd$_Iter51.length; _$rapyd$_Index51++) {\n                location = _$rapyd$_Iter51[_$rapyd$_Index51];\n                if (location) {\n                    import_dirs.push(location);\n                }\n            }\n            module_id = options.module_id;\n            baselib_items = {};\n            imported_module_ids = _$rapyd$_list_decorate([]);\n            imported_modules = options.imported_modules || {};\n            importing_modules = options.importing_modules || {};\n            importing_modules[module_id] = true;\n            S = {\n                \"input\": (typeof text === \"string\") ? tokenizer(text, options.filename) : text,\n                \"token\": null,\n                \"prev\": null,\n                \"peeked\": _$rapyd$_list_decorate([]),\n                \"in_function\": 0,\n                \"statement_starting_token\": null,\n                \"in_comprehension\": false,\n                \"in_parenthesized_expr\": false,\n                \"in_loop\": 0,\n                \"in_class\": _$rapyd$_list_decorate([ false ]),\n                \"classes\": _$rapyd$_list_decorate([ {} ]),\n                \"functions\": _$rapyd$_list_decorate([ {} ]),\n                \"labels\": _$rapyd$_list_decorate([]),\n                \"decorators\": [],\n                \"parsing_decorator\": false,\n                \"scoped_flags\": {\n                    \"stack\": [options.scoped_flags || {}],\n                    \"push\": (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            this.stack.push({});\n                        };\n                        return _$rapyd$_anonfunc;\n                    })(),\n                    \"pop\": (function() {\n                        var _$rapyd$_anonfunc = function () {\n                            this.stack.pop();\n                        };\n                        return _$rapyd$_anonfunc;\n                    })(),\n                    \"get\": (function() {\n                        var _$rapyd$_anonfunc = function (name, defval) {\n                            var d;\n                            for (var i = this.stack.length - 1; i >= 0; i--) {\n                                d = this.stack[i];\n                                if (has_prop.call(d, name)) {\n                                    return d[name];\n                                }\n                            }\n                            return defval;\n                        };\n\n                        _$rapyd$_anonfunc.__argnames__ = [\"name\", \"defval\"];\n                        return _$rapyd$_anonfunc;\n                    })(),\n                    \"set\": (function() {\n                        var _$rapyd$_anonfunc = function (name, val) {\n                            this.stack[this.stack.length-1][name] = val;\n                        };\n\n                        _$rapyd$_anonfunc.__argnames__ = [\"name\", \"val\"];\n                        return _$rapyd$_anonfunc;\n                    })()\n                }\n            };\n            if (options.classes) {\n                var _$rapyd$_Iter52 = _$rapyd$_Iterable(options.classes);\n                for (var _$rapyd$_Index52 = 0; _$rapyd$_Index52 < _$rapyd$_Iter52.length; _$rapyd$_Index52++) {\n                    cname = _$rapyd$_Iter52[_$rapyd$_Index52];\n                    obj = options.classes[cname];\n                    S.classes[0][cname] = {\n                        \"static\": obj.static,\n                        \"bound\": obj.bound\n                    };\n                }\n            }\n            return create_parser_ctx(S, import_dirs, module_id, baselib_items, imported_module_ids, imported_modules, importing_modules, options)();\n        };\n\n        parse.__argnames__ = [\"text\", \"options\"];\n\n        _$rapyd$_modules.parse.has_prop = has_prop;\n        _$rapyd$_modules.parse.COMPILER_VERSION = COMPILER_VERSION;\n        _$rapyd$_modules.parse.PYTHON_FLAGS = PYTHON_FLAGS;\n        _$rapyd$_modules.parse.NATIVE_CLASSES = NATIVE_CLASSES;\n        _$rapyd$_modules.parse.ERROR_CLASSES = ERROR_CLASSES;\n        _$rapyd$_modules.parse.COMMON_STATIC = COMMON_STATIC;\n        _$rapyd$_modules.parse.UNARY_PREFIX = UNARY_PREFIX;\n        _$rapyd$_modules.parse.ASSIGNMENT = ASSIGNMENT;\n        _$rapyd$_modules.parse.PRECEDENCE = PRECEDENCE;\n        _$rapyd$_modules.parse.STATEMENTS_WITH_LABELS = STATEMENTS_WITH_LABELS;\n        _$rapyd$_modules.parse.ATOMIC_START_TOKEN = ATOMIC_START_TOKEN;\n        _$rapyd$_modules.parse.compile_time_decorators = compile_time_decorators;\n        _$rapyd$_modules.parse.has_simple_decorator = has_simple_decorator;\n        _$rapyd$_modules.parse.has_setter_decorator = has_setter_decorator;\n        _$rapyd$_modules.parse.create_parser_ctx = create_parser_ctx;\n        _$rapyd$_modules.parse.parse = parse;\n    })();\n\n    (function(){\n        var __name__ = \"output\";\n\n        _$rapyd$_modules[\"output\"][\"stream\"] = _$rapyd$_modules[\"output.stream\"];\n        _$rapyd$_modules[\"output\"][\"statements\"] = _$rapyd$_modules[\"output.statements\"];\n        _$rapyd$_modules[\"output\"][\"exceptions\"] = _$rapyd$_modules[\"output.exceptions\"];\n        _$rapyd$_modules[\"output\"][\"functions\"] = _$rapyd$_modules[\"output.functions\"];\n        _$rapyd$_modules[\"output\"][\"classes\"] = _$rapyd$_modules[\"output.classes\"];\n        _$rapyd$_modules[\"output\"][\"literals\"] = _$rapyd$_modules[\"output.literals\"];\n        _$rapyd$_modules[\"output\"][\"loops\"] = _$rapyd$_modules[\"output.loops\"];\n        _$rapyd$_modules[\"output\"][\"modules\"] = _$rapyd$_modules[\"output.modules\"];\n        _$rapyd$_modules[\"output\"][\"operators\"] = _$rapyd$_modules[\"output.operators\"];\n        _$rapyd$_modules[\"output\"][\"utils\"] = _$rapyd$_modules[\"output.utils\"];\n        _$rapyd$_modules[\"output\"][\"codegen\"] = _$rapyd$_modules[\"output.codegen\"];\n    })();\n\n    (function(){\n        var __name__ = \"output.stream\";\n        var DANGEROUS, require_semi_colon_chars;\n        var make_predicate = _$rapyd$_modules.utils.make_predicate;\n        var defaults = _$rapyd$_modules.utils.defaults;\n        var repeat_string = _$rapyd$_modules.utils.repeat_string;\n        \n        var is_identifier_char = _$rapyd$_modules.tokenizer.is_identifier_char;\n        \n        DANGEROUS = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n        function to_ascii(str_, identifier) {\n            return str_.replace(/[\\u0080-\\uffff]/g, (function() {\n                var _$rapyd$_anonfunc = function (ch) {\n                    var code;\n                    code = ch.charCodeAt(0).toString(16);\n                    if (code.length <= 2 && !identifier) {\n                        while (code.length < 2) {\n                            code = \"0\" + code;\n                        }\n                        return \"\\\\x\" + code;\n                    } else {\n                        while (code.length < 4) {\n                            code = \"0\" + code;\n                        }\n                        return \"\\\\u\" + code;\n                    }\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"ch\"];\n                return _$rapyd$_anonfunc;\n            })());\n        };\n\n        to_ascii.__argnames__ = [\"str_\", \"identifier\"];\n\n        function encode_string(str_) {\n            return JSON.stringify(str_).replace(DANGEROUS, (function() {\n                var _$rapyd$_anonfunc = function (a) {\n                    return \"\\\\u\" + a.charCodeAt(0).toString(16);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"a\"];\n                return _$rapyd$_anonfunc;\n            })());\n        };\n\n        encode_string.__argnames__ = [\"str_\"];\n\n        require_semi_colon_chars = make_predicate(\"( [ + * / - , .\");\n        function OutputStream() {\n            if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n            OutputStream.prototype.__init__.apply(this, arguments);\n        }\n        OutputStream.prototype.__init__ = function __init__(options) {\n            var self = this;\n            self.options = defaults(options, {\n                \"indent_start\": 0,\n                \"indent_level\": 4,\n                \"quote_keys\": false,\n                \"space_colon\": true,\n                \"ascii_only\": false,\n                \"width\": 80,\n                \"max_line_len\": 32e3,\n                \"ie_proof\": true,\n                \"beautify\": false,\n                \"source_map\": null,\n                \"bracketize\": false,\n                \"semicolons\": true,\n                \"comments\": false,\n                \"preserve_line\": false,\n                \"omit_baselib\": false,\n                \"baselib_plain\": null,\n                \"private_scope\": true,\n                \"auto_bind\": false,\n                \"js_version\": 5,\n                \"write_name\": true\n            }, true);\n            self._indentation = 0;\n            self.current_col = 0;\n            self.current_line = 1;\n            self.current_pos = 0;\n            self.OUTPUT = \"\";\n            self.IMPORTED = {};\n            self.might_need_space = false;\n            self.might_need_semicolon = false;\n            self._last = null;\n            self._stack = _$rapyd$_list_decorate([]);\n            self.index_counter = 0;\n            self.with_counter = 0;\n        };\n\n        OutputStream.prototype.__init__.__argnames__ = [\"options\"];\n        OutputStream.__argnames__ = OutputStream.prototype.__init__.__argnames__;\n        OutputStream.__handles_kwarg_interpolation__ = OutputStream.prototype.__init__.__handles_kwarg_interpolation__;\n        OutputStream.prototype.make_name = function make_name(name) {\n            var self = this;\n            name = name.toString();\n            if (self.options.ascii_only) {\n                name = to_ascii(name, true);\n            }\n            return name;\n        };\n\n        OutputStream.prototype.make_name.__argnames__ = [\"name\"];\n        OutputStream.prototype.print_name = function print_name(name) {\n            var self = this;\n            self.print(self.make_name(name));\n        };\n\n        OutputStream.prototype.print_name.__argnames__ = [\"name\"];\n        OutputStream.prototype.make_indent = function make_indent(back) {\n            var self = this;\n            return repeat_string(\" \", self.options.indent_start + self._indentation - back * self.options.indent_level);\n        };\n\n        OutputStream.prototype.make_indent.__argnames__ = [\"back\"];\n        OutputStream.prototype.last_char = function last_char() {\n            var self = this;\n            return self._last.charAt(self._last.length - 1);\n        };\n\n        OutputStream.prototype.last_char.__argnames__ = [];\n        OutputStream.prototype.maybe_newline = function maybe_newline() {\n            var self = this;\n            if (self.options.max_line_len && self.current_col > self.options.max_line_len) {\n                self.print(\"\\n\");\n            }\n        };\n\n        OutputStream.prototype.maybe_newline.__argnames__ = [];\n        OutputStream.prototype.print = function print(str_) {\n            var self = this;\n            var ch, target_line, prev, a, n;\n            str_ = String(str_);\n            ch = str_.charAt(0);\n            if (self.might_need_semicolon) {\n                if ((!ch || \";}\".indexOf(ch) < 0) && !/[;]$/.test(self._last)) {\n                    if (self.options.semicolons || require_semi_colon_chars(ch)) {\n                        self.OUTPUT += \";\";\n                        self.current_col += 1;\n                        self.current_pos += 1;\n                    } else {\n                        self.OUTPUT += \"\\n\";\n                        self.current_pos += 1;\n                        self.current_line += 1;\n                        self.current_col = 0;\n                    }\n                    if (!self.options.beautify) {\n                        self.might_need_space = false;\n                    }\n                }\n                self.might_need_semicolon = false;\n                self.maybe_newline();\n            }\n            if (!self.options.beautify && self.options.preserve_line && self._stack[self._stack.length - 1]) {\n                target_line = self._stack[self._stack.length - 1].start.line;\n                while (self.current_line < target_line) {\n                    self.OUTPUT += \"\\n\";\n                    self.current_pos += 1;\n                    self.current_line += 1;\n                    self.current_col = 0;\n                    self.might_need_space = false;\n                }\n            }\n            if (self.might_need_space) {\n                prev = self.last_char();\n                if (is_identifier_char(prev) && (is_identifier_char(ch) || ch === \"\\\\\") || /^[\\+\\-\\/]$/.test(ch) && ch === prev) {\n                    self.OUTPUT += \" \";\n                    self.current_col += 1;\n                    self.current_pos += 1;\n                }\n                self.might_need_space = false;\n            }\n            a = str_.split(/\\r?\\n/);\n            n = a.length - 1;\n            self.current_line += n;\n            if (n === 0) {\n                self.current_col += a[n].length;\n            } else {\n                self.current_col = a[n].length;\n            }\n            self.current_pos += str_.length;\n            self._last = str_;\n            self.OUTPUT += str_;\n        };\n\n        OutputStream.prototype.print.__argnames__ = [\"str_\"];\n        OutputStream.prototype.space = function space() {\n            var self = this;\n            if (self.options.beautify) {\n                self.print(\" \");\n            } else {\n                self.might_need_space = true;\n            }\n        };\n\n        OutputStream.prototype.space.__argnames__ = [];\n        OutputStream.prototype.indent = function indent(half) {\n            var self = this;\n            if (self.options.beautify) {\n                self.print(self.make_indent((half) ? .5 : 0));\n            }\n        };\n\n        OutputStream.prototype.indent.__argnames__ = [\"half\"];\n        OutputStream.prototype.with_indent = function with_indent(col, proceed) {\n            var self = this;\n            var save_indentation, ret;\n            if (self.options.beautify) {\n                if (col === true) {\n                    col = self.next_indent();\n                }\n                save_indentation = self._indentation;\n                self._indentation = col;\n                ret = proceed();\n                self._indentation = save_indentation;\n                return ret;\n            } else {\n                return proceed();\n            }\n        };\n\n        OutputStream.prototype.with_indent.__argnames__ = [\"col\", \"proceed\"];\n        OutputStream.prototype.indentation = function indentation() {\n            var self = this;\n            return self._indentation;\n        };\n\n        OutputStream.prototype.indentation.__argnames__ = [];\n        OutputStream.prototype.set_indentation = function set_indentation(val) {\n            var self = this;\n            if (self.options.beautify) {\n                self._indentation = val;\n            }\n        };\n\n        OutputStream.prototype.set_indentation.__argnames__ = [\"val\"];\n        OutputStream.prototype.newline = function newline() {\n            var self = this;\n            if (self.options.beautify) {\n                self.print(\"\\n\");\n            }\n        };\n\n        OutputStream.prototype.newline.__argnames__ = [];\n        OutputStream.prototype.semicolon = function semicolon() {\n            var self = this;\n            if (self.options.beautify) {\n                self.print(\";\");\n            } else {\n                self.might_need_semicolon = true;\n            }\n        };\n\n        OutputStream.prototype.semicolon.__argnames__ = [];\n        OutputStream.prototype.force_semicolon = function force_semicolon() {\n            var self = this;\n            self.might_need_semicolon = false;\n            self.print(\";\");\n        };\n\n        OutputStream.prototype.force_semicolon.__argnames__ = [];\n        OutputStream.prototype.next_indent = function next_indent() {\n            var self = this;\n            return self._indentation + self.options.indent_level;\n        };\n\n        OutputStream.prototype.next_indent.__argnames__ = [];\n        OutputStream.prototype.spaced = function spaced() {\n            var self = this;\n            for (var i=0; i < arguments.length; i++) {\n                if (i > 0) {\n                    self.space();\n                }\n                if (typeof arguments[i].print === \"function\") {\n                    arguments[i].print(self);\n                } else {\n                    self.print(arguments[i]);\n                }\n            }\n        };\n\n        OutputStream.prototype.spaced.__argnames__ = [];\n        OutputStream.prototype.end_statement = function end_statement() {\n            var self = this;\n            self.semicolon();\n            self.newline();\n        };\n\n        OutputStream.prototype.end_statement.__argnames__ = [];\n        OutputStream.prototype.with_block = function with_block(cont) {\n            var self = this;\n            var ret;\n            ret = null;\n            self.print(\"{\");\n            self.newline();\n            self.with_indent(self.next_indent(), (function() {\n                var _$rapyd$_anonfunc = function () {\n                    ret = cont();\n                };\n                return _$rapyd$_anonfunc;\n            })());\n            self.indent();\n            self.print(\"}\");\n            return ret;\n        };\n\n        OutputStream.prototype.with_block.__argnames__ = [\"cont\"];\n        OutputStream.prototype.with_parens = function with_parens(cont) {\n            var self = this;\n            var ret;\n            self.print(\"(\");\n            ret = cont();\n            self.print(\")\");\n            return ret;\n        };\n\n        OutputStream.prototype.with_parens.__argnames__ = [\"cont\"];\n        OutputStream.prototype.with_square = function with_square(cont) {\n            var self = this;\n            var ret;\n            self.print(\"[\");\n            ret = cont();\n            self.print(\"]\");\n            return ret;\n        };\n\n        OutputStream.prototype.with_square.__argnames__ = [\"cont\"];\n        OutputStream.prototype.comma = function comma() {\n            var self = this;\n            self.print(\",\");\n            self.space();\n        };\n\n        OutputStream.prototype.comma.__argnames__ = [];\n        OutputStream.prototype.colon = function colon() {\n            var self = this;\n            self.print(\":\");\n            if (self.options.space_colon) {\n                self.space();\n            }\n        };\n\n        OutputStream.prototype.colon.__argnames__ = [];\n        OutputStream.prototype.dump_yield = function dump_yield() {\n            var self = this;\n            var code, ci;\n            self.indent();\n            self.spaced(\"var\", \"_$rapyd$_regenerator\", \"=\", \"{}\");\n            self.end_statement();\n            code = regenerate(false, self.options.beautify);\n            if (self.options.beautify) {\n                code = code.replace(/\\/\\/.*$/gm, \"\\n\").replace(/^\\s*$/gm, \"\");\n                ci = self.make_indent(0);\n                code = (function() {\n                    var _$rapyd$_Iter = _$rapyd$_Iterable(code.split(\"\\n\")), _$rapyd$_Result = [], x;\n                    for (var _$rapyd$_Index = 0; _$rapyd$_Index < _$rapyd$_Iter.length; _$rapyd$_Index++) {\n                        x = _$rapyd$_Iter[_$rapyd$_Index];\n                        _$rapyd$_Result.push(ci + x);\n                    }\n                    _$rapyd$_Result = _$rapyd$_list_constructor(_$rapyd$_Result);\n                    return _$rapyd$_Result;\n                })().join(\"\\n\");\n            }\n            self.print(code + \"(_$rapyd$_regenerator)\");\n            self.end_statement();\n        };\n\n        OutputStream.prototype.dump_yield.__argnames__ = [];\n        OutputStream.prototype.get = function get() {\n            var self = this;\n            return self.OUTPUT;\n        };\n\n        OutputStream.prototype.get.__argnames__ = [];\n        OutputStream.prototype.toString = function toString() {\n            var self = this;\n            return self.OUTPUT;\n        };\n\n        OutputStream.prototype.toString.__argnames__ = [];\n        OutputStream.prototype.assign = function assign(name) {\n            var self = this;\n            if (typeof name === \"string\") {\n                self.print(name);\n            } else {\n                name.print(self);\n            }\n            self.space();\n            self.print(\"=\");\n            self.space();\n        };\n\n        OutputStream.prototype.assign.__argnames__ = [\"name\"];\n        OutputStream.prototype.current_width = function current_width() {\n            var self = this;\n            return self.current_col - self._indentation;\n        };\n\n        OutputStream.prototype.current_width.__argnames__ = [];\n        OutputStream.prototype.should_break = function should_break() {\n            var self = this;\n            return self.options.width && self.current_width() >= self.options.width;\n        };\n\n        OutputStream.prototype.should_break.__argnames__ = [];\n        OutputStream.prototype.last = function last() {\n            var self = this;\n            return self._last;\n        };\n\n        OutputStream.prototype.last.__argnames__ = [];\n        OutputStream.prototype.print_string = function print_string(str_) {\n            var self = this;\n            self.print(encode_string(str_));\n        };\n\n        OutputStream.prototype.print_string.__argnames__ = [\"str_\"];\n        OutputStream.prototype.import_ = function import_(module) {\n            var self = this;\n            if (!Object.prototype.hasOwnProperty.call(self.IMPORTED, module.key)) {\n                self.IMPORTED[module.key] = module;\n            }\n        };\n\n        OutputStream.prototype.import_.__argnames__ = [\"module\"];\n        OutputStream.prototype.is_main = function is_main() {\n            var self = this;\n            return self.OUTPUT.length === 0;\n        };\n\n        OutputStream.prototype.is_main.__argnames__ = [];\n        OutputStream.prototype.option = function option(opt) {\n            var self = this;\n            return self.options[opt];\n        };\n\n        OutputStream.prototype.option.__argnames__ = [\"opt\"];\n        OutputStream.prototype.line = function line() {\n            var self = this;\n            return self.current_line;\n        };\n\n        OutputStream.prototype.line.__argnames__ = [];\n        OutputStream.prototype.col = function col() {\n            var self = this;\n            return self.current_col;\n        };\n\n        OutputStream.prototype.col.__argnames__ = [];\n        OutputStream.prototype.pos = function pos() {\n            var self = this;\n            return self.current_pos;\n        };\n\n        OutputStream.prototype.pos.__argnames__ = [];\n        OutputStream.prototype.push_node = function push_node(node) {\n            var self = this;\n            self._stack.push(node);\n        };\n\n        OutputStream.prototype.push_node.__argnames__ = [\"node\"];\n        OutputStream.prototype.pop_node = function pop_node() {\n            var self = this;\n            return self._stack.pop();\n        };\n\n        OutputStream.prototype.pop_node.__argnames__ = [];\n        OutputStream.prototype.stack = function stack() {\n            var self = this;\n            return self._stack;\n        };\n\n        OutputStream.prototype.stack.__argnames__ = [];\n        OutputStream.prototype.parent = function parent(n) {\n            var self = this;\n            return self._stack[self._stack.length - 2 - (n || 0)];\n        };\n\n        OutputStream.prototype.parent.__argnames__ = [\"n\"];\n        OutputStream.prototype.__repr__ = function __repr__ () {\n            return \"<\" + __name__ + \".\" + \"OutputStream\" + \" #\" + this._$rapyd$_object_id + \">\";\n        };\n        OutputStream.prototype.__str__ = function __str__ () {\n            return this.__repr__();\n        };\n\n        _$rapyd$_modules[\"output.stream\"].DANGEROUS = DANGEROUS;\n        _$rapyd$_modules[\"output.stream\"].require_semi_colon_chars = require_semi_colon_chars;\n        _$rapyd$_modules[\"output.stream\"].to_ascii = to_ascii;\n        _$rapyd$_modules[\"output.stream\"].encode_string = encode_string;\n        _$rapyd$_modules[\"output.stream\"].OutputStream = OutputStream;\n    })();\n\n    (function(){\n        var __name__ = \"output.statements\";\n        var AST_Definitions = _$rapyd$_modules.ast.AST_Definitions;\n        var AST_Scope = _$rapyd$_modules.ast.AST_Scope;\n        var AST_Method = _$rapyd$_modules.ast.AST_Method;\n        var AST_Except = _$rapyd$_modules.ast.AST_Except;\n        var AST_EmptyStatement = _$rapyd$_modules.ast.AST_EmptyStatement;\n        var AST_Statement = _$rapyd$_modules.ast.AST_Statement;\n        var AST_Seq = _$rapyd$_modules.ast.AST_Seq;\n        var AST_BaseCall = _$rapyd$_modules.ast.AST_BaseCall;\n        var AST_Dot = _$rapyd$_modules.ast.AST_Dot;\n        var AST_Sub = _$rapyd$_modules.ast.AST_Sub;\n        var AST_ItemAccess = _$rapyd$_modules.ast.AST_ItemAccess;\n        var AST_Conditional = _$rapyd$_modules.ast.AST_Conditional;\n        var AST_Binary = _$rapyd$_modules.ast.AST_Binary;\n        var AST_UnaryPostfix = _$rapyd$_modules.ast.AST_UnaryPostfix;\n        var AST_BlockStatement = _$rapyd$_modules.ast.AST_BlockStatement;\n        \n        function force_statement(stat, output) {\n            if (output.option(\"bracketize\")) {\n                if (!stat || stat instanceof AST_EmptyStatement) {\n                    output.print(\"{}\");\n                } else if (stat instanceof AST_BlockStatement) {\n                    stat.print(output);\n                } else {\n                    output.with_block((function() {\n                        var _$rapyd$_anonfunc = function () {\n                            output.indent();\n                            stat.print(output);\n                            output.newline();\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                }\n            } else {\n                if (!stat || stat instanceof AST_EmptyStatement) {\n                    output.force_semicolon();\n                } else {\n                    stat.print(output);\n                }\n            }\n        };\n\n        force_statement.__argnames__ = [\"stat\", \"output\"];\n\n        function first_in_statement(output) {\n            var a, i, node, p;\n            a = output.stack();\n            i = a.length;\n            node = a[i -= 1];\n            p = a[i -= 1];\n            while (i > 0) {\n                if (p instanceof AST_Statement && p.body === node) {\n                    return true;\n                }\n                if (p instanceof AST_Seq && p.car === node || p instanceof AST_BaseCall && p.expression === node || p instanceof AST_Dot && p.expression === node || p instanceof AST_Sub && p.expression === node || p instanceof AST_ItemAccess && p.expression === node || p instanceof AST_Conditional && p.condition === node || p instanceof AST_Binary && p.left === node || p instanceof AST_UnaryPostfix && p.expression === node) {\n                    node = p;\n                    p = a[i -= 1];\n                } else {\n                    return false;\n                }\n            }\n        };\n\n        first_in_statement.__argnames__ = [\"output\"];\n\n        function bind_methods(methods, output) {\n            var arg;\n            if (methods) {\n                var _$rapyd$_Iter53 = _$rapyd$_Iterable(methods);\n                for (var _$rapyd$_Index53 = 0; _$rapyd$_Index53 < _$rapyd$_Iter53.length; _$rapyd$_Index53++) {\n                    arg = _$rapyd$_Iter53[_$rapyd$_Index53];\n                    output.indent();\n                    output.print(\"this.\");\n                    output.assign(arg);\n                    output.print(\"_$rapyd$_bind\");\n                    output.with_parens((function() {\n                        var _$rapyd$_anonfunc = function () {\n                            output.print(\"this.\");\n                            output.print(arg);\n                            output.comma();\n                            output.print(\"this\");\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                    output.semicolon();\n                    output.newline();\n                }\n            }\n        };\n\n        bind_methods.__argnames__ = [\"methods\", \"output\"];\n\n        function declare_vars(vars, output) {\n            if (vars.length) {\n                output.indent();\n                output.print(\"var\");\n                output.space();\n                vars.forEach((function() {\n                    var _$rapyd$_anonfunc = function (arg, i) {\n                        if (i) {\n                            output.comma();\n                        }\n                        arg.print(output);\n                    };\n\n                    _$rapyd$_anonfunc.__argnames__ = [\"arg\", \"i\"];\n                    return _$rapyd$_anonfunc;\n                })());\n                output.semicolon();\n                output.newline();\n            }\n        };\n\n        declare_vars.__argnames__ = [\"vars\", \"output\"];\n\n        function display_body(body, is_toplevel, output) {\n            var last;\n            last = body.length - 1;\n            body.forEach((function() {\n                var _$rapyd$_anonfunc = function (stmt, i) {\n                    if (!(stmt instanceof AST_EmptyStatement) && !(stmt instanceof AST_Definitions)) {\n                        output.indent();\n                        stmt.print(output);\n                        if (!(i === last && is_toplevel)) {\n                            output.newline();\n                        }\n                    }\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"stmt\", \"i\"];\n                return _$rapyd$_anonfunc;\n            })());\n        };\n\n        display_body.__argnames__ = [\"body\", \"is_toplevel\", \"output\"];\n\n        function display_complex_body(node, is_toplevel, output, function_preamble) {\n            var offset;\n            offset = 0;\n            if (node instanceof AST_Method && !node.static) {\n                output.indent();\n                output.print(\"var\");\n                output.space();\n                output.assign(node.argnames[0]);\n                output.print(\"this\");\n                output.semicolon();\n                output.newline();\n                offset += 1;\n            }\n            if (node instanceof AST_Scope) {\n                function_preamble(node, output, offset);\n                if (output.option(\"auto_bind\") && node instanceof AST_Method && node.name && node.name.name === \"__init__\") {\n                    output.indent();\n                    output.print(\"_$rapyd$_rebind_all\");\n                    output.with_parens((function() {\n                        var _$rapyd$_anonfunc = function () {\n                            output.print(\"this\");\n                            output.comma();\n                            output.print(\"true\");\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                    output.semicolon();\n                    output.newline();\n                    bind_methods(node.bound, output);\n                }\n                declare_vars(node.localvars, output);\n            } else if (node instanceof AST_Except) {\n                if (node.argname) {\n                    output.indent();\n                    output.print(\"var\");\n                    output.space();\n                    output.assign(node.argname);\n                    output.print(\"_$rapyd$_Exception\");\n                    output.semicolon();\n                    output.newline();\n                }\n            }\n            display_body(node.body, is_toplevel, output);\n        };\n\n        display_complex_body.__argnames__ = [\"node\", \"is_toplevel\", \"output\", \"function_preamble\"];\n\n        function print_bracketed(node, output, complex, function_preamble) {\n            if (node.body.length > 0) {\n                output.with_block((function() {\n                    var _$rapyd$_anonfunc = function () {\n                        if (complex) {\n                            display_complex_body(node, false, output, function_preamble);\n                        } else {\n                            display_body(node.body, false, output, function_preamble);\n                        }\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n            } else {\n                output.print(\"{}\");\n            }\n        };\n\n        print_bracketed.__argnames__ = [\"node\", \"output\", \"complex\", \"function_preamble\"];\n\n        function print_with(self, output) {\n            var exits, clause_name, clause;\n            exits = [];\n            [output.assign(\"_$rapyd$_with_exception\"), output.print(\"undefined\"), output.end_statement()];\n            var _$rapyd$_Iter54 = _$rapyd$_Iterable(self.clauses);\n            for (var _$rapyd$_Index54 = 0; _$rapyd$_Index54 < _$rapyd$_Iter54.length; _$rapyd$_Index54++) {\n                clause = _$rapyd$_Iter54[_$rapyd$_Index54];\n                output.with_counter += 1;\n                clause_name = \"_$rapyd$_with_clause_\" + output.with_counter;\n                exits.push(clause_name);\n                [output.indent(), output.print(\"var \"), output.assign(clause_name)];\n                clause.expression.print(output);\n                output.end_statement();\n                output.indent();\n                if (clause.alias) {\n                    output.assign(clause.alias.name);\n                }\n                output.print(clause_name + \".__enter__()\");\n                output.end_statement();\n            }\n            [output.indent(), output.print(\"try\"), output.space()];\n            output.with_block((function() {\n                var _$rapyd$_anonfunc = function () {\n                    output.indent();\n                    self._do_print_body(output);\n                    output.newline();\n                };\n                return _$rapyd$_anonfunc;\n            })());\n            [output.space(), output.print(\"catch(e)\")];\n            output.with_block((function() {\n                var _$rapyd$_anonfunc = function () {\n                    [output.indent(), output.assign(\"_$rapyd$_with_exception\"), output.print(\"e\"), output.end_statement()];\n                };\n                return _$rapyd$_anonfunc;\n            })());\n            [output.newline(), output.indent(), output.spaced(\"if\", \"(_$rapyd$_with_exception\", \"===\", \"undefined)\")];\n            output.with_block((function() {\n                var _$rapyd$_anonfunc = function () {\n                    var clause;\n                    var _$rapyd$_Iter55 = _$rapyd$_Iterable(exits);\n                    for (var _$rapyd$_Index55 = 0; _$rapyd$_Index55 < _$rapyd$_Iter55.length; _$rapyd$_Index55++) {\n                        clause = _$rapyd$_Iter55[_$rapyd$_Index55];\n                        [output.indent(), output.print(clause + \".__exit__()\"), output.end_statement()];\n                    }\n                };\n                return _$rapyd$_anonfunc;\n            })());\n            [output.space(), output.print(\"else\"), output.space()];\n            output.with_block((function() {\n                var _$rapyd$_anonfunc = function () {\n                    var clause;\n                    [output.indent(), output.assign(\"_$rapyd$_with_suppress\"), output.print(\"false\"), \n                    output.end_statement()];\n                    var _$rapyd$_Iter56 = _$rapyd$_Iterable(exits);\n                    for (var _$rapyd$_Index56 = 0; _$rapyd$_Index56 < _$rapyd$_Iter56.length; _$rapyd$_Index56++) {\n                        clause = _$rapyd$_Iter56[_$rapyd$_Index56];\n                        output.indent();\n                        output.spaced(\"_$rapyd$_with_suppress\", \"|=\", \"_$rapyd$_bool(\" + clause + \".__exit__(_$rapyd$_with_exception.constructor,\", \"_$rapyd$_with_exception,\", \"_$rapyd$_with_exception.stack))\");\n                        output.end_statement();\n                    }\n                    [output.indent(), output.spaced(\"if\", \"(!_$rapyd$_with_suppress)\", \"throw _$rapyd$_with_exception\"), \n                    output.end_statement()];\n                };\n                return _$rapyd$_anonfunc;\n            })());\n        };\n\n        print_with.__argnames__ = [\"self\", \"output\"];\n\n        _$rapyd$_modules[\"output.statements\"].force_statement = force_statement;\n        _$rapyd$_modules[\"output.statements\"].first_in_statement = first_in_statement;\n        _$rapyd$_modules[\"output.statements\"].bind_methods = bind_methods;\n        _$rapyd$_modules[\"output.statements\"].declare_vars = declare_vars;\n        _$rapyd$_modules[\"output.statements\"].display_body = display_body;\n        _$rapyd$_modules[\"output.statements\"].display_complex_body = display_complex_body;\n        _$rapyd$_modules[\"output.statements\"].print_bracketed = print_bracketed;\n        _$rapyd$_modules[\"output.statements\"].print_with = print_with;\n    })();\n\n    (function(){\n        var __name__ = \"output.exceptions\";\n        var print_bracketed = _$rapyd$_modules[\"output.statements\"].print_bracketed;\n        \n        function print_try(self, output) {\n            output.print(\"try\");\n            output.space();\n            print_bracketed(self, output);\n            if (self.bcatch) {\n                output.space();\n                self.bcatch.print(output);\n            }\n            if (self.bfinally) {\n                output.space();\n                self.bfinally.print(output);\n            }\n        };\n\n        print_try.__argnames__ = [\"self\", \"output\"];\n\n        function print_catch(self, output) {\n            output.print(\"catch\");\n            output.space();\n            output.with_parens((function() {\n                var _$rapyd$_anonfunc = function () {\n                    output.print(\"_$rapyd$_Exception\");\n                };\n                return _$rapyd$_anonfunc;\n            })());\n            output.space();\n            if (self.body.length > 1 || self.body[0].errors.length) {\n                output.with_block((function() {\n                    var _$rapyd$_anonfunc = function () {\n                        var no_default;\n                        output.indent();\n                        no_default = true;\n                        self.body.forEach((function() {\n                            var _$rapyd$_anonfunc = function (exception, i) {\n                                if (i) {\n                                    output.print(\"else \");\n                                }\n                                if (exception.errors.length) {\n                                    output.print(\"if\");\n                                    output.space();\n                                    output.with_parens((function() {\n                                        var _$rapyd$_anonfunc = function () {\n                                            exception.errors.forEach((function() {\n                                                var _$rapyd$_anonfunc = function (err, i) {\n                                                    if (i) {\n                                                        output.newline();\n                                                        output.indent();\n                                                        output.print(\"||\");\n                                                        output.space();\n                                                    }\n                                                    output.print(\"_$rapyd$_Exception\");\n                                                    output.space();\n                                                    output.print(\"instanceof\");\n                                                    output.space();\n                                                    err.print(output);\n                                                };\n\n                                                _$rapyd$_anonfunc.__argnames__ = [\"err\", \"i\"];\n                                                return _$rapyd$_anonfunc;\n                                            })());\n                                        };\n                                        return _$rapyd$_anonfunc;\n                                    })());\n                                    output.space();\n                                } else {\n                                    no_default = false;\n                                }\n                                print_bracketed(exception, output, true);\n                                output.space();\n                            };\n\n                            _$rapyd$_anonfunc.__argnames__ = [\"exception\", \"i\"];\n                            return _$rapyd$_anonfunc;\n                        })());\n                        if (no_default) {\n                            output.print(\"else\");\n                            output.space();\n                            output.with_block((function() {\n                                var _$rapyd$_anonfunc = function () {\n                                    output.indent();\n                                    output.print(\"throw\");\n                                    output.space();\n                                    output.print(\"_$rapyd$_Exception\");\n                                    output.semicolon();\n                                    output.newline();\n                                };\n                                return _$rapyd$_anonfunc;\n                            })());\n                        }\n                        output.newline();\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n            } else {\n                print_bracketed(self.body[0], output, true);\n            }\n        };\n\n        print_catch.__argnames__ = [\"self\", \"output\"];\n\n        function print_finally(self, output) {\n            output.print(\"finally\");\n            output.space();\n            print_bracketed(self, output);\n        };\n\n        print_finally.__argnames__ = [\"self\", \"output\"];\n\n        _$rapyd$_modules[\"output.exceptions\"].print_try = print_try;\n        _$rapyd$_modules[\"output.exceptions\"].print_catch = print_catch;\n        _$rapyd$_modules[\"output.exceptions\"].print_finally = print_finally;\n    })();\n\n    (function(){\n        var __name__ = \"output.functions\";\n        var anonfunc;\n        var AST_ClassCall = _$rapyd$_modules.ast.AST_ClassCall;\n        var AST_New = _$rapyd$_modules.ast.AST_New;\n        var has_calls = _$rapyd$_modules.ast.has_calls;\n        var AST_Dot = _$rapyd$_modules.ast.AST_Dot;\n        var AST_SymbolRef = _$rapyd$_modules.ast.AST_SymbolRef;\n        \n        var OutputStream = _$rapyd$_modules[\"output.stream\"].OutputStream;\n        \n        var print_bracketed = _$rapyd$_modules[\"output.statements\"].print_bracketed;\n        \n        anonfunc = \"_$rapyd$_anonfunc\";\n        function decorate(decorators, output, func) {\n            var pos;\n            pos = 0;\n            function wrap() {\n                if (pos < decorators.length) {\n                    decorators[pos].expression.print(output);\n                    pos += 1;\n                    output.with_parens((function() {\n                        var _$rapyd$_anonfunc = function () {\n                            wrap();\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                } else {\n                    func();\n                }\n            };\n\n            wrap();\n        };\n\n        decorate.__argnames__ = [\"decorators\", \"output\", \"func\"];\n\n        function function_args(argnames, output, strip_first) {\n            output.with_parens((function() {\n                var _$rapyd$_anonfunc = function () {\n                    if (argnames && argnames.length && (argnames.is_simple_func === true || argnames.is_simple_func === undefined)) {\n                        ((strip_first) ? argnames.slice(1) : argnames).forEach((function() {\n                            var _$rapyd$_anonfunc = function (arg, i) {\n                                if (i) {\n                                    output.comma();\n                                }\n                                arg.print(output);\n                            };\n\n                            _$rapyd$_anonfunc.__argnames__ = [\"arg\", \"i\"];\n                            return _$rapyd$_anonfunc;\n                        })());\n                    }\n                };\n                return _$rapyd$_anonfunc;\n            })());\n            output.space();\n        };\n\n        function_args.__argnames__ = [\"argnames\", \"output\", \"strip_first\"];\n\n        function function_preamble(node, output, offset) {\n            var a, fname, kw, i, _$rapyd$_unpack, c, arg, dname, nargs;\n            a = node.argnames;\n            if (!a || a.is_simple_func) {\n                return;\n            }\n            fname = (node.name) ? node.name.name : anonfunc;\n            kw = \"arguments[arguments.length-1]\";\n            var _$rapyd$_Iter57 = _$rapyd$_Iterable(enumerate(a));\n            for (var _$rapyd$_Index57 = 0; _$rapyd$_Index57 < _$rapyd$_Iter57.length; _$rapyd$_Index57++) {\n                _$rapyd$_unpack = _$rapyd$_Iter57[_$rapyd$_Index57];\n                c = _$rapyd$_unpack[0];\n                arg = _$rapyd$_unpack[1];\n                i = c - offset;\n                if (i >= 0) {\n                    output.indent();\n                    output.print(\"var\");\n                    output.space();\n                    output.assign(arg);\n                    if (Object.prototype.hasOwnProperty.call(a.defaults, arg.name)) {\n                        output.spaced(\"(arguments[\" + i + \"]\", \"===\", \"undefined\", \"||\", \"(\", i, \"===\", \"arguments.length-1\", \"&&\", kw, \"!==\", \"null\", \"&&\", \"typeof\", kw, \"===\", \"\\\"object\\\"\", \"&&\", kw, \"[_$rapyd$_kwargs_symbol]\", \"===\", \"true))\", \"?\", \"\");\n                        [output.print(fname + \".__defaults__.\"), arg.print(output)];\n                        [output.space(), output.print(\":\"), output.space()];\n                    } else {\n                        output.spaced(\"(\", i, \"===\", \"arguments.length-1\", \"&&\", kw, \"!==\", \"null\", \"&&\", \"typeof\", kw, \"===\", \"\\\"object\\\"\", \"&&\", kw, \"[_$rapyd$_kwargs_symbol]\", \"===\", \"true)\", \"?\", \"undefined\", \":\", \"\");\n                    }\n                    output.print(\"arguments[\" + i + \"]\");\n                    output.end_statement();\n                }\n            }\n            if (a.kwargs || a.has_defaults) {\n                kw = (a.kwargs) ? a.kwargs.name : \"_$rapyd$_kwargs_obj\";\n                output.indent();\n                output.spaced(\"var\", kw, \"=\", \"arguments[arguments.length-1]\");\n                output.end_statement();\n                output.indent();\n                output.spaced(\"if\", \"(\" + kw, \"===\", \"null\", \"||\", \"typeof\", kw, \"!==\", \"\\\"object\\\"\", \"||\", kw, \"[_$rapyd$_kwargs_symbol]\", \"!==\", \"true)\", kw, \"=\", \"{}\");\n                output.end_statement();\n                if (a.has_defaults) {\n                    var _$rapyd$_Iter58 = _$rapyd$_Iterable(Object.keys(a.defaults));\n                    for (var _$rapyd$_Index58 = 0; _$rapyd$_Index58 < _$rapyd$_Iter58.length; _$rapyd$_Index58++) {\n                        dname = _$rapyd$_Iter58[_$rapyd$_Index58];\n                        output.indent();\n                        output.spaced(\"if\", \"(Object.prototype.hasOwnProperty.call(\" + kw + \",\", \"\\\"\" + dname + \"\\\"))\");\n                        output.with_block((function() {\n                            var _$rapyd$_anonfunc = function () {\n                                output.indent();\n                                output.spaced(dname, \"=\", kw + \".\" + dname);\n                                output.end_statement();\n                                if (a.kwargs) {\n                                    output.indent();\n                                    output.spaced(\"delete\", kw + \".\" + dname);\n                                    output.end_statement();\n                                }\n                            };\n                            return _$rapyd$_anonfunc;\n                        })());\n                        output.newline();\n                    }\n                }\n            }\n            if (a.starargs !== undefined) {\n                nargs = a.length - offset;\n                output.indent();\n                output.spaced(\"var\", a.starargs.name, \"=\", \"Array.prototype.slice.call(arguments,\", nargs + \")\");\n                output.end_statement();\n                output.indent();\n                output.spaced(\"if\", \"(\" + kw, \"!==\", \"null\", \"&&\", \"typeof\", kw, \"===\", \"\\\"object\\\"\", \"&&\", kw, \"[_$rapyd$_kwargs_symbol]\", \"===\", \"true)\", a.starargs.name);\n                output.print(\".pop()\");\n                output.end_statement();\n            }\n        };\n\n        function_preamble.__argnames__ = [\"node\", \"output\", \"offset\"];\n\n        function has_annotations(self) {\n            var arg;\n            if (self.return_annotation) {\n                return true;\n            }\n            var _$rapyd$_Iter59 = _$rapyd$_Iterable(self.argnames);\n            for (var _$rapyd$_Index59 = 0; _$rapyd$_Index59 < _$rapyd$_Iter59.length; _$rapyd$_Index59++) {\n                arg = _$rapyd$_Iter59[_$rapyd$_Index59];\n                if (arg.annotation) {\n                    return true;\n                }\n            }\n            return false;\n        };\n\n        has_annotations.__argnames__ = [\"self\"];\n\n        function function_annotation(self, output, strip_first, name) {\n            var fname, defaults, dkeys;\n            fname = name || ((self.name) ? self.name.name : anonfunc);\n            if (has_annotations(self)) {\n                output.end_statement();\n                output.indent();\n                output.assign(fname + \".__annotations__\");\n                output.with_block((function() {\n                    var _$rapyd$_anonfunc = function () {\n                        output.indent();\n                        if (self.argnames && self.argnames.length) {\n                            self.argnames.forEach((function() {\n                                var _$rapyd$_anonfunc = function (arg, i) {\n                                    if (arg.annotation) {\n                                        arg.print(output);\n                                        [output.print(\":\"), output.space()];\n                                        arg.annotation.print(output);\n                                        if (i < self.argnames.length - 1 || self.return_annotation) {\n                                            output.comma();\n                                        }\n                                        output.newline();\n                                        output.indent();\n                                    }\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"arg\", \"i\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                        }\n                        if (self.return_annotation) {\n                            [output.print(\"return:\"), output.space()];\n                            self.return_annotation.print(output);\n                            output.newline();\n                        }\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n                output.end_statement();\n            }\n            defaults = self.argnames.defaults;\n            dkeys = Object.keys(self.argnames.defaults);\n            if (dkeys.length) {\n                [output.newline(), output.indent()];\n                output.assign(fname + \".__defaults__\");\n                output.with_block((function() {\n                    var _$rapyd$_anonfunc = function () {\n                        dkeys.forEach((function() {\n                            var _$rapyd$_anonfunc = function (k, i) {\n                                output.indent();\n                                [output.print(k + \":\"), defaults[k].print(output)];\n                                if (i !== dkeys.length - 1) {\n                                    [output.print(\",\"), output.space()];\n                                }\n                                output.newline();\n                            };\n\n                            _$rapyd$_anonfunc.__argnames__ = [\"k\", \"i\"];\n                            return _$rapyd$_anonfunc;\n                        })());\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n                output.end_statement();\n            }\n            if (!self.argnames.is_simple_func) {\n                [output.newline(), output.indent()];\n                output.assign(fname + \".__handles_kwarg_interpolation__\");\n                output.print(\"true\");\n                output.end_statement();\n            }\n            if (self.argnames.length) {\n                [output.newline(), output.indent()];\n                output.assign(fname + \".__argnames__\");\n                [output.print(\"[\"), self.argnames.forEach((function() {\n                    var _$rapyd$_anonfunc = function (arg, i) {\n                        if (strip_first && i === 0) {\n                            return;\n                        }\n                        output.print(JSON.stringify(arg.name));\n                        if (i !== self.argnames.length - 1) {\n                            [output.print(\",\"), output.space()];\n                        }\n                    };\n\n                    _$rapyd$_anonfunc.__argnames__ = [\"arg\", \"i\"];\n                    return _$rapyd$_anonfunc;\n                })())];\n                output.print(\"]\");\n                output.end_statement();\n            }\n        };\n\n        function_annotation.__argnames__ = [\"self\", \"output\", \"strip_first\", \"name\"];\n\n        function function_definition(self, output, strip_first, as_expression) {\n            var orig_indent;\n            as_expression = as_expression || self.is_expression || self.is_anonymous;\n            if (as_expression) {\n                orig_indent = output.indentation();\n                output.set_indentation(output.next_indent());\n                [output.spaced(\"(function()\", \"{\"), output.newline()];\n                [output.indent(), output.spaced(\"var\", anonfunc, \"=\"), output.space()];\n            }\n            [output.print(\"function\"), output.space()];\n            if (self.name) {\n                self.name.print(output);\n            }\n            if (self.is_generator) {\n                [output.print(\"()\"), output.space()];\n                output.with_block((function() {\n                    var _$rapyd$_anonfunc = function () {\n                        var temp, transpiled, ci;\n                        if (output.options.js_version >= 6) {\n                            output.indent();\n                            output.print(\"function* js_generator\");\n                            function_args(self.argnames, output, strip_first);\n                            print_bracketed(self, output, true, function_preamble);\n                        } else {\n                            temp = new OutputStream({\n                                \"beautify\": true\n                            });\n                            temp.print(\"function* js_generator\");\n                            function_args(self.argnames, temp, strip_first);\n                            print_bracketed(self, temp, true, function_preamble);\n                            transpiled = regenerate(temp.get(), output.options.beautify).replace(/regeneratorRuntime.(wrap|mark)/g, \"_$rapyd$_regenerator.regeneratorRuntime.$1\");\n                            if (output.options.beautify) {\n                                ci = output.make_indent(0);\n                                transpiled = (function() {\n                                    var _$rapyd$_Iter = _$rapyd$_Iterable(transpiled.split(\"\\n\")), _$rapyd$_Result = [], x;\n                                    for (var _$rapyd$_Index = 0; _$rapyd$_Index < _$rapyd$_Iter.length; _$rapyd$_Index++) {\n                                        x = _$rapyd$_Iter[_$rapyd$_Index];\n                                        _$rapyd$_Result.push(ci + x);\n                                    }\n                                    _$rapyd$_Result = _$rapyd$_list_constructor(_$rapyd$_Result);\n                                    return _$rapyd$_Result;\n                                })().join(\"\\n\");\n                            }\n                            output.print(transpiled);\n                        }\n                        output.newline();\n                        output.indent();\n                        output.spaced(\"var\", \"result\", \"=\", \"js_generator.apply(this,\", \"arguments)\");\n                        output.end_statement();\n                        output.indent();\n                        output.spaced(\"result.send\", \"=\", \"result.next\");\n                        output.end_statement();\n                        output.indent();\n                        output.spaced(\"return\", \"result\");\n                        output.end_statement();\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n            } else {\n                function_args(self.argnames, output, strip_first);\n                print_bracketed(self, output, true, function_preamble);\n            }\n            if (as_expression) {\n                output.end_statement();\n                function_annotation(self, output, strip_first, anonfunc);\n                [output.indent(), output.spaced(\"return\", anonfunc), output.end_statement()];\n                output.set_indentation(orig_indent);\n                [output.indent(), output.print(\"})()\")];\n            }\n        };\n\n        function_definition.__argnames__ = [\"self\", \"output\", \"strip_first\", \"as_expression\"];\n\n        function print_function(output) {\n            var self;\n            self = this;\n            if (self.decorators && self.decorators.length) {\n                output.print(\"var\");\n                output.space();\n                output.assign(self.name.name);\n                decorate(self.decorators, output, (function() {\n                    var _$rapyd$_anonfunc = function () {\n                        function_definition(self, output, false, true);\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n                output.end_statement();\n            } else {\n                function_definition(self, output, false);\n                if (!self.is_expression && !self.is_anonymous) {\n                    output.end_statement();\n                    function_annotation(self, output, false);\n                }\n            }\n        };\n\n        print_function.__argnames__ = [\"output\"];\n\n        function find_this(expression) {\n            if (expression instanceof AST_Dot) {\n                return expression.expression;\n            }\n            if (!(expression instanceof AST_SymbolRef)) {\n                return expression;\n            }\n        };\n\n        find_this.__argnames__ = [\"expression\"];\n\n        function print_this(expression, output) {\n            var obj;\n            obj = find_this(expression);\n            if (obj) {\n                obj.print(output);\n            } else {\n                output.print(\"this\");\n            }\n        };\n\n        print_this.__argnames__ = [\"expression\", \"output\"];\n\n        function print_function_call(self, output) {\n            var has_kwarg_items, has_kwarg_formals, has_kwargs, is_new, is_repeatable;\n            function print_function_name() {\n                if (self instanceof AST_ClassCall) {\n                    if (self.static) {\n                        self.class.print(output);\n                        output.print(\".\");\n                        output.print(self.method);\n                    } else {\n                        self.class.print(output);\n                        output.print(\".prototype.\");\n                        output.print(self.method);\n                        output.print(\".call\");\n                    }\n                } else {\n                    if (!is_repeatable) {\n                        output.print(\"_$rapyd$_expr_temp\");\n                        if (self.expression instanceof AST_Dot) {\n                            self.expression._codegen(self.expression, output, true);\n                        }\n                    } else {\n                        self.expression.print(output);\n                    }\n                }\n            };\n\n            function print_kwargs() {\n                output.print(\"_$rapyd$_desugar_kwargs(\");\n                if (has_kwarg_items) {\n                    self.args.kwarg_items.forEach((function() {\n                        var _$rapyd$_anonfunc = function (kwname, i) {\n                            if (i > 0) {\n                                output.print(\",\");\n                                output.space();\n                            }\n                            kwname.print(output);\n                        };\n\n                        _$rapyd$_anonfunc.__argnames__ = [\"kwname\", \"i\"];\n                        return _$rapyd$_anonfunc;\n                    })());\n                    if (has_kwarg_formals) {\n                        output.print(\",\");\n                        output.space();\n                    }\n                }\n                if (has_kwarg_formals) {\n                    output.print(\"{\");\n                    self.args.kwargs.forEach((function() {\n                        var _$rapyd$_anonfunc = function (pair, i) {\n                            if (i) {\n                                output.comma();\n                            }\n                            pair[0].print(output);\n                            output.print(\":\");\n                            output.space();\n                            pair[1].print(output);\n                        };\n\n                        _$rapyd$_anonfunc.__argnames__ = [\"pair\", \"i\"];\n                        return _$rapyd$_anonfunc;\n                    })());\n                    output.print(\"}\");\n                }\n                output.print(\")\");\n            };\n\n            function print_new(apply) {\n                output.print(\"_$rapyd$_interpolate_kwargs_constructor.call(\");\n                [output.print(\"Object.create(\"), self.expression.print(output), output.print(\")\")];\n                output.comma();\n                output.print((apply) ? \"true\" : \"false\");\n                output.comma();\n            };\n\n            print_new.__argnames__ = [\"apply\"];\n\n            function do_print_this() {\n                if (!is_repeatable) {\n                    output.print(\"_$rapyd$_expr_temp\");\n                } else {\n                    print_this(self.expression, output);\n                }\n                output.comma();\n            };\n\n            function print_positional_args() {\n                var i, expr, is_first;\n                i = 0;\n                while (i < self.args.length) {\n                    expr = self.args[i];\n                    is_first = i === 0;\n                    if (!is_first) {\n                        output.print(\".concat(\");\n                    }\n                    if (expr.is_array) {\n                        expr.print(output);\n                        i += 1;\n                    } else {\n                        output.print(\"[\");\n                        while (i < self.args.length && !self.args[i].is_array) {\n                            self.args[i].print(output);\n                            if (i + 1 < self.args.length && !self.args[i + 1].is_array) {\n                                output.print(\",\");\n                                output.space();\n                            }\n                            i += 1;\n                        }\n                        output.print(\"]\");\n                    }\n                    if (!is_first) {\n                        output.print(\")\");\n                    }\n                }\n            };\n\n            has_kwarg_items = self.args.kwarg_items && self.args.kwarg_items.length;\n            has_kwarg_formals = self.args.kwargs && self.args.kwargs.length;\n            has_kwargs = has_kwarg_items || has_kwarg_formals;\n            is_new = self instanceof AST_New;\n            is_repeatable = true;\n            if (is_new && !self.args.length && !has_kwargs && !self.args.starargs) {\n                [output.print(\"new\"), output.space()];\n                print_function_name();\n                return;\n            }\n            if (!has_kwargs && !self.args.starargs) {\n                if (is_new) {\n                    [output.print(\"new\"), output.space()];\n                }\n                print_function_name();\n                output.with_parens((function() {\n                    var _$rapyd$_anonfunc = function () {\n                        self.args.forEach((function() {\n                            var _$rapyd$_anonfunc = function (a, i) {\n                                if (i) {\n                                    output.comma();\n                                }\n                                a.print(output);\n                            };\n\n                            _$rapyd$_anonfunc.__argnames__ = [\"a\", \"i\"];\n                            return _$rapyd$_anonfunc;\n                        })());\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n                return;\n            }\n            is_repeatable = is_new || !has_calls(self.expression);\n            if (!is_repeatable) {\n                [output.assign(\"(_$rapyd$_expr_temp\"), print_this(self.expression, output), output.comma()];\n            }\n            if (has_kwargs) {\n                if (is_new) {\n                    print_new(false);\n                } else {\n                    output.print(\"_$rapyd$_interpolate_kwargs.call(\");\n                    do_print_this();\n                }\n                print_function_name();\n                output.comma();\n            } else {\n                if (is_new) {\n                    print_new(true);\n                    print_function_name();\n                    output.comma();\n                } else {\n                    print_function_name();\n                    output.print(\".apply(\");\n                    do_print_this();\n                }\n            }\n            print_positional_args();\n            if (has_kwargs) {\n                if (self.args.length) {\n                    output.print(\".concat(\");\n                }\n                output.print(\"[\");\n                print_kwargs();\n                output.print(\"]\");\n                if (self.args.length) {\n                    output.print(\")\");\n                }\n            }\n            output.print(\")\");\n            if (!is_repeatable) {\n                output.print(\")\");\n            }\n        };\n\n        print_function_call.__argnames__ = [\"self\", \"output\"];\n\n        _$rapyd$_modules[\"output.functions\"].anonfunc = anonfunc;\n        _$rapyd$_modules[\"output.functions\"].decorate = decorate;\n        _$rapyd$_modules[\"output.functions\"].function_args = function_args;\n        _$rapyd$_modules[\"output.functions\"].function_preamble = function_preamble;\n        _$rapyd$_modules[\"output.functions\"].has_annotations = has_annotations;\n        _$rapyd$_modules[\"output.functions\"].function_annotation = function_annotation;\n        _$rapyd$_modules[\"output.functions\"].function_definition = function_definition;\n        _$rapyd$_modules[\"output.functions\"].print_function = print_function;\n        _$rapyd$_modules[\"output.functions\"].find_this = find_this;\n        _$rapyd$_modules[\"output.functions\"].print_this = print_this;\n        _$rapyd$_modules[\"output.functions\"].print_function_call = print_function_call;\n    })();\n\n    (function(){\n        var __name__ = \"output.classes\";\n        var AST_Class = _$rapyd$_modules.ast.AST_Class;\n        var AST_Method = _$rapyd$_modules.ast.AST_Method;\n        \n        var decorate = _$rapyd$_modules[\"output.functions\"].decorate;\n        var function_definition = _$rapyd$_modules[\"output.functions\"].function_definition;\n        var function_annotation = _$rapyd$_modules[\"output.functions\"].function_annotation;\n        \n        var bind_methods = _$rapyd$_modules[\"output.statements\"].bind_methods;\n        \n        function print_class(output) {\n            var self, class_def, define_method, property_names, defined_methods;\n            self = this;\n            if (self.external) {\n                return;\n            }\n            class_def = (function() {\n                var _$rapyd$_anonfunc = function (method, is_var) {\n                    output.indent();\n                    self.name.print(output);\n                    if (!is_var && method && self.static.indexOf(method) !== -1) {\n                        output.assign(\".\" + method);\n                    } else {\n                        if (is_var) {\n                            output.assign(\".prototype[\" + method + \"]\");\n                        } else {\n                            output.assign(\".prototype\" + ((method) ? \".\" + method : \"\"));\n                        }\n                    }\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"method\", \"is_var\"];\n                return _$rapyd$_anonfunc;\n            })();\n            define_method = (function() {\n                var _$rapyd$_anonfunc = function (stmt, is_property) {\n                    var name, strip_first;\n                    name = stmt.name.name;\n                    if (!is_property) {\n                        class_def(name);\n                    }\n                    strip_first = self.static.indexOf(name) === -1;\n                    if (stmt.decorators && stmt.decorators.length) {\n                        decorate(stmt.decorators, output, (function() {\n                            var _$rapyd$_anonfunc = function () {\n                                function_definition(stmt, output, strip_first, true);\n                            };\n                            return _$rapyd$_anonfunc;\n                        })());\n                        output.end_statement();\n                    } else {\n                        function_definition(stmt, output, strip_first);\n                        if (!is_property) {\n                            output.end_statement();\n                            function_annotation(stmt, output, strip_first, self.name.name + \".prototype.\" + name);\n                        }\n                    }\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"stmt\", \"is_property\"];\n                return _$rapyd$_anonfunc;\n            })();\n            function define_default_method(name, body) {\n                class_def(name);\n                output.spaced(\"function\", name, \"()\", \"\");\n                output.with_block((function() {\n                    var _$rapyd$_anonfunc = function () {\n                        [output.indent(), body()];\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n                output.end_statement();\n            };\n\n            define_default_method.__argnames__ = [\"name\", \"body\"];\n\n            function write_constructor() {\n                output.print(\"function\");\n                output.space();\n                self.name.print(output);\n                output.print(\"()\");\n                output.space();\n                output.with_block((function() {\n                    var _$rapyd$_anonfunc = function () {\n                        bind_methods(self.bound, output);\n                        output.indent();\n                        output.spaced(\"if\", \"(this._$rapyd$_object_id\", \"===\", \"undefined)\", \"Object.defineProperty(this,\", \"\\\"_$rapyd$_object_id\\\",\", \"{\\\"value\\\":++_$rapyd$_object_counter})\");\n                        output.end_statement();\n                        output.indent();\n                        self.name.print(output);\n                        output.print(\".prototype.__init__.apply\");\n                        output.with_parens((function() {\n                            var _$rapyd$_anonfunc = function () {\n                                output.print(\"this\");\n                                output.comma();\n                                output.print(\"arguments\");\n                            };\n                            return _$rapyd$_anonfunc;\n                        })());\n                        output.end_statement();\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n            };\n\n            if (self.decorators && self.decorators.length) {\n                output.print(\"var \");\n                output.assign(self.name);\n                decorate(self.decorators, output, write_constructor);\n                output.semicolon();\n            } else {\n                write_constructor();\n            }\n            output.newline();\n            if (self.parent) {\n                output.indent();\n                output.print(\"_$rapyd$_extends\");\n                output.with_parens((function() {\n                    var _$rapyd$_anonfunc = function () {\n                        self.name.print(output);\n                        output.comma();\n                        self.parent.print(output);\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n                output.semicolon();\n                output.newline();\n            }\n            property_names = Object.keys(self.dynamic_properties);\n            if (property_names.length) {\n                output.indent();\n                output.print(\"Object.defineProperties\");\n                output.with_parens((function() {\n                    var _$rapyd$_anonfunc = function () {\n                        [self.name.print(output), output.print(\".prototype\"), output.comma(), output.space(), \n                        output.with_block((function() {\n                            var _$rapyd$_anonfunc = function () {\n                                var prop, name;\n                                var _$rapyd$_Iter60 = _$rapyd$_Iterable(property_names);\n                                for (var _$rapyd$_Index60 = 0; _$rapyd$_Index60 < _$rapyd$_Iter60.length; _$rapyd$_Index60++) {\n                                    name = _$rapyd$_Iter60[_$rapyd$_Index60];\n                                    prop = self.dynamic_properties[name];\n                                    [output.indent(), output.print(JSON.stringify(name) + \":\"), output.space()];\n                                    output.with_block((function() {\n                                        var _$rapyd$_anonfunc = function () {\n                                            [output.indent(), output.print(\"\\\"enumerable\\\":\"), output.space(), output.print(\"true\"), \n                                            output.comma(), output.newline()];\n                                            if (prop.getter) {\n                                                [output.indent(), output.print(\"\\\"get\\\":\"), output.space()];\n                                                [define_method(prop.getter, true), output.comma(), output.newline()];\n                                            }\n                                            [output.indent(), output.print(\"\\\"set\\\":\"), output.space()];\n                                            if (prop.setter) {\n                                                [define_method(prop.setter, true), output.newline()];\n                                            } else {\n                                                [output.spaced(\"function\", \"()\", \"{\", \"throw new AttributeError(\\\"can't set attribute\\\")\", \"}\"), \n                                                output.newline()];\n                                            }\n                                        };\n                                        return _$rapyd$_anonfunc;\n                                    })());\n                                    [output.comma(), output.newline()];\n                                }\n                            };\n                            return _$rapyd$_anonfunc;\n                        })())];\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n                output.end_statement();\n            }\n            if (!self.init) {\n                define_default_method(\"__init__\", (function() {\n                    var _$rapyd$_anonfunc = function () {\n                        if (self.parent) {\n                            self.parent.print(output);\n                            output.spaced(\".prototype.__init__\", \"&&\");\n                            [output.space(), self.parent.print(output)];\n                            output.print(\".prototype.__init__.apply\");\n                            output.with_parens((function() {\n                                var _$rapyd$_anonfunc = function () {\n                                    output.print(\"this\");\n                                    output.comma();\n                                    output.print(\"arguments\");\n                                };\n                                return _$rapyd$_anonfunc;\n                            })());\n                            output.end_statement();\n                        }\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n            }\n            defined_methods = {};\n            self.body.forEach((function() {\n                var _$rapyd$_anonfunc = function (stmt, i) {\n                    var sname, attr;\n                    if (stmt instanceof AST_Method) {\n                        if (stmt.is_getter || stmt.is_setter) {\n                            return;\n                        }\n                        define_method(stmt);\n                        defined_methods[stmt.name.name] = true;\n                        sname = stmt.name.name;\n                        if (sname === \"__init__\") {\n                            var _$rapyd$_Iter61 = _$rapyd$_Iterable(_$rapyd$_list_decorate([ \".__argnames__\", \".__handles_kwarg_interpolation__\" ]));\n                            for (var _$rapyd$_Index61 = 0; _$rapyd$_Index61 < _$rapyd$_Iter61.length; _$rapyd$_Index61++) {\n                                attr = _$rapyd$_Iter61[_$rapyd$_Index61];\n                                [output.indent(), self.name.print(output), output.assign(attr)];\n                                [self.name.print(output), output.print(\".prototype.__init__\" + attr), output.end_statement()];\n                            }\n                        }\n                        if (sname === \"__iter__\") {\n                            class_def(\"_$rapyd$_iterator_symbol\", true);\n                            self.name.print(output);\n                            output.print(\".prototype.\" + stmt.name.name);\n                            output.end_statement();\n                        }\n                    } else if (stmt instanceof AST_Class) {\n                        console.error(\"Nested classes aren't supported yet\");\n                    }\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"stmt\", \"i\"];\n                return _$rapyd$_anonfunc;\n            })());\n            if (!defined_methods[\"__repr__\"]) {\n                define_default_method(\"__repr__\", (function() {\n                    var _$rapyd$_anonfunc = function () {\n                        output.spaced(\"return\", \"\\\"<\\\"\", \"+\", \"__name__\", \"+\", \"\\\".\\\"\", \"+\", \"\\\"\");\n                        self.name.print(output);\n                        output.spaced(\"\\\"\", \"+\", \"\\\" #\\\"\", \"+\", \"this._$rapyd$_object_id\", \"+\", \"\\\">\\\"\");\n                        output.end_statement();\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n            }\n            if (!defined_methods[\"__str__\"]) {\n                define_default_method(\"__str__\", (function() {\n                    var _$rapyd$_anonfunc = function () {\n                        output.spaced(\"return\", \"this.__repr__()\");\n                        output.end_statement();\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n            }\n            self.statements.forEach((function() {\n                var _$rapyd$_anonfunc = function (stmt) {\n                    if (!(stmt instanceof AST_Method)) {\n                        output.indent();\n                        stmt.print(output);\n                        output.newline();\n                    }\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"stmt\"];\n                return _$rapyd$_anonfunc;\n            })());\n        };\n\n        print_class.__argnames__ = [\"output\"];\n\n        _$rapyd$_modules[\"output.classes\"].print_class = print_class;\n    })();\n\n    (function(){\n        var __name__ = \"output.literals\";\n        var AST_Binary = _$rapyd$_modules.ast.AST_Binary;\n        \n        function print_array(self, output) {\n            output.print(\"_$rapyd$_list_decorate\");\n            output.with_parens((function() {\n                var _$rapyd$_anonfunc = function () {\n                    output.with_square((function() {\n                        var _$rapyd$_anonfunc = function () {\n                            var a, len_;\n                            a = self.elements;\n                            len_ = a.length;\n                            if (len_ > 0) {\n                                output.space();\n                            }\n                            a.forEach((function() {\n                                var _$rapyd$_anonfunc = function (exp, i) {\n                                    if (i) {\n                                        output.comma();\n                                    }\n                                    exp.print(output);\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"exp\", \"i\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                            if (len_ > 0) {\n                                output.space();\n                            }\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n                return _$rapyd$_anonfunc;\n            })());\n        };\n\n        print_array.__argnames__ = [\"self\", \"output\"];\n\n        function print_obj_literal(self, output) {\n            output.with_parens((function() {\n                var _$rapyd$_anonfunc = function () {\n                    output.print(\"function()\");\n                    output.with_block((function() {\n                        var _$rapyd$_anonfunc = function () {\n                            output.indent();\n                            if (self.is_pydict) {\n                                output.spaced.apply(output, \"var _$rapyd$_d = _$rapyd$_dict()\".split(\" \"));\n                            } else {\n                                output.spaced.apply(output, \"var _$rapyd$_d = {}\".split(\" \"));\n                            }\n                            output.end_statement();\n                            self.properties.forEach((function() {\n                                var _$rapyd$_anonfunc = function (prop, i) {\n                                    output.indent();\n                                    if (self.is_pydict) {\n                                        output.print(\"_$rapyd$_d.set\");\n                                        output.with_parens((function() {\n                                            var _$rapyd$_anonfunc = function () {\n                                                prop.key.print(output);\n                                                [output.print(\",\"), output.space()];\n                                                prop.value.print(output);\n                                            };\n                                            return _$rapyd$_anonfunc;\n                                        })());\n                                    } else {\n                                        output.print(\"_$rapyd$_d\");\n                                        output.with_square((function() {\n                                            var _$rapyd$_anonfunc = function () {\n                                                prop.key.print(output);\n                                            };\n                                            return _$rapyd$_anonfunc;\n                                        })());\n                                        [output.space(), output.print(\"=\"), output.space()];\n                                        prop.value.print(output);\n                                    }\n                                    output.end_statement();\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"prop\", \"i\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                            output.indent();\n                            output.spaced(\"return\", \"_$rapyd$_d\");\n                            output.end_statement();\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n                return _$rapyd$_anonfunc;\n            })());\n            output.print(\"()\");\n        };\n\n        print_obj_literal.__argnames__ = [\"self\", \"output\"];\n\n        function print_object(self, output) {\n            if (self.is_pydict) {\n                if (self.properties.length > 0) {\n                    print_obj_literal(self, output);\n                } else {\n                    output.print(\"_$rapyd$_dict()\");\n                }\n            } else {\n                if (self.properties.length > 0) {\n                    output.with_block((function() {\n                        var _$rapyd$_anonfunc = function () {\n                            self.properties.forEach((function() {\n                                var _$rapyd$_anonfunc = function (prop, i) {\n                                    if (i) {\n                                        output.print(\",\");\n                                        output.newline();\n                                    }\n                                    output.indent();\n                                    prop.print(output);\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"prop\", \"i\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                            output.newline();\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                } else {\n                    output.print(\"{}\");\n                }\n            }\n        };\n\n        print_object.__argnames__ = [\"self\", \"output\"];\n\n        function print_set(self, output) {\n            if (self.items.length === 0) {\n                output.print(\"_$rapyd$_set()\");\n                return;\n            }\n            output.with_parens((function() {\n                var _$rapyd$_anonfunc = function () {\n                    output.print(\"function()\");\n                    output.with_block((function() {\n                        var _$rapyd$_anonfunc = function () {\n                            output.indent();\n                            output.spaced.apply(output, \"var s = _$rapyd$_set()\".split(\" \"));\n                            output.end_statement();\n                            self.items.forEach((function() {\n                                var _$rapyd$_anonfunc = function (item, i) {\n                                    output.indent();\n                                    output.print(\"s.jsset.add\");\n                                    output.with_parens((function() {\n                                        var _$rapyd$_anonfunc = function () {\n                                            item.value.print(output);\n                                        };\n                                        return _$rapyd$_anonfunc;\n                                    })());\n                                    output.end_statement();\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"item\", \"i\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                            output.indent();\n                            output.spaced(\"return\", \"s\");\n                            output.end_statement();\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n                return _$rapyd$_anonfunc;\n            })());\n            output.print(\"()\");\n        };\n\n        print_set.__argnames__ = [\"self\", \"output\"];\n\n        function print_regexp(self, output) {\n            var str_, p;\n            str_ = self.getValue().toString();\n            if (output.option(\"ascii_only\")) {\n                str_ = output.to_ascii(str_);\n            }\n            output.print(str_);\n            p = output.parent();\n            if (p instanceof AST_Binary && /^in/.test(p.operator) && p.left === self) {\n                output.print(\" \");\n            }\n        };\n\n        print_regexp.__argnames__ = [\"self\", \"output\"];\n\n        _$rapyd$_modules[\"output.literals\"].print_array = print_array;\n        _$rapyd$_modules[\"output.literals\"].print_obj_literal = print_obj_literal;\n        _$rapyd$_modules[\"output.literals\"].print_object = print_object;\n        _$rapyd$_modules[\"output.literals\"].print_set = print_set;\n        _$rapyd$_modules[\"output.literals\"].print_regexp = print_regexp;\n    })();\n\n    (function(){\n        var __name__ = \"output.loops\";\n        var AST_BaseCall = _$rapyd$_modules.ast.AST_BaseCall;\n        var AST_SymbolRef = _$rapyd$_modules.ast.AST_SymbolRef;\n        var AST_Array = _$rapyd$_modules.ast.AST_Array;\n        var AST_Unary = _$rapyd$_modules.ast.AST_Unary;\n        var AST_Number = _$rapyd$_modules.ast.AST_Number;\n        \n        var OutputStream = _$rapyd$_modules[\"output.stream\"].OutputStream;\n        \n        function unpack_tuple(elems, output, in_statement) {\n            elems.forEach((function() {\n                var _$rapyd$_anonfunc = function (elem, i) {\n                    output.indent();\n                    output.assign(elem);\n                    output.print(\"_$rapyd$_unpack\");\n                    output.with_square((function() {\n                        var _$rapyd$_anonfunc = function () {\n                            output.print(i);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                    if (!in_statement || i < elems.length - 1) {\n                        output.semicolon();\n                        output.newline();\n                    }\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"elem\", \"i\"];\n                return _$rapyd$_anonfunc;\n            })());\n        };\n\n        unpack_tuple.__argnames__ = [\"elems\", \"output\", \"in_statement\"];\n\n        function print_do_loop(self, output) {\n            output.print(\"do\");\n            output.space();\n            self._do_print_body(output);\n            output.space();\n            output.print(\"while\");\n            output.space();\n            output.with_parens((function() {\n                var _$rapyd$_anonfunc = function () {\n                    self.condition.print(output);\n                };\n                return _$rapyd$_anonfunc;\n            })());\n            output.semicolon();\n        };\n\n        print_do_loop.__argnames__ = [\"self\", \"output\"];\n\n        function print_while_loop(self, output) {\n            output.print(\"while\");\n            output.space();\n            output.with_parens((function() {\n                var _$rapyd$_anonfunc = function () {\n                    self.condition.print(output);\n                };\n                return _$rapyd$_anonfunc;\n            })());\n            output.space();\n            self._do_print_body(output);\n        };\n\n        print_while_loop.__argnames__ = [\"self\", \"output\"];\n\n        function is_simple_for_in(self) {\n            if (self.object instanceof AST_BaseCall && self.object.expression instanceof AST_SymbolRef && self.object.expression.name === \"dir\" && self.object.args.length === 1) {\n                return true;\n            }\n            return false;\n        };\n\n        is_simple_for_in.__argnames__ = [\"self\"];\n\n        function is_simple_for(self) {\n            if (self.object instanceof AST_BaseCall && self.object.expression instanceof AST_SymbolRef && self.object.expression.name === \"range\" && !(self.init instanceof AST_Array) && (self.object.args.length < 3 || self.object.args.slice(-1)[0] instanceof AST_Number || self.object.args.slice(-1)[0] instanceof AST_Unary && self.object.args.slice(-1)[0].operator === \"-\" && self.object.args.slice(-1)[0].expression instanceof AST_Number)) {\n                return true;\n            }\n            return false;\n        };\n\n        is_simple_for.__argnames__ = [\"self\"];\n\n        function print_for_loop_body(output) {\n            var self;\n            self = this;\n            output.with_block((function() {\n                var _$rapyd$_anonfunc = function () {\n                    var itervar, flat;\n                    if (!(self.simple_for_index || is_simple_for_in(self))) {\n                        output.indent();\n                        if (output.option(\"js_version\") === 5) {\n                            itervar = \"_$rapyd$_Iter\" + output.index_counter + \"[_$rapyd$_Index\" + output.index_counter + \"]\";\n                        } else {\n                            itervar = \"_$rapyd$_Index\" + output.index_counter;\n                        }\n                        if (self.init instanceof AST_Array) {\n                            flat = self.init.flatten();\n                            output.assign(\"_$rapyd$_unpack\");\n                            if (flat.length > self.init.elements.length) {\n                                output.print(\"_$rapyd$_flatten(\" + itervar + \")\");\n                            } else {\n                                output.print(itervar);\n                            }\n                            output.end_statement();\n                            unpack_tuple(flat, output);\n                        } else {\n                            output.assign(self.init);\n                            output.print(itervar);\n                            output.end_statement();\n                        }\n                        output.index_counter += 1;\n                    }\n                    if (self.simple_for_index) {\n                        output.indent();\n                        output.assign(self.init);\n                        output.print(self.simple_for_index);\n                        output.end_statement();\n                    }\n                    self.body.body.forEach((function() {\n                        var _$rapyd$_anonfunc = function (stmt, i) {\n                            output.indent();\n                            stmt.print(output);\n                            output.newline();\n                        };\n\n                        _$rapyd$_anonfunc.__argnames__ = [\"stmt\", \"i\"];\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n                return _$rapyd$_anonfunc;\n            })());\n        };\n\n        print_for_loop_body.__argnames__ = [\"output\"];\n\n        function init_es6_itervar(output, itervar) {\n            output.indent();\n            output.spaced(itervar, \"=\", \"((typeof\", itervar + \"[Symbol.iterator]\", \"===\", \"\\\"function\\\")\", \"?\", \"(\" + itervar, \"instanceof\", \"Map\", \"?\", itervar + \".keys()\", \":\", itervar + \")\", \":\", \"Object.keys(\" + itervar + \"))\");\n            output.end_statement();\n        };\n\n        init_es6_itervar.__argnames__ = [\"output\", \"itervar\"];\n\n        function print_for_in(self, output) {\n            var increment, args, tmp_, start, end, idx, _$rapyd$_chain_assign_temp, itervar;\n            function write_object() {\n                if (self.object.TYPE === \"Seq\") {\n                    new AST_Array({\n                        \"elements\": self.object.to_array()\n                    }).print(output);\n                } else {\n                    self.object.print(output);\n                }\n            };\n\n            if (is_simple_for(self)) {\n                increment = null;\n                args = self.object.args;\n                tmp_ = args.length;\n                if (tmp_ === 1) {\n                    start = 0;\n                    end = args[0];\n                } else if (tmp_ === 2) {\n                    start = args[0];\n                    end = args[1];\n                } else if (tmp_ === 3) {\n                    start = args[0];\n                    end = args[1];\n                    increment = args[2];\n                }\n                _$rapyd$_chain_assign_temp = \"_$rapyd$_Index\" + output.index_counter;\n                self.simple_for_index = _$rapyd$_chain_assign_temp;\n                idx = _$rapyd$_chain_assign_temp;\n;\n                output.index_counter += 1;\n                output.print(\"for\");\n                output.space();\n                output.with_parens((function() {\n                    var _$rapyd$_anonfunc = function () {\n                        [output.spaced(\"var\", idx, \"=\"), output.space()];\n                        (start.print) ? start.print(output) : output.print(start);\n                        output.semicolon();\n                        output.space();\n                        output.print(idx);\n                        output.space();\n                        (increment instanceof AST_Unary) ? output.print(\">\") : output.print(\"<\");\n                        output.space();\n                        end.print(output);\n                        output.semicolon();\n                        output.space();\n                        output.print(idx);\n                        if (increment && (!(increment instanceof AST_Unary) || increment.expression.value !== \"1\")) {\n                            if (increment instanceof AST_Unary) {\n                                output.print(\"-=\");\n                                increment.expression.print(output);\n                            } else {\n                                output.print(\"+=\");\n                                increment.print(output);\n                            }\n                        } else {\n                            if (increment instanceof AST_Unary) {\n                                output.print(\"--\");\n                            } else {\n                                output.print(\"++\");\n                            }\n                        }\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n            } else if (is_simple_for_in(self)) {\n                output.print(\"for\");\n                output.space();\n                output.with_parens((function() {\n                    var _$rapyd$_anonfunc = function () {\n                        self.init.print(output);\n                        output.space();\n                        output.print(\"in\");\n                        output.space();\n                        self.object.args[0].print(output);\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n            } else {\n                if (output.options.js_version === 5) {\n                    output.assign(\"var _$rapyd$_Iter\" + output.index_counter);\n                    output.print(\"_$rapyd$_Iterable\");\n                    output.with_parens(write_object);\n                    output.semicolon();\n                    output.newline();\n                    output.indent();\n                    output.print(\"for\");\n                    output.space();\n                    output.with_parens((function() {\n                        var _$rapyd$_anonfunc = function () {\n                            output.print(\"var\");\n                            output.space();\n                            output.assign(\"_$rapyd$_Index\" + output.index_counter);\n                            output.print(\"0\");\n                            output.semicolon();\n                            output.space();\n                            output.print(\"_$rapyd$_Index\" + output.index_counter);\n                            output.space();\n                            output.print(\"<\");\n                            output.space();\n                            output.print(\"_$rapyd$_Iter\" + output.index_counter + \".length\");\n                            output.semicolon();\n                            output.space();\n                            output.print(\"_$rapyd$_Index\" + output.index_counter + \"++\");\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                } else {\n                    itervar = \"_$rapyd$_Iter\" + output.index_counter;\n                    output.assign(\"var \" + itervar);\n                    write_object();\n                    output.end_statement();\n                    init_es6_itervar(output, itervar);\n                    output.indent();\n                    output.spaced(\"for\", \"(var\", \"_$rapyd$_Index\" + output.index_counter, \"of\", itervar + \")\");\n                }\n            }\n            output.space();\n            self._do_print_body(output);\n        };\n\n        print_for_in.__argnames__ = [\"self\", \"output\"];\n\n        function print_list_comprehension(self, output) {\n            var result_obj, is_generator, es5, add_to_result, push_func;\n            result_obj = {\n                \"ListComprehension\": \"[]\",\n                \"DictComprehension\": \"{}\",\n                \"SetComprehension\": \"_$rapyd$_set()\"\n            }[self.TYPE];\n            is_generator = self.TYPE === \"GeneratorComprehension\";\n            es5 = output.option(\"js_version\") === 5;\n            if (self.TYPE === \"DictComprehension\") {\n                if (self.is_pydict) {\n                    result_obj = \"_$rapyd$_dict()\";\n                    add_to_result = (function() {\n                        var _$rapyd$_anonfunc = function (output) {\n                            output.indent();\n                            output.print(\"_$rapyd$_Result.set\");\n                            output.with_parens((function() {\n                                var _$rapyd$_anonfunc = function () {\n                                    self.statement.print(output);\n                                    [output.space(), output.print(\",\"), output.space()];\n                                    output.with_parens((function() {\n                                        var _$rapyd$_anonfunc = function () {\n                                            if (self.value_statement.TYPE === \"Seq\") {\n                                                output.with_square((function() {\n                                                    var _$rapyd$_anonfunc = function () {\n                                                        self.value_statement.print(output);\n                                                    };\n                                                    return _$rapyd$_anonfunc;\n                                                })());\n                                            } else {\n                                                self.value_statement.print(output);\n                                            }\n                                        };\n                                        return _$rapyd$_anonfunc;\n                                    })());\n                                };\n                                return _$rapyd$_anonfunc;\n                            })());\n                            output.end_statement();\n                        };\n\n                        _$rapyd$_anonfunc.__argnames__ = [\"output\"];\n                        return _$rapyd$_anonfunc;\n                    })();\n                } else {\n                    add_to_result = (function() {\n                        var _$rapyd$_anonfunc = function (output) {\n                            output.indent();\n                            output.print(\"_$rapyd$_Result\");\n                            output.with_square((function() {\n                                var _$rapyd$_anonfunc = function () {\n                                    self.statement.print(output);\n                                };\n                                return _$rapyd$_anonfunc;\n                            })());\n                            [output.space(), output.print(\"=\"), output.space()];\n                            output.with_parens((function() {\n                                var _$rapyd$_anonfunc = function () {\n                                    if (self.value_statement.TYPE === \"Seq\") {\n                                        output.with_square((function() {\n                                            var _$rapyd$_anonfunc = function () {\n                                                self.value_statement.print(output);\n                                            };\n                                            return _$rapyd$_anonfunc;\n                                        })());\n                                    } else {\n                                        self.value_statement.print(output);\n                                    }\n                                };\n                                return _$rapyd$_anonfunc;\n                            })());\n                            output.end_statement();\n                        };\n\n                        _$rapyd$_anonfunc.__argnames__ = [\"output\"];\n                        return _$rapyd$_anonfunc;\n                    })();\n                }\n            } else {\n                push_func = \"_$rapyd$_Result.\" + ((self.TYPE === \"ListComprehension\") ? \"push\" : \"add\");\n                if (is_generator) {\n                    push_func = \"yield \";\n                }\n                add_to_result = (function() {\n                    var _$rapyd$_anonfunc = function (output) {\n                        output.indent();\n                        output.print(push_func);\n                        output.with_parens((function() {\n                            var _$rapyd$_anonfunc = function () {\n                                if (self.statement.TYPE === \"Seq\") {\n                                    output.with_square((function() {\n                                        var _$rapyd$_anonfunc = function () {\n                                            self.statement.print(output);\n                                        };\n                                        return _$rapyd$_anonfunc;\n                                    })());\n                                } else {\n                                    self.statement.print(output);\n                                }\n                            };\n                            return _$rapyd$_anonfunc;\n                        })());\n                        output.end_statement();\n                    };\n\n                    _$rapyd$_anonfunc.__argnames__ = [\"output\"];\n                    return _$rapyd$_anonfunc;\n                })();\n            }\n            output.with_parens((function() {\n                var _$rapyd$_anonfunc = function () {\n                    output.print(\"function\");\n                    output.print(\"()\");\n                    output.space();\n                    output.with_block((function() {\n                        var _$rapyd$_anonfunc = function () {\n                            var body_out, previous_indentation, transpiled, ci;\n                            body_out = output;\n                            if (is_generator) {\n                                if (es5) {\n                                    body_out = new OutputStream({\n                                        \"beautify\": true\n                                    });\n                                }\n                                body_out.indent();\n                                [body_out.print(\"function* js_generator()\"), body_out.space(), body_out.print(\"{\")];\n                                body_out.newline();\n                                previous_indentation = output.indentation();\n                                output.set_indentation(output.next_indent());\n                            }\n                            body_out.indent();\n                            body_out.assign(\"var _$rapyd$_Iter\");\n                            if (es5) {\n                                body_out.print(\"_$rapyd$_Iterable\");\n                                body_out.with_parens((function() {\n                                    var _$rapyd$_anonfunc = function () {\n                                        self.object.print(body_out);\n                                    };\n                                    return _$rapyd$_anonfunc;\n                                })());\n                            } else {\n                                self.object.print(body_out);\n                            }\n                            if (result_obj) {\n                                body_out.comma();\n                                body_out.assign(\"_$rapyd$_Result\");\n                                body_out.print(result_obj);\n                            }\n                            if (self.init instanceof AST_Array) {\n                                self.init.elements.forEach((function() {\n                                    var _$rapyd$_anonfunc = function (i) {\n                                        body_out.comma();\n                                        i.print(body_out);\n                                    };\n\n                                    _$rapyd$_anonfunc.__argnames__ = [\"i\"];\n                                    return _$rapyd$_anonfunc;\n                                })());\n                            } else {\n                                body_out.comma();\n                                self.init.print(body_out);\n                            }\n                            body_out.end_statement();\n                            if (!es5) {\n                                init_es6_itervar(body_out, \"_$rapyd$_Iter\");\n                            }\n                            body_out.indent();\n                            body_out.print(\"for\");\n                            body_out.space();\n                            body_out.with_parens((function() {\n                                var _$rapyd$_anonfunc = function () {\n                                    if (es5) {\n                                        body_out.print(\"var\");\n                                        body_out.space();\n                                        body_out.assign(\"_$rapyd$_Index\");\n                                        body_out.print(\"0\");\n                                        body_out.semicolon();\n                                        body_out.space();\n                                        body_out.print(\"_$rapyd$_Index\");\n                                        body_out.space();\n                                        body_out.print(\"<\");\n                                        body_out.space();\n                                        body_out.print(\"_$rapyd$_Iter.length\");\n                                        body_out.semicolon();\n                                        body_out.space();\n                                        body_out.print(\"_$rapyd$_Index++\");\n                                    } else {\n                                        body_out.spaced(\"var\", \"_$rapyd$_Index\", \"of\", \"_$rapyd$_Iter\");\n                                    }\n                                };\n                                return _$rapyd$_anonfunc;\n                            })());\n                            body_out.space();\n                            body_out.with_block((function() {\n                                var _$rapyd$_anonfunc = function () {\n                                    var itervar, flat;\n                                    body_out.indent();\n                                    itervar = (es5) ? \"_$rapyd$_Iter[_$rapyd$_Index]\" : \"_$rapyd$_Index\";\n                                    if (self.init instanceof AST_Array) {\n                                        flat = self.init.flatten();\n                                        body_out.assign(\"_$rapyd$_unpack\");\n                                        if (flat.length > self.init.elements.length) {\n                                            body_out.print(\"_$rapyd$_flatten(\" + itervar + \")\");\n                                        } else {\n                                            body_out.print(itervar);\n                                        }\n                                        body_out.end_statement();\n                                        unpack_tuple(flat, body_out);\n                                    } else {\n                                        body_out.assign(self.init);\n                                        body_out.print(itervar);\n                                        body_out.end_statement();\n                                    }\n                                    if (self.condition) {\n                                        body_out.indent();\n                                        body_out.print(\"if\");\n                                        body_out.space();\n                                        body_out.with_parens((function() {\n                                            var _$rapyd$_anonfunc = function () {\n                                                self.condition.print(body_out);\n                                            };\n                                            return _$rapyd$_anonfunc;\n                                        })());\n                                        body_out.space();\n                                        body_out.with_block((function() {\n                                            var _$rapyd$_anonfunc = function () {\n                                                add_to_result(body_out);\n                                            };\n                                            return _$rapyd$_anonfunc;\n                                        })());\n                                        body_out.newline();\n                                    } else {\n                                        add_to_result(body_out);\n                                    }\n                                };\n                                return _$rapyd$_anonfunc;\n                            })());\n                            body_out.newline();\n                            if (self.TYPE === \"ListComprehension\") {\n                                body_out.indent();\n                                body_out.spaced(\"_$rapyd$_Result\", \"=\", \"_$rapyd$_list_constructor(_$rapyd$_Result)\");\n                                body_out.end_statement();\n                            }\n                            if (!is_generator) {\n                                body_out.indent();\n                                body_out.print(\"return _$rapyd$_Result\");\n                                body_out.end_statement();\n                            }\n                            if (is_generator) {\n                                output.set_indentation(previous_indentation);\n                                [body_out.newline(), body_out.indent(), body_out.print(\"}\")];\n                                if (es5) {\n                                    transpiled = regenerate(body_out.get(), output.options.beautify).replace(/regeneratorRuntime.(wrap|mark)/g, \"_$rapyd$_regenerator.regeneratorRuntime.$1\");\n                                    if (output.options.beautify) {\n                                        ci = output.make_indent(0);\n                                        transpiled = (function() {\n                                            var _$rapyd$_Iter = _$rapyd$_Iterable(transpiled.split(\"\\n\")), _$rapyd$_Result = [], x;\n                                            for (var _$rapyd$_Index = 0; _$rapyd$_Index < _$rapyd$_Iter.length; _$rapyd$_Index++) {\n                                                x = _$rapyd$_Iter[_$rapyd$_Index];\n                                                _$rapyd$_Result.push(ci + x);\n                                            }\n                                            _$rapyd$_Result = _$rapyd$_list_constructor(_$rapyd$_Result);\n                                            return _$rapyd$_Result;\n                                        })().join(\"\\n\");\n                                    }\n                                    output.print(transpiled);\n                                }\n                                [output.newline(), output.indent()];\n                                output.spaced(\"var\", \"result\", \"=\", \"js_generator.call(this)\");\n                                output.end_statement();\n                                output.indent();\n                                output.spaced(\"result.send\", \"=\", \"result.next\");\n                                output.end_statement();\n                                output.indent();\n                                output.spaced(\"return\", \"result\");\n                                output.end_statement();\n                            }\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n                return _$rapyd$_anonfunc;\n            })());\n            output.print(\"()\");\n        };\n\n        print_list_comprehension.__argnames__ = [\"self\", \"output\"];\n\n        _$rapyd$_modules[\"output.loops\"].unpack_tuple = unpack_tuple;\n        _$rapyd$_modules[\"output.loops\"].print_do_loop = print_do_loop;\n        _$rapyd$_modules[\"output.loops\"].print_while_loop = print_while_loop;\n        _$rapyd$_modules[\"output.loops\"].is_simple_for_in = is_simple_for_in;\n        _$rapyd$_modules[\"output.loops\"].is_simple_for = is_simple_for;\n        _$rapyd$_modules[\"output.loops\"].print_for_loop_body = print_for_loop_body;\n        _$rapyd$_modules[\"output.loops\"].init_es6_itervar = init_es6_itervar;\n        _$rapyd$_modules[\"output.loops\"].print_for_in = print_for_in;\n        _$rapyd$_modules[\"output.loops\"].print_list_comprehension = print_list_comprehension;\n    })();\n\n    (function(){\n        var __name__ = \"output.modules\";\n        var COMPILER_VERSION = _$rapyd$_modules.parse.COMPILER_VERSION;\n        \n        var declare_vars = _$rapyd$_modules[\"output.statements\"].declare_vars;\n        var display_body = _$rapyd$_modules[\"output.statements\"].display_body;\n        \n        var OutputStream = _$rapyd$_modules[\"output.stream\"].OutputStream;\n        \n        function write_imports(module, output) {\n            var imports, import_id, nonlocalvars, name, module_, module_id;\n            imports = _$rapyd$_list_decorate([]);\n            var _$rapyd$_Iter62 = _$rapyd$_Iterable(Object.keys(module.imports));\n            for (var _$rapyd$_Index62 = 0; _$rapyd$_Index62 < _$rapyd$_Iter62.length; _$rapyd$_Index62++) {\n                import_id = _$rapyd$_Iter62[_$rapyd$_Index62];\n                imports.push(module.imports[import_id]);\n            }\n            imports.sort((function() {\n                var _$rapyd$_anonfunc = function (a, b) {\n                    var _$rapyd$_unpack;\n                    _$rapyd$_unpack = [a.import_order, b.import_order];\n                    a = _$rapyd$_unpack[0];\n                    b = _$rapyd$_unpack[1];\n                    return (a < b) ? -1 : (a > b) ? 1 : 0;\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"a\", \"b\"];\n                return _$rapyd$_anonfunc;\n            })());\n            if (imports.length > 1) {\n                output.indent();\n                output.print(\"var _$rapyd$_modules = {};\");\n                output.newline();\n            }\n            nonlocalvars = {};\n            var _$rapyd$_Iter63 = _$rapyd$_Iterable(imports);\n            for (var _$rapyd$_Index63 = 0; _$rapyd$_Index63 < _$rapyd$_Iter63.length; _$rapyd$_Index63++) {\n                module_ = _$rapyd$_Iter63[_$rapyd$_Index63];\n                var _$rapyd$_Iter64 = _$rapyd$_Iterable(module_.nonlocalvars);\n                for (var _$rapyd$_Index64 = 0; _$rapyd$_Index64 < _$rapyd$_Iter64.length; _$rapyd$_Index64++) {\n                    name = _$rapyd$_Iter64[_$rapyd$_Index64];\n                    nonlocalvars[name] = true;\n                }\n            }\n            nonlocalvars = Object.getOwnPropertyNames(nonlocalvars).join(\", \");\n            if (nonlocalvars.length) {\n                output.indent();\n                output.print(\"var \" + nonlocalvars);\n                output.semicolon();\n                output.newline();\n            }\n            var _$rapyd$_Iter65 = _$rapyd$_Iterable(imports);\n            for (var _$rapyd$_Index65 = 0; _$rapyd$_Index65 < _$rapyd$_Iter65.length; _$rapyd$_Index65++) {\n                module_ = _$rapyd$_Iter65[_$rapyd$_Index65];\n                module_id = module_.module_id;\n                if (module_id !== \"__main__\") {\n                    output.indent();\n                    if (module_id.indexOf(\".\") === -1) {\n                        output.print(\"_$rapyd$_modules.\" + module_id);\n                    } else {\n                        output.print(\"_$rapyd$_modules[\\\"\" + module_id + \"\\\"]\");\n                    }\n                    [output.space(), output.print(\"=\"), output.space(), output.print(\"{}\")];\n                    output.end_statement();\n                }\n            }\n            var _$rapyd$_Iter66 = _$rapyd$_Iterable(imports);\n            for (var _$rapyd$_Index66 = 0; _$rapyd$_Index66 < _$rapyd$_Iter66.length; _$rapyd$_Index66++) {\n                module_ = _$rapyd$_Iter66[_$rapyd$_Index66];\n                if (module_.module_id !== \"__main__\") {\n                    print_module(module_, output);\n                }\n            }\n        };\n\n        write_imports.__argnames__ = [\"module\", \"output\"];\n\n        function write_main_name(output) {\n            if (output.option(\"write_name\")) {\n                output.newline();\n                output.indent();\n                output.print(\"var __name__ = \\\"__main__\\\"\");\n                output.semicolon();\n                output.newline();\n                output.newline();\n            }\n        };\n\n        write_main_name.__argnames__ = [\"output\"];\n\n        function declare_exports(module_id, exports, submodules, output) {\n            var seen, symbol;\n            seen = {};\n            output.newline();\n            var _$rapyd$_Iter67 = _$rapyd$_Iterable(exports);\n            for (var _$rapyd$_Index67 = 0; _$rapyd$_Index67 < _$rapyd$_Iter67.length; _$rapyd$_Index67++) {\n                symbol = _$rapyd$_Iter67[_$rapyd$_Index67];\n                if (!Object.prototype.hasOwnProperty.call(seen, symbol.name)) {\n                    output.indent();\n                    if (module_id.indexOf(\".\") === -1) {\n                        output.print(\"_$rapyd$_modules.\" + module_id + \".\" + symbol.name);\n                    } else {\n                        output.print(\"_$rapyd$_modules[\\\"\" + module_id + \"\\\"].\" + symbol.name);\n                    }\n                    [output.space(), output.print(\"=\"), output.space(), output.print(symbol.name)];\n                    seen[symbol.name] = true;\n                    output.end_statement();\n                }\n            }\n        };\n\n        declare_exports.__argnames__ = [\"module_id\", \"exports\", \"submodules\", \"output\"];\n\n        function declare_submodules(module_id, submodules, output) {\n            var seen, key, sub_module_id;\n            seen = {};\n            var _$rapyd$_Iter68 = _$rapyd$_Iterable(submodules);\n            for (var _$rapyd$_Index68 = 0; _$rapyd$_Index68 < _$rapyd$_Iter68.length; _$rapyd$_Index68++) {\n                sub_module_id = _$rapyd$_Iter68[_$rapyd$_Index68];\n                if (!Object.prototype.hasOwnProperty.call(seen, sub_module_id)) {\n                    seen[sub_module_id] = true;\n                    key = (_$rapyd$_expr_temp = sub_module_id.split(\".\"), _$rapyd$_expr_temp[_$rapyd$_expr_temp.length-1]);\n                    output.indent();\n                    output.spaced(\"_$rapyd$_modules[\\\"\" + module_id + \"\\\"][\\\"\" + key + \"\\\"]\", \"=\", \"_$rapyd$_modules[\\\"\" + sub_module_id + \"\\\"]\");\n                    output.end_statement();\n                }\n            }\n        };\n\n        declare_submodules.__argnames__ = [\"module_id\", \"submodules\", \"output\"];\n\n        function prologue(module, output) {\n            var v, needs_yield;\n            if (output.options.omit_baselib) {\n                return;\n            }\n            output.indent();\n            v = (output.options.js_version > 5) ? \"const\" : \"var\";\n            [output.print(v), output.space()];\n            output.spaced.apply(output, \"_$rapyd$_iterator_symbol = (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") ? Symbol.iterator : \\\"iterator-Symbol-5d0927e5554349048cf0e3762a228256\\\"\".split(\" \"));\n            output.end_statement();\n            [output.indent(), output.print(v), output.space()];\n            output.spaced.apply(output, \"_$rapyd$_kwargs_symbol = (typeof Symbol === \\\"function\\\") ? Symbol(\\\"kwargs-object\\\") : \\\"kwargs-object-Symbol-5d0927e5554349048cf0e3762a228256\\\"\".split(\" \"));\n            output.end_statement();\n            [output.indent(), output.spaced(\"var\", \"_$rapyd$_cond_temp,\", \"_$rapyd$_expr_temp\"), \n            output.end_statement()];\n            [output.indent(), output.spaced(\"var\", \"_$rapyd$_object_counter\", \"=\", \"0\"), output.end_statement()];\n            needs_yield = output.options.js_version < 6 && module.baselib[\"yield\"];\n            if (needs_yield) {\n                output.dump_yield();\n            }\n            if (!output.options.baselib_plain) {\n                throw new ValueError(\"The baselib is missing! Remember to set the baselib_plain field on the options for OutputStream\");\n            }\n            output.print(output.options.baselib_plain);\n            output.end_statement();\n        };\n\n        prologue.__argnames__ = [\"module\", \"output\"];\n\n        function print_top_level(self, output) {\n            var is_main;\n            is_main = output.is_main();\n            if (output.option(\"private_scope\") && is_main) {\n                output.with_parens((function() {\n                    var _$rapyd$_anonfunc = function () {\n                        output.print(\"function()\");\n                        output.with_block((function() {\n                            var _$rapyd$_anonfunc = function () {\n                                output.indent();\n                                output.print(\"\\\"use strict\\\"\");\n                                output.end_statement();\n                                prologue(self, output);\n                                write_imports(self, output);\n                                output.newline();\n                                output.indent();\n                                output.with_parens((function() {\n                                    var _$rapyd$_anonfunc = function () {\n                                        output.print(\"function()\");\n                                        output.with_block((function() {\n                                            var _$rapyd$_anonfunc = function () {\n                                                write_main_name(output);\n                                                output.newline();\n                                                declare_vars(self.localvars, output);\n                                                display_body(self.body, true, output);\n                                                output.newline();\n                                            };\n                                            return _$rapyd$_anonfunc;\n                                        })());\n                                    };\n                                    return _$rapyd$_anonfunc;\n                                })());\n                                output.print(\"();\");\n                                output.newline();\n                            };\n                            return _$rapyd$_anonfunc;\n                        })());\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n                output.print(\"();\");\n                output.print(\"\");\n            } else {\n                if (is_main) {\n                    prologue(self, output);\n                    write_imports(self, output);\n                    write_main_name(output);\n                }\n                declare_vars(self.localvars, output);\n                display_body(self.body, true, output);\n            }\n        };\n\n        print_top_level.__argnames__ = [\"self\", \"output\"];\n\n        function print_module(self, output) {\n            function output_module(output) {\n                declare_vars(self.localvars, output);\n                display_body(self.body, true, output);\n                declare_exports(self.module_id, self.exports, self.submodules, output);\n            };\n\n            output_module.__argnames__ = [\"output\"];\n\n            output.newline();\n            output.indent();\n            output.with_parens((function() {\n                var _$rapyd$_anonfunc = function () {\n                    output.print(\"function()\");\n                    output.with_block((function() {\n                        var _$rapyd$_anonfunc = function () {\n                            var okey, cached, cobj, cname, symdef, co, raw, js_version, auto_bind, beautify;\n                            if (output.option(\"write_name\")) {\n                                output.indent();\n                                output.print(\"var \");\n                                output.assign(\"__name__\");\n                                output.print(\"\\\"\" + self.module_id + \"\\\"\");\n                                output.semicolon();\n                                output.newline();\n                            }\n                            function output_key(beautify, auto_bind, js_version) {\n                                return \"beautify:\" + beautify + \" auto_bind:\" + auto_bind + \" js_version:\" + js_version;\n                            };\n\n                            output_key.__argnames__ = [\"beautify\", \"auto_bind\", \"js_version\"];\n\n                            okey = output_key(output.option(\"beautify\"), output.option(\"auto_bind\"), output.option(\"js_version\"));\n                            if (self.is_cached && _$rapyd$_in(okey, self.outputs)) {\n                                output.print(self.outputs[okey]);\n                                declare_submodules(self.module_id, self.submodules, output);\n                            } else {\n                                output_module(output);\n                                declare_submodules(self.module_id, self.submodules, output);\n                                if (self.srchash && self.filename) {\n                                    cached = {\n                                        \"version\": COMPILER_VERSION,\n                                        \"signature\": self.srchash,\n                                        \"classes\": {},\n                                        \"baselib\": self.baselib,\n                                        \"nonlocalvars\": self.nonlocalvars,\n                                        \"imported_module_ids\": self.imported_module_ids,\n                                        \"exports\": _$rapyd$_list_decorate([]),\n                                        \"outputs\": {}\n                                    };\n                                    var _$rapyd$_Iter69 = _$rapyd$_Iterable(Object.keys(self.classes));\n                                    for (var _$rapyd$_Index69 = 0; _$rapyd$_Index69 < _$rapyd$_Iter69.length; _$rapyd$_Index69++) {\n                                        cname = _$rapyd$_Iter69[_$rapyd$_Index69];\n                                        cobj = self.classes[cname];\n                                        cached.classes[cname] = {\n                                            \"name\": {\n                                                \"name\": cobj.name.name\n                                            },\n                                            \"static\": cobj.static,\n                                            \"bound\": cobj.bound\n                                        };\n                                    }\n                                    var _$rapyd$_Iter70 = _$rapyd$_Iterable(self.exports);\n                                    for (var _$rapyd$_Index70 = 0; _$rapyd$_Index70 < _$rapyd$_Iter70.length; _$rapyd$_Index70++) {\n                                        symdef = _$rapyd$_Iter70[_$rapyd$_Index70];\n                                        cached.exports.push({\n                                            \"name\": symdef.name\n                                        });\n                                    }\n                                    var _$rapyd$_Iter71 = _$rapyd$_Iterable(_$rapyd$_list_decorate([ true, false ]));\n                                    for (var _$rapyd$_Index71 = 0; _$rapyd$_Index71 < _$rapyd$_Iter71.length; _$rapyd$_Index71++) {\n                                        beautify = _$rapyd$_Iter71[_$rapyd$_Index71];\n                                        var _$rapyd$_Iter72 = _$rapyd$_Iterable(_$rapyd$_list_decorate([ true, false ]));\n                                        for (var _$rapyd$_Index72 = 0; _$rapyd$_Index72 < _$rapyd$_Iter72.length; _$rapyd$_Index72++) {\n                                            auto_bind = _$rapyd$_Iter72[_$rapyd$_Index72];\n                                            var _$rapyd$_Iter73 = _$rapyd$_Iterable(_$rapyd$_list_decorate([ 5, 6 ]));\n                                            for (var _$rapyd$_Index73 = 0; _$rapyd$_Index73 < _$rapyd$_Iter73.length; _$rapyd$_Index73++) {\n                                                js_version = _$rapyd$_Iter73[_$rapyd$_Index73];\n                                                co = new OutputStream({\n                                                    \"beautify\": beautify,\n                                                    \"auto_bind\": auto_bind,\n                                                    \"js_version\": js_version,\n                                                    \"private_scope\": false,\n                                                    \"write_name\": false\n                                                });\n                                                co.with_indent(output.indentation(), (function() {\n                                                    var _$rapyd$_anonfunc = function () {\n                                                        output_module(co);\n                                                    };\n                                                    return _$rapyd$_anonfunc;\n                                                })());\n                                                raw = co.toString();\n                                                cached.outputs[output_key(beautify, auto_bind, js_version)] = raw;\n                                            }\n                                        }\n                                    }\n                                    try {\n                                        writefile(self.filename + \"-cached\", JSON.stringify(cached, null, \"\\t\"));\n                                    } catch (_$rapyd$_Exception) {\n                                        if (_$rapyd$_Exception instanceof Error) {\n                                            var e = _$rapyd$_Exception;\n                                            console.error(\"Failed to write output cache file:\", self.filename + \"-cached\", \"with error:\", e);\n                                        } else {\n                                            throw _$rapyd$_Exception;\n                                        }\n                                    }\n                                }\n                            }\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n                return _$rapyd$_anonfunc;\n            })());\n            output.print(\"()\");\n            output.semicolon();\n            output.newline();\n        };\n\n        print_module.__argnames__ = [\"self\", \"output\"];\n\n        function print_imports(container, output) {\n            var akey, argname, bound_name, self;\n            function add_aname(aname, key, from_import) {\n                output.print(\"var \");\n                output.assign(aname);\n                if (key.indexOf(\".\") === -1) {\n                    [output.print(\"_$rapyd$_modules.\"), output.print(key)];\n                } else {\n                    [output.print(\"_$rapyd$_modules[\\\"\"), output.print(key), output.print(\"\\\"]\")];\n                }\n                if (from_import) {\n                    output.print(\".\");\n                    output.print(from_import);\n                }\n                output.semicolon();\n                output.newline();\n                output.indent();\n            };\n\n            add_aname.__argnames__ = [\"aname\", \"key\", \"from_import\"];\n\n            var _$rapyd$_Iter74 = _$rapyd$_Iterable(container.imports);\n            for (var _$rapyd$_Index74 = 0; _$rapyd$_Index74 < _$rapyd$_Iter74.length; _$rapyd$_Index74++) {\n                self = _$rapyd$_Iter74[_$rapyd$_Index74];\n                output.import_(self.module);\n                if (self.argnames) {\n                    var _$rapyd$_Iter75 = _$rapyd$_Iterable(self.argnames);\n                    for (var _$rapyd$_Index75 = 0; _$rapyd$_Index75 < _$rapyd$_Iter75.length; _$rapyd$_Index75++) {\n                        argname = _$rapyd$_Iter75[_$rapyd$_Index75];\n                        akey = (argname.alias) ? argname.alias.name : argname.name;\n                        add_aname(akey, self.key, argname.name);\n                    }\n                } else {\n                    if (self.alias) {\n                        add_aname(self.alias.name, self.key, false);\n                    } else {\n                        bound_name = self.key.split(\".\", 1)[0];\n                        add_aname(bound_name, bound_name, false);\n                    }\n                }\n            }\n        };\n\n        print_imports.__argnames__ = [\"container\", \"output\"];\n\n        _$rapyd$_modules[\"output.modules\"].write_imports = write_imports;\n        _$rapyd$_modules[\"output.modules\"].write_main_name = write_main_name;\n        _$rapyd$_modules[\"output.modules\"].declare_exports = declare_exports;\n        _$rapyd$_modules[\"output.modules\"].declare_submodules = declare_submodules;\n        _$rapyd$_modules[\"output.modules\"].prologue = prologue;\n        _$rapyd$_modules[\"output.modules\"].print_top_level = print_top_level;\n        _$rapyd$_modules[\"output.modules\"].print_module = print_module;\n        _$rapyd$_modules[\"output.modules\"].print_imports = print_imports;\n    })();\n\n    (function(){\n        var __name__ = \"output.operators\";\n        var AST_Number = _$rapyd$_modules.ast.AST_Number;\n        var AST_Unary = _$rapyd$_modules.ast.AST_Unary;\n        var AST_Seq = _$rapyd$_modules.ast.AST_Seq;\n        var AST_Array = _$rapyd$_modules.ast.AST_Array;\n        var AST_Binary = _$rapyd$_modules.ast.AST_Binary;\n        var AST_Set = _$rapyd$_modules.ast.AST_Set;\n        var AST_Object = _$rapyd$_modules.ast.AST_Object;\n        var AST_Statement = _$rapyd$_modules.ast.AST_Statement;\n        var AST_Conditional = _$rapyd$_modules.ast.AST_Conditional;\n        var AST_BaseCall = _$rapyd$_modules.ast.AST_BaseCall;\n        var AST_Symbol = _$rapyd$_modules.ast.AST_Symbol;\n        var AST_SymbolRef = _$rapyd$_modules.ast.AST_SymbolRef;\n        var AST_Assign = _$rapyd$_modules.ast.AST_Assign;\n        var AST_Return = _$rapyd$_modules.ast.AST_Return;\n        var AST_SimpleStatement = _$rapyd$_modules.ast.AST_SimpleStatement;\n        var has_calls = _$rapyd$_modules.ast.has_calls;\n        var AST_String = _$rapyd$_modules.ast.AST_String;\n        \n        var unpack_tuple = _$rapyd$_modules[\"output.loops\"].unpack_tuple;\n        \n        function print_getattr(self, output, skip_expression) {\n            var expr;\n            if (!skip_expression) {\n                expr = self.expression;\n                expr.print(output);\n            }\n            if (expr instanceof AST_Number && expr.getValue() >= 0) {\n                if (!/[xa-f.]/i.test(output.last())) {\n                    output.print(\".\");\n                }\n            }\n            output.print(\".\");\n            output.print_name(self.property);\n        };\n\n        print_getattr.__argnames__ = [\"self\", \"output\", \"skip_expression\"];\n\n        function print_getitem(self, output, skip_expression) {\n            var is_repeatable, from_end, enclose;\n            is_repeatable = !has_calls(self.expression);\n            from_end = self.property instanceof AST_Unary && self.property.operator === \"-\" && self.property.expression instanceof AST_Number;\n            enclose = from_end && !is_repeatable && !skip_expression;\n            if (enclose) {\n                output.assign(\"(_$rapyd$_expr_temp\");\n            }\n            if (!skip_expression) {\n                self.expression.print(output);\n            }\n            if (enclose) {\n                [output.comma(), output.print(\"_$rapyd$_expr_temp\")];\n            }\n            output.print(\"[\");\n            if (from_end) {\n                if (enclose) {\n                    output.print(\"_$rapyd$_expr_temp\");\n                } else {\n                    self.expression.print(output);\n                }\n                output.print(\".length\");\n            }\n            self.property.print(output);\n            output.print(\"]\");\n            if (enclose) {\n                output.print(\")\");\n            }\n        };\n\n        print_getitem.__argnames__ = [\"self\", \"output\", \"skip_expression\"];\n\n        function print_rich_getitem(self, output) {\n            var func;\n            func = \"_$rapyd$_\" + ((self.assignment) ? \"setitem\" : \"getitem\");\n            output.print(func + \"(\");\n            [self.expression.print(output), output.comma(), self.property.print(output)];\n            if (self.assignment) {\n                [output.comma(), self.assignment.print(output)];\n            }\n            output.print(\")\");\n        };\n\n        print_rich_getitem.__argnames__ = [\"self\", \"output\"];\n\n        function print_splice_assignment(self, output) {\n            output.print(\"[].splice.apply\");\n            output.with_parens((function() {\n                var _$rapyd$_anonfunc = function () {\n                    self.expression.print(output);\n                    output.comma();\n                    output.with_square((function() {\n                        var _$rapyd$_anonfunc = function () {\n                            self.property.print(output);\n                            output.comma();\n                            self.property2.print(output);\n                            output.print(\"-\");\n                            self.property.print(output);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                    output.print(\".concat\");\n                    output.with_parens((function() {\n                        var _$rapyd$_anonfunc = function () {\n                            self.assignment.print(output);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n                return _$rapyd$_anonfunc;\n            })());\n        };\n\n        print_splice_assignment.__argnames__ = [\"self\", \"output\"];\n\n        function print_unary_prefix(self, output) {\n            var op;\n            op = self.operator;\n            output.print(op);\n            if (/^[a-z]/i.test(op)) {\n                output.space();\n            }\n            self.expression.print(output);\n        };\n\n        print_unary_prefix.__argnames__ = [\"self\", \"output\"];\n\n        function print_unary_postfix(self, output) {\n            self.expression.print(output);\n            output.print(self.operator);\n        };\n\n        print_unary_postfix.__argnames__ = [\"self\", \"output\"];\n\n        function write_instanceof(left, right, output) {\n            function single(left, right) {\n                if (right.name === \"Array\" || right.name === \"list\") {\n                    output.print(\"Array.isArray\");\n                    output.with_parens((function() {\n                        var _$rapyd$_anonfunc = function () {\n                            left.print(output);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                } else {\n                    output.spaced(left, \"instanceof\", right);\n                }\n            };\n\n            single.__argnames__ = [\"left\", \"right\"];\n\n            if (right instanceof AST_Seq) {\n                right = new AST_Array({\n                    \"elements\": right.to_array()\n                });\n            }\n            if (right instanceof AST_Array) {\n                output.with_parens((function() {\n                    var _$rapyd$_anonfunc = function () {\n                        right.elements.forEach((function() {\n                            var _$rapyd$_anonfunc = function (right, i, arr) {\n                                single(left, right);\n                                if (arr.length > 1 && i < arr.length - 1) {\n                                    [output.space(), output.print(\"||\"), output.space()];\n                                }\n                            };\n\n                            _$rapyd$_anonfunc.__argnames__ = [\"right\", \"i\", \"arr\"];\n                            return _$rapyd$_anonfunc;\n                        })());\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n            } else {\n                single(left, right);\n            }\n        };\n\n        write_instanceof.__argnames__ = [\"left\", \"right\", \"output\"];\n\n        function write_smart_equality(self, output) {\n            function is_ok(x) {\n                return !((x instanceof AST_Array || x instanceof AST_Set || x instanceof AST_Object || x instanceof AST_Statement || x instanceof AST_Binary || x instanceof AST_Conditional || x instanceof AST_BaseCall));\n            };\n\n            is_ok.__argnames__ = [\"x\"];\n\n            if (is_ok(self.left) && is_ok(self.right)) {\n                if (self.operator === \"==\") {\n                    output.print(\"(\");\n                    output.spaced(self.left, \"===\", self.right, \"||\", \"typeof\", self.left, \"===\", \"\\\"object\\\"\", \"&&\", \"_$rapyd$_equals(\");\n                    [self.left.print(output), output.print(\",\"), output.space(), self.right.print(output), \n                    output.print(\"))\")];\n                } else {\n                    output.print(\"(\");\n                    output.spaced(self.left, \"!==\", self.right, \"&&\", \"(typeof\", self.left, \"!==\", \"\\\"object\\\"\", \"||\", \"_$rapyd$_not_equals(\");\n                    [self.left.print(output), output.print(\",\"), output.space(), self.right.print(output), \n                    output.print(\")))\")];\n                }\n            } else {\n                output.print(\"_$rapyd$_\" + ((self.operator === \"==\") ? \"equals(\" : \"not_equals(\"));\n                [self.left.print(output), output.print(\",\"), output.space(), self.right.print(output), \n                output.print(\")\")];\n            }\n        };\n\n        write_smart_equality.__argnames__ = [\"self\", \"output\"];\n\n        function print_binary_op(self, output) {\n            var comparators, function_ops, leftvar;\n            comparators = {\n                \"<\": true,\n                \">\": true,\n                \"<=\": true,\n                \">=\": true,\n                \"==\": true,\n                \"!=\": true\n            };\n            function_ops = {\n                \"in\": \"_$rapyd$_in\",\n                \"**\": \"Math.pow\"\n            };\n            if (function_ops[self.operator]) {\n                output.print(function_ops[self.operator]);\n                output.with_parens((function() {\n                    var _$rapyd$_anonfunc = function () {\n                        self.left.print(output);\n                        output.comma();\n                        self.right.print(output);\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n            } else if (comparators[self.operator] && self.left instanceof AST_Binary && comparators[self.left.operator]) {\n                if (self.left.right instanceof AST_Symbol) {\n                    self.left.print(output);\n                    leftvar = self.left.right.name;\n                } else {\n                    self.left.left.print(output);\n                    output.space();\n                    output.print(self.left.operator);\n                    output.space();\n                    output.with_parens((function() {\n                        var _$rapyd$_anonfunc = function () {\n                            output.assign(\"_$rapyd$_cond_temp\");\n                            self.left.right.print(output);\n                            leftvar = \"_$rapyd$_cond_temp\";\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                }\n                output.space();\n                output.print(\"&&\");\n                output.space();\n                output.print(leftvar);\n                output.space();\n                output.print(self.operator);\n                output.space();\n                self.right.print(output);\n            } else if (self.operator === \"//\") {\n                output.print(\"Math.floor\");\n                output.with_parens((function() {\n                    var _$rapyd$_anonfunc = function () {\n                        self.left.print(output);\n                        output.space();\n                        output.print(\"/\");\n                        output.space();\n                        self.right.print(output);\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n            } else if (self.operator === \"==\" || self.operator === \"!=\") {\n                write_smart_equality(self, output);\n            } else if (self.operator === \"instanceof\") {\n                write_instanceof(self.left, self.right, output);\n            } else if (self.operator === \"*\" && self.left instanceof AST_String) {\n                [self.left.print(output), output.print(\".repeat(\"), self.right.print(output), output.print(\")\")];\n            } else {\n                output.spaced(self.left, self.operator, self.right);\n            }\n        };\n\n        print_binary_op.__argnames__ = [\"self\", \"output\"];\n\n        function print_assignment(self, output) {\n            var flattened, left, flat;\n            flattened = false;\n            left = self.left;\n            if (left instanceof AST_Seq) {\n                left = new AST_Array({\n                    \"elements\": [left.car, left.cdr]\n                });\n            }\n            if (left instanceof AST_Array) {\n                flat = left.flatten();\n                flattened = flat.length > left.elements.length;\n                output.print(\"_$rapyd$_unpack\");\n            } else {\n                left.print(output);\n            }\n            output.space();\n            output.print(self.operator);\n            output.space();\n            if (flattened) {\n                output.print(\"_$rapyd$_flatten\");\n                output.with_parens((function() {\n                    var _$rapyd$_anonfunc = function () {\n                        self.right.print(output);\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n            } else {\n                self.right.print(output);\n            }\n            if (left instanceof AST_Array) {\n                output.semicolon();\n                output.newline();\n                unpack_tuple(flat, output, true);\n            }\n        };\n\n        print_assignment.__argnames__ = [\"self\", \"output\"];\n\n        function print_assign(self, output) {\n            var _$rapyd$_unpack, left_hand_sides, rhs, temp_rhs, lhs;\n            if (self.operator === \"//=\") {\n                output.assign(self.left);\n                output.print(\"Math.floor\");\n                output.with_parens((function() {\n                    var _$rapyd$_anonfunc = function () {\n                        self.left.print(output);\n                        output.space();\n                        output.print(\"/\");\n                        output.space();\n                        self.right.print(output);\n                    };\n                    return _$rapyd$_anonfunc;\n                })());\n                return;\n            }\n            if (self.operator === \"=\" && self.is_chained()) {\n                _$rapyd$_unpack = self.traverse_chain();\n                left_hand_sides = _$rapyd$_unpack[0];\n                rhs = _$rapyd$_unpack[1];\n                temp_rhs = new AST_SymbolRef({\n                    \"name\": \"_$rapyd$_chain_assign_temp\"\n                });\n                print_assignment(new AST_Assign({\n                    \"left\": temp_rhs,\n                    \"operator\": \"=\",\n                    \"right\": rhs\n                }), output);\n                [output.end_statement(), output.indent()];\n                var _$rapyd$_Iter76 = _$rapyd$_Iterable(left_hand_sides);\n                for (var _$rapyd$_Index76 = 0; _$rapyd$_Index76 < _$rapyd$_Iter76.length; _$rapyd$_Index76++) {\n                    lhs = _$rapyd$_Iter76[_$rapyd$_Index76];\n                    print_assignment(new AST_Assign({\n                        \"left\": lhs,\n                        \"right\": temp_rhs,\n                        \"operator\": self.operator\n                    }), output);\n                    output.end_statement();\n                    if (lhs !== left_hand_sides[left_hand_sides.length-1]) {\n                        output.indent();\n                    }\n                }\n            } else {\n                print_assignment(self, output);\n            }\n        };\n\n        print_assign.__argnames__ = [\"self\", \"output\"];\n\n        function print_conditional(self, output, condition, consequent, alternative) {\n            var _$rapyd$_unpack;\n            _$rapyd$_unpack = [self.condition, self.consequent, self.alternative];\n            condition = _$rapyd$_unpack[0];\n            consequent = _$rapyd$_unpack[1];\n            alternative = _$rapyd$_unpack[2];\n            output.with_parens((function() {\n                var _$rapyd$_anonfunc = function () {\n                    condition.print(output);\n                };\n                return _$rapyd$_anonfunc;\n            })());\n            output.space();\n            output.print(\"?\");\n            output.space();\n            consequent.print(output);\n            output.space();\n            output.colon();\n            alternative.print(output);\n        };\n\n        print_conditional.__argnames__ = [\"self\", \"output\", \"condition\", \"consequent\", \"alternative\"];\n\n        function print_seq(output) {\n            var self, p, print_seq;\n            self = this;\n            p = output.parent();\n            print_seq = (function() {\n                var _$rapyd$_anonfunc = function () {\n                    self.car.print(output);\n                    if (self.cdr) {\n                        output.comma();\n                        if (output.should_break()) {\n                            output.newline();\n                            output.indent();\n                        }\n                        self.cdr.print(output);\n                    }\n                };\n                return _$rapyd$_anonfunc;\n            })();\n            if (p instanceof AST_Binary || p instanceof AST_Return || p instanceof AST_Array || p instanceof AST_BaseCall || p instanceof AST_SimpleStatement) {\n                output.with_square(print_seq);\n            } else {\n                print_seq();\n            }\n        };\n\n        print_seq.__argnames__ = [\"output\"];\n\n        _$rapyd$_modules[\"output.operators\"].print_getattr = print_getattr;\n        _$rapyd$_modules[\"output.operators\"].print_getitem = print_getitem;\n        _$rapyd$_modules[\"output.operators\"].print_rich_getitem = print_rich_getitem;\n        _$rapyd$_modules[\"output.operators\"].print_splice_assignment = print_splice_assignment;\n        _$rapyd$_modules[\"output.operators\"].print_unary_prefix = print_unary_prefix;\n        _$rapyd$_modules[\"output.operators\"].print_unary_postfix = print_unary_postfix;\n        _$rapyd$_modules[\"output.operators\"].write_instanceof = write_instanceof;\n        _$rapyd$_modules[\"output.operators\"].write_smart_equality = write_smart_equality;\n        _$rapyd$_modules[\"output.operators\"].print_binary_op = print_binary_op;\n        _$rapyd$_modules[\"output.operators\"].print_assignment = print_assignment;\n        _$rapyd$_modules[\"output.operators\"].print_assign = print_assign;\n        _$rapyd$_modules[\"output.operators\"].print_conditional = print_conditional;\n        _$rapyd$_modules[\"output.operators\"].print_seq = print_seq;\n    })();\n\n    (function(){\n        var __name__ = \"output.utils\";\n        var AST_BlockStatement = _$rapyd$_modules.ast.AST_BlockStatement;\n        \n        function best_of(a) {\n            var best, len_, i;\n            best = a[0];\n            len_ = best.length;\n            for (var _$rapyd$_Index77 = 1; _$rapyd$_Index77 < a.length; _$rapyd$_Index77++) {\n                i = _$rapyd$_Index77;\n                if (a[i].length < len_) {\n                    best = a[i];\n                    len_ = best.length;\n                }\n            }\n            return best;\n        };\n\n        best_of.__argnames__ = [\"a\"];\n\n        function make_num(num) {\n            var str_, a, m;\n            str_ = num.toString(10);\n            a = _$rapyd$_list_decorate([ str_.replace(/^0\\./, \".\").replace(\"e+\", \"e\") ]);\n            m = null;\n            if (Math.floor(num) === num) {\n                if (num >= 0) {\n                    a.push(\"0x\" + num.toString(16).toLowerCase(), \"0\" + num.toString(8));\n                } else {\n                    a.push(\"-0x\" + (-num).toString(16).toLowerCase(), \"-0\" + (-num).toString(8));\n                }\n                if (m = /^(.*?)(0+)$/.exec(num)) {\n                    a.push(m[1] + \"e\" + m[2].length);\n                }\n            } else if (m = /^0?\\.(0+)(.*)$/.exec(num)) {\n                a.push(m[2] + \"e-\" + (m[1].length + m[2].length), str_.substr(str_.indexOf(\".\")));\n            }\n            return best_of(a);\n        };\n\n        make_num.__argnames__ = [\"num\"];\n\n        function make_block(stmt, output) {\n            if (stmt instanceof AST_BlockStatement) {\n                stmt.print(output);\n                return;\n            }\n            output.with_block((function() {\n                var _$rapyd$_anonfunc = function () {\n                    output.indent();\n                    stmt.print(output);\n                    output.newline();\n                };\n                return _$rapyd$_anonfunc;\n            })());\n        };\n\n        make_block.__argnames__ = [\"stmt\", \"output\"];\n\n        _$rapyd$_modules[\"output.utils\"].best_of = best_of;\n        _$rapyd$_modules[\"output.utils\"].make_num = make_num;\n        _$rapyd$_modules[\"output.utils\"].make_block = make_block;\n    })();\n\n    (function(){\n        var __name__ = \"output.codegen\";\n        var noop = _$rapyd$_modules.utils.noop;\n        \n        var PRECEDENCE = _$rapyd$_modules.parse.PRECEDENCE;\n        \n        var AST_Array = _$rapyd$_modules.ast.AST_Array;\n        var AST_Assign = _$rapyd$_modules.ast.AST_Assign;\n        var AST_BaseCall = _$rapyd$_modules.ast.AST_BaseCall;\n        var AST_Binary = _$rapyd$_modules.ast.AST_Binary;\n        var AST_BlockStatement = _$rapyd$_modules.ast.AST_BlockStatement;\n        var AST_Break = _$rapyd$_modules.ast.AST_Break;\n        var AST_Catch = _$rapyd$_modules.ast.AST_Catch;\n        var AST_Class = _$rapyd$_modules.ast.AST_Class;\n        var AST_Conditional = _$rapyd$_modules.ast.AST_Conditional;\n        var AST_Const = _$rapyd$_modules.ast.AST_Const;\n        var AST_Constant = _$rapyd$_modules.ast.AST_Constant;\n        var AST_Continue = _$rapyd$_modules.ast.AST_Continue;\n        var AST_Debugger = _$rapyd$_modules.ast.AST_Debugger;\n        var AST_Definitions = _$rapyd$_modules.ast.AST_Definitions;\n        var AST_Directive = _$rapyd$_modules.ast.AST_Directive;\n        var AST_Do = _$rapyd$_modules.ast.AST_Do;\n        var AST_Dot = _$rapyd$_modules.ast.AST_Dot;\n        var AST_EmptyStatement = _$rapyd$_modules.ast.AST_EmptyStatement;\n        var AST_Exit = _$rapyd$_modules.ast.AST_Exit;\n        var AST_ExpressiveObject = _$rapyd$_modules.ast.AST_ExpressiveObject;\n        var AST_Finally = _$rapyd$_modules.ast.AST_Finally;\n        var AST_ForIn = _$rapyd$_modules.ast.AST_ForIn;\n        var AST_ForJS = _$rapyd$_modules.ast.AST_ForJS;\n        var AST_Function = _$rapyd$_modules.ast.AST_Function;\n        var AST_Hole = _$rapyd$_modules.ast.AST_Hole;\n        var AST_If = _$rapyd$_modules.ast.AST_If;\n        var AST_Imports = _$rapyd$_modules.ast.AST_Imports;\n        var AST_Infinity = _$rapyd$_modules.ast.AST_Infinity;\n        var AST_Lambda = _$rapyd$_modules.ast.AST_Lambda;\n        var AST_ListComprehension = _$rapyd$_modules.ast.AST_ListComprehension;\n        var AST_LoopControl = _$rapyd$_modules.ast.AST_LoopControl;\n        var AST_NaN = _$rapyd$_modules.ast.AST_NaN;\n        var AST_New = _$rapyd$_modules.ast.AST_New;\n        var AST_Node = _$rapyd$_modules.ast.AST_Node;\n        var AST_Number = _$rapyd$_modules.ast.AST_Number;\n        var AST_Object = _$rapyd$_modules.ast.AST_Object;\n        var AST_ObjectKeyVal = _$rapyd$_modules.ast.AST_ObjectKeyVal;\n        var AST_ObjectProperty = _$rapyd$_modules.ast.AST_ObjectProperty;\n        var AST_PropAccess = _$rapyd$_modules.ast.AST_PropAccess;\n        var AST_RegExp = _$rapyd$_modules.ast.AST_RegExp;\n        var AST_Return = _$rapyd$_modules.ast.AST_Return;\n        var AST_Set = _$rapyd$_modules.ast.AST_Set;\n        var AST_Seq = _$rapyd$_modules.ast.AST_Seq;\n        var AST_SimpleStatement = _$rapyd$_modules.ast.AST_SimpleStatement;\n        var AST_Splice = _$rapyd$_modules.ast.AST_Splice;\n        var AST_Statement = _$rapyd$_modules.ast.AST_Statement;\n        var AST_StatementWithBody = _$rapyd$_modules.ast.AST_StatementWithBody;\n        var AST_String = _$rapyd$_modules.ast.AST_String;\n        var AST_Sub = _$rapyd$_modules.ast.AST_Sub;\n        var AST_ItemAccess = _$rapyd$_modules.ast.AST_ItemAccess;\n        var AST_Symbol = _$rapyd$_modules.ast.AST_Symbol;\n        var AST_This = _$rapyd$_modules.ast.AST_This;\n        var AST_Throw = _$rapyd$_modules.ast.AST_Throw;\n        var AST_Toplevel = _$rapyd$_modules.ast.AST_Toplevel;\n        var AST_Try = _$rapyd$_modules.ast.AST_Try;\n        var AST_Unary = _$rapyd$_modules.ast.AST_Unary;\n        var AST_UnaryPostfix = _$rapyd$_modules.ast.AST_UnaryPostfix;\n        var AST_UnaryPrefix = _$rapyd$_modules.ast.AST_UnaryPrefix;\n        var AST_Undefined = _$rapyd$_modules.ast.AST_Undefined;\n        var AST_Var = _$rapyd$_modules.ast.AST_Var;\n        var AST_VarDef = _$rapyd$_modules.ast.AST_VarDef;\n        var AST_Verbatim = _$rapyd$_modules.ast.AST_Verbatim;\n        var AST_While = _$rapyd$_modules.ast.AST_While;\n        var AST_With = _$rapyd$_modules.ast.AST_With;\n        var AST_Yield = _$rapyd$_modules.ast.AST_Yield;\n        var TreeWalker = _$rapyd$_modules.ast.TreeWalker;\n        \n        var print_try = _$rapyd$_modules[\"output.exceptions\"].print_try;\n        var print_catch = _$rapyd$_modules[\"output.exceptions\"].print_catch;\n        var print_finally = _$rapyd$_modules[\"output.exceptions\"].print_finally;\n        \n        var OutputStream = _$rapyd$_modules[\"output.stream\"].OutputStream;\n        \n        var print_class = _$rapyd$_modules[\"output.classes\"].print_class;\n        \n        var print_array = _$rapyd$_modules[\"output.literals\"].print_array;\n        var print_obj_literal = _$rapyd$_modules[\"output.literals\"].print_obj_literal;\n        var print_object = _$rapyd$_modules[\"output.literals\"].print_object;\n        var print_set = _$rapyd$_modules[\"output.literals\"].print_set;\n        var print_regexp = _$rapyd$_modules[\"output.literals\"].print_regexp;\n        \n        var print_do_loop = _$rapyd$_modules[\"output.loops\"].print_do_loop;\n        var print_while_loop = _$rapyd$_modules[\"output.loops\"].print_while_loop;\n        var print_for_loop_body = _$rapyd$_modules[\"output.loops\"].print_for_loop_body;\n        var print_for_in = _$rapyd$_modules[\"output.loops\"].print_for_in;\n        var print_list_comprehension = _$rapyd$_modules[\"output.loops\"].print_list_comprehension;\n        \n        var print_top_level = _$rapyd$_modules[\"output.modules\"].print_top_level;\n        var print_imports = _$rapyd$_modules[\"output.modules\"].print_imports;\n        \n        var print_getattr = _$rapyd$_modules[\"output.operators\"].print_getattr;\n        var print_getitem = _$rapyd$_modules[\"output.operators\"].print_getitem;\n        var print_rich_getitem = _$rapyd$_modules[\"output.operators\"].print_rich_getitem;\n        var print_splice_assignment = _$rapyd$_modules[\"output.operators\"].print_splice_assignment;\n        var print_unary_prefix = _$rapyd$_modules[\"output.operators\"].print_unary_prefix;\n        var print_unary_postfix = _$rapyd$_modules[\"output.operators\"].print_unary_postfix;\n        var print_binary_op = _$rapyd$_modules[\"output.operators\"].print_binary_op;\n        var print_assign = _$rapyd$_modules[\"output.operators\"].print_assign;\n        var print_conditional = _$rapyd$_modules[\"output.operators\"].print_conditional;\n        var print_seq = _$rapyd$_modules[\"output.operators\"].print_seq;\n        \n        var print_function = _$rapyd$_modules[\"output.functions\"].print_function;\n        var print_function_call = _$rapyd$_modules[\"output.functions\"].print_function_call;\n        \n        var print_bracketed = _$rapyd$_modules[\"output.statements\"].print_bracketed;\n        var first_in_statement = _$rapyd$_modules[\"output.statements\"].first_in_statement;\n        var force_statement = _$rapyd$_modules[\"output.statements\"].force_statement;\n        var print_with = _$rapyd$_modules[\"output.statements\"].print_with;\n        \n        var make_block = _$rapyd$_modules[\"output.utils\"].make_block;\n        var make_num = _$rapyd$_modules[\"output.utils\"].make_num;\n        \n        function generate_code() {\n            function DEFPRINT(nodetype, generator) {\n                nodetype.DEFMETHOD(\"_codegen\", generator);\n            };\n\n            DEFPRINT.__argnames__ = [\"nodetype\", \"generator\"];\n\n            AST_Node.DEFMETHOD(\"print\", (function() {\n                var _$rapyd$_anonfunc = function (stream, force_parens) {\n                    var self, generator;\n                    self = this;\n                    generator = self._codegen;\n                    stream.push_node(self);\n                    if (force_parens || self.needs_parens(stream)) {\n                        stream.with_parens((function() {\n                            var _$rapyd$_anonfunc = function () {\n                                self.add_comments(stream);\n                                generator(self, stream);\n                            };\n                            return _$rapyd$_anonfunc;\n                        })());\n                    } else {\n                        self.add_comments(stream);\n                        generator(self, stream);\n                    }\n                    stream.pop_node();\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"stream\", \"force_parens\"];\n                return _$rapyd$_anonfunc;\n            })());\n            AST_Node.DEFMETHOD(\"print_to_string\", (function() {\n                var _$rapyd$_anonfunc = function (options) {\n                    var s;\n                    s = new OutputStream(options);\n                    this.print(s);\n                    return s.get();\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"options\"];\n                return _$rapyd$_anonfunc;\n            })());\n            AST_Node.DEFMETHOD(\"add_comments\", (function() {\n                var _$rapyd$_anonfunc = function (output) {\n                    var c, self, start, comments;\n                    c = output.option(\"comments\");\n                    self = this;\n                    if (c) {\n                        start = self.start;\n                        if (start && !start._comments_dumped) {\n                            start._comments_dumped = true;\n                            comments = start.comments_before;\n                            if (self instanceof AST_Exit && self.value && self.value.start.comments_before.length > 0) {\n                                comments = (comments || _$rapyd$_list_decorate([])).concat(self.value.start.comments_before);\n                                self.value.start.comments_before = _$rapyd$_list_decorate([]);\n                            }\n                            if (c.test) {\n                                comments = comments.filter((function() {\n                                    var _$rapyd$_anonfunc = function (comment) {\n                                        return c.test(comment.value);\n                                    };\n\n                                    _$rapyd$_anonfunc.__argnames__ = [\"comment\"];\n                                    return _$rapyd$_anonfunc;\n                                })());\n                            } else if (typeof c === \"function\") {\n                                comments = comments.filter((function() {\n                                    var _$rapyd$_anonfunc = function (comment) {\n                                        return c(self, comment);\n                                    };\n\n                                    _$rapyd$_anonfunc.__argnames__ = [\"comment\"];\n                                    return _$rapyd$_anonfunc;\n                                })());\n                            }\n                            comments.forEach((function() {\n                                var _$rapyd$_anonfunc = function (c) {\n                                    if (c.type === \"comment1\") {\n                                        output.print(\"//\" + c.value + \"\\n\");\n                                        output.indent();\n                                    } else if (c.type === \"comment2\") {\n                                        output.print(\"/*\" + c.value + \"*/\");\n                                        if (start.nlb) {\n                                            output.print(\"\\n\");\n                                            output.indent();\n                                        } else {\n                                            output.space();\n                                        }\n                                    }\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"c\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                        }\n                    }\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            function PARENS(nodetype, func) {\n                nodetype.DEFMETHOD(\"needs_parens\", func);\n            };\n\n            PARENS.__argnames__ = [\"nodetype\", \"func\"];\n\n            PARENS(AST_Node, (function() {\n                var _$rapyd$_anonfunc = function () {\n                    return false;\n                };\n                return _$rapyd$_anonfunc;\n            })());\n            PARENS(AST_Function, (function() {\n                var _$rapyd$_anonfunc = function (output) {\n                    return first_in_statement(output);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            PARENS(AST_Object, (function() {\n                var _$rapyd$_anonfunc = function (output) {\n                    return first_in_statement(output);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            PARENS(AST_Unary, (function() {\n                var _$rapyd$_anonfunc = function (output) {\n                    var p;\n                    p = output.parent();\n                    return p instanceof AST_PropAccess && p.expression === this;\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            PARENS(AST_Seq, (function() {\n                var _$rapyd$_anonfunc = function (output) {\n                    var p;\n                    p = output.parent();\n                    return p instanceof AST_Unary || p instanceof AST_VarDef || p instanceof AST_Dot || p instanceof AST_ObjectProperty || p instanceof AST_Conditional;\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            PARENS(AST_Binary, (function() {\n                var _$rapyd$_anonfunc = function (output) {\n                    var p, po, pp, so, sp;\n                    p = output.parent();\n                    if (p instanceof AST_BaseCall && p.expression === this) {\n                        return true;\n                    }\n                    if (p instanceof AST_Unary) {\n                        return true;\n                    }\n                    if (p instanceof AST_PropAccess && p.expression === this) {\n                        return true;\n                    }\n                    if (p instanceof AST_Binary) {\n                        po = p.operator;\n                        pp = PRECEDENCE[po];\n                        so = this.operator;\n                        sp = PRECEDENCE[so];\n                        if (pp > sp || pp === sp && this === p.right && !(so === po && (so === \"*\" || so === \"&&\" || so === \"||\"))) {\n                            return true;\n                        }\n                    }\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            PARENS(AST_PropAccess, (function() {\n                var _$rapyd$_anonfunc = function (output) {\n                    var p;\n                    p = output.parent();\n                    if (p instanceof AST_New && p.expression === this) {\n                        try {\n                            this.walk(new TreeWalker((function() {\n                                var _$rapyd$_anonfunc = function (node) {\n                                    if (node instanceof AST_BaseCall) {\n                                        throw p;\n                                    }\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"node\"];\n                                return _$rapyd$_anonfunc;\n                            })()));\n                        } catch (_$rapyd$_Exception) {\n                            var ex = _$rapyd$_Exception;\n                            if (ex !== p) {\n                                throw ex;\n                            }\n                            return true;\n                        }\n                    }\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            PARENS(AST_BaseCall, (function() {\n                var _$rapyd$_anonfunc = function (output) {\n                    var p;\n                    p = output.parent();\n                    return p instanceof AST_New && p.expression === this;\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            PARENS(AST_New, (function() {\n                var _$rapyd$_anonfunc = function (output) {\n                    var p;\n                    p = output.parent();\n                    if (this.args.length === 0 && (p instanceof AST_PropAccess || p instanceof AST_BaseCall && p.expression === this)) {\n                        return true;\n                    }\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            PARENS(AST_Number, (function() {\n                var _$rapyd$_anonfunc = function (output) {\n                    var p;\n                    p = output.parent();\n                    if (this.getValue() < 0 && p instanceof AST_PropAccess && p.expression === this) {\n                        return true;\n                    }\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            PARENS(AST_NaN, (function() {\n                var _$rapyd$_anonfunc = function (output) {\n                    var p;\n                    p = output.parent();\n                    if (p instanceof AST_PropAccess && p.expression === this) {\n                        return true;\n                    }\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            function assign_and_conditional_paren_rules(output) {\n                var p;\n                p = output.parent();\n                if (p instanceof AST_Unary) {\n                    return true;\n                }\n                if (p instanceof AST_Binary && !(p instanceof AST_Assign)) {\n                    return true;\n                }\n                if (p instanceof AST_BaseCall && p.expression === this) {\n                    return true;\n                }\n                if (p instanceof AST_Conditional && p.condition === this) {\n                    return true;\n                }\n                if (p instanceof AST_PropAccess && p.expression === this) {\n                    return true;\n                }\n            };\n\n            assign_and_conditional_paren_rules.__argnames__ = [\"output\"];\n\n            PARENS(AST_Assign, assign_and_conditional_paren_rules);\n            PARENS(AST_Conditional, assign_and_conditional_paren_rules);\n            DEFPRINT(AST_Directive, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    output.print_string(self.value);\n                    output.semicolon();\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_Debugger, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    output.print(\"debugger\");\n                    output.semicolon();\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            AST_StatementWithBody.DEFMETHOD(\"_do_print_body\", (function() {\n                var _$rapyd$_anonfunc = function (output) {\n                    force_statement(this.body, output);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_Statement, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    self.body.print(output);\n                    output.semicolon();\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_Toplevel, print_top_level);\n            DEFPRINT(AST_Imports, print_imports);\n            DEFPRINT(AST_SimpleStatement, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    if (!(self.body instanceof AST_EmptyStatement)) {\n                        self.body.print(output);\n                        output.semicolon();\n                    }\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_BlockStatement, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    print_bracketed(self, output);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_EmptyStatement, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_Do, print_do_loop);\n            DEFPRINT(AST_While, print_while_loop);\n            AST_ForIn.DEFMETHOD(\"_do_print_body\", print_for_loop_body);\n            DEFPRINT(AST_ForIn, print_for_in);\n            AST_ForJS.DEFMETHOD(\"_do_print_body\", (function() {\n                var _$rapyd$_anonfunc = function (output) {\n                    var self;\n                    self = this;\n                    output.with_block((function() {\n                        var _$rapyd$_anonfunc = function () {\n                            self.body.body.forEach((function() {\n                                var _$rapyd$_anonfunc = function (stmt, i) {\n                                    output.indent();\n                                    stmt.print(output);\n                                    output.newline();\n                                };\n\n                                _$rapyd$_anonfunc.__argnames__ = [\"stmt\", \"i\"];\n                                return _$rapyd$_anonfunc;\n                            })());\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_ForJS, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    output.print(\"for\");\n                    output.space();\n                    output.with_parens((function() {\n                        var _$rapyd$_anonfunc = function () {\n                            self.condition.print(output);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                    output.space();\n                    self._do_print_body(output);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_ListComprehension, print_list_comprehension);\n            DEFPRINT(AST_With, print_with);\n            AST_Lambda.DEFMETHOD(\"_do_print\", print_function);\n            DEFPRINT(AST_Lambda, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    self._do_print(output);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            AST_Class.DEFMETHOD(\"_do_print\", print_class);\n            DEFPRINT(AST_Class, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    self._do_print(output);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            AST_Exit.DEFMETHOD(\"_do_print\", (function() {\n                var _$rapyd$_anonfunc = function (output, kind) {\n                    var self;\n                    self = this;\n                    output.print(kind);\n                    if (self.value) {\n                        output.space();\n                        self.value.print(output);\n                    }\n                    output.semicolon();\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"output\", \"kind\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_Yield, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    self._do_print(output, \"yield\" + ((self.is_yield_from) ? \"*\" : \"\"));\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_Return, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    self._do_print(output, \"return\");\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_Throw, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    self._do_print(output, \"throw\");\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            AST_LoopControl.DEFMETHOD(\"_do_print\", (function() {\n                var _$rapyd$_anonfunc = function (output, kind) {\n                    output.print(kind);\n                    if (this.label) {\n                        output.space();\n                        this.label.print(output);\n                    }\n                    output.semicolon();\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"output\", \"kind\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_Break, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    self._do_print(output, \"break\");\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_Continue, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    self._do_print(output, \"continue\");\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            function make_then(self, output) {\n                var b;\n                if (output.option(\"bracketize\")) {\n                    make_block(self.body, output);\n                    return;\n                }\n                if (!self.body) {\n                    return output.force_semicolon();\n                }\n                if (self.body instanceof AST_Do && output.option(\"ie_proof\")) {\n                    make_block(self.body, output);\n                    return;\n                }\n                b = self.body;\n                while (true) {\n                    if (b instanceof AST_If) {\n                        if (!b.alternative) {\n                            make_block(self.body, output);\n                            return;\n                        }\n                        b = b.alternative;\n                    } else if (b instanceof AST_StatementWithBody) {\n                        b = b.body;\n                    } else {\n                        break;\n                    }\n                }\n                force_statement(self.body, output);\n            };\n\n            make_then.__argnames__ = [\"self\", \"output\"];\n\n            DEFPRINT(AST_If, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    output.print(\"if\");\n                    output.space();\n                    output.with_parens((function() {\n                        var _$rapyd$_anonfunc = function () {\n                            self.condition.print(output);\n                        };\n                        return _$rapyd$_anonfunc;\n                    })());\n                    output.space();\n                    if (self.alternative) {\n                        make_then(self, output);\n                        output.space();\n                        output.print(\"else\");\n                        output.space();\n                        force_statement(self.alternative, output);\n                    } else {\n                        self._do_print_body(output);\n                    }\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_Try, print_try);\n            DEFPRINT(AST_Catch, print_catch);\n            DEFPRINT(AST_Finally, print_finally);\n            AST_Definitions.DEFMETHOD(\"_do_print\", (function() {\n                var _$rapyd$_anonfunc = function (output, kind) {\n                    var p, in_for, avoid_semicolon;\n                    output.print(kind);\n                    output.space();\n                    this.definitions.forEach((function() {\n                        var _$rapyd$_anonfunc = function (def_, i) {\n                            if (i) {\n                                output.comma();\n                            }\n                            def_.print(output);\n                        };\n\n                        _$rapyd$_anonfunc.__argnames__ = [\"def_\", \"i\"];\n                        return _$rapyd$_anonfunc;\n                    })());\n                    p = output.parent();\n                    in_for = p instanceof AST_ForIn;\n                    avoid_semicolon = in_for && p.init === this;\n                    if (!avoid_semicolon) {\n                        output.semicolon();\n                    }\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"output\", \"kind\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_Var, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    self._do_print(output, \"var\");\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_Const, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    self._do_print(output, \"const\");\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            function parenthesize_for_noin(node, output, noin) {\n                if (!noin) {\n                    node.print(output);\n                } else {\n                    try {\n                        node.walk(new TreeWalker((function() {\n                            var _$rapyd$_anonfunc = function (node) {\n                                if (node instanceof AST_Binary && node.operator === \"in\") {\n                                    throw output;\n                                }\n                            };\n\n                            _$rapyd$_anonfunc.__argnames__ = [\"node\"];\n                            return _$rapyd$_anonfunc;\n                        })()));\n                        node.print(output);\n                    } catch (_$rapyd$_Exception) {\n                        var ex = _$rapyd$_Exception;\n                        if (ex !== output) {\n                            throw ex;\n                        }\n                        node.print(output, true);\n                    }\n                }\n            };\n\n            parenthesize_for_noin.__argnames__ = [\"node\", \"output\", \"noin\"];\n\n            DEFPRINT(AST_VarDef, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    var p, noin;\n                    self.name.print(output);\n                    if (self.value) {\n                        output.assign(\"\");\n                        p = output.parent(1);\n                        noin = p instanceof AST_ForIn;\n                        parenthesize_for_noin(self.value, output, noin);\n                    }\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_BaseCall, print_function_call);\n            AST_Seq.DEFMETHOD(\"_do_print\", print_seq);\n            DEFPRINT(AST_Seq, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    self._do_print(output);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_Dot, print_getattr);\n            DEFPRINT(AST_Sub, print_getitem);\n            DEFPRINT(AST_ItemAccess, print_rich_getitem);\n            DEFPRINT(AST_Splice, print_splice_assignment);\n            DEFPRINT(AST_UnaryPrefix, print_unary_prefix);\n            DEFPRINT(AST_UnaryPostfix, print_unary_postfix);\n            DEFPRINT(AST_Binary, print_binary_op);\n            DEFPRINT(AST_Assign, print_assign);\n            DEFPRINT(AST_Conditional, print_conditional);\n            DEFPRINT(AST_Array, print_array);\n            DEFPRINT(AST_ExpressiveObject, print_obj_literal);\n            DEFPRINT(AST_Object, print_object);\n            DEFPRINT(AST_ObjectKeyVal, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    self.key.print(output);\n                    output.colon();\n                    self.value.print(output);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_Set, print_set);\n            AST_Symbol.DEFMETHOD(\"definition\", (function() {\n                var _$rapyd$_anonfunc = function () {\n                    return this.thedef;\n                };\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_Symbol, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    var def_;\n                    def_ = self.definition();\n                    output.print_name((def_) ? def_.mangled_name || def_.name : self.name);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_Undefined, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    output.print(\"void 0\");\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_Hole, noop);\n            DEFPRINT(AST_Infinity, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    output.print(\"1/0\");\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_NaN, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    output.print(\"0/0\");\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_This, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    output.print(\"this\");\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_Constant, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    output.print(self.getValue());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_String, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    output.print_string(self.getValue());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_Verbatim, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    output.print(self.getValue());\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_Number, (function() {\n                var _$rapyd$_anonfunc = function (self, output) {\n                    output.print(make_num(self.getValue()));\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"self\", \"output\"];\n                return _$rapyd$_anonfunc;\n            })());\n            DEFPRINT(AST_RegExp, print_regexp);\n        };\n\n        _$rapyd$_modules[\"output.codegen\"].generate_code = generate_code;\n    })();\n\n    (function(){\n\n        var __name__ = \"__main__\";\n\n\n        var ast, ast_node;\n        var DefaultsError = _$rapyd$_modules.utils.DefaultsError;\n        var string_template = _$rapyd$_modules.utils.string_template;\n        \n        var ImportError = _$rapyd$_modules.errors.ImportError;\n        var SyntaxError = _$rapyd$_modules.errors.SyntaxError;\n        \n        var ALL_KEYWORDS = _$rapyd$_modules.tokenizer.ALL_KEYWORDS;\n        var IDENTIFIER_PAT = _$rapyd$_modules.tokenizer.IDENTIFIER_PAT;\n        var tokenizer = _$rapyd$_modules.tokenizer.tokenizer;\n        \n        var parse = _$rapyd$_modules.parse.parse;\n        var NATIVE_CLASSES = _$rapyd$_modules.parse.NATIVE_CLASSES;\n        var compile_time_decorators = _$rapyd$_modules.parse.compile_time_decorators;\n        \n        var OutputStream = _$rapyd$_modules[\"output.stream\"].OutputStream;\n        \n        var generate_code = _$rapyd$_modules[\"output.codegen\"].generate_code;\n        \n        generate_code();\n        if (typeof exports === \"object\") {\n            exports.DefaultsError = DefaultsError;\n            exports.parse = parse;\n            exports.compile_time_decorators = compile_time_decorators;\n            exports.OutputStream = OutputStream;\n            exports.string_template = string_template;\n            exports.ALL_KEYWORDS = ALL_KEYWORDS;\n            exports.IDENTIFIER_PAT = IDENTIFIER_PAT;\n            exports.NATIVE_CLASSES = NATIVE_CLASSES;\n            exports.ImportError = ImportError;\n            exports.SyntaxError = SyntaxError;\n            exports.tokenizer = tokenizer;\n            ast = _$rapyd$_modules[\"ast\"];\n            var _$rapyd$_Iter78 = _$rapyd$_Iterable(ast);\n            for (var _$rapyd$_Index78 = 0; _$rapyd$_Index78 < _$rapyd$_Iter78.length; _$rapyd$_Index78++) {\n                ast_node = _$rapyd$_Iter78[_$rapyd$_Index78];\n                if (ast_node.substr(0, 4) === \"AST_\") {\n                    exports[ast_node] = ast[ast_node];\n                }\n            }\n        }\n    })();\n})();","baselib-plain-pretty.js":"var _$rapyd$_len;\nfunction _$rapyd$_bool(val) {\n    return !!val;\n};\n\n_$rapyd$_bool.__argnames__ = [\"val\"];\n\nfunction _$rapyd$_bind(fn, thisArg) {\n    var ret;\n    if (fn.orig) {\n        fn = fn.orig;\n    }\n    if (thisArg === false) {\n        return fn;\n    }\n    ret = (function() {\n        var _$rapyd$_anonfunc = function () {\n            return fn.apply(thisArg, arguments);\n        };\n        return _$rapyd$_anonfunc;\n    })();\n    ret.orig = fn;\n    return ret;\n};\n\n_$rapyd$_bind.__argnames__ = [\"fn\", \"thisArg\"];\n\nfunction _$rapyd$_rebind_all(thisArg, rebind) {\n    if (typeof rebind === \"undefined\") {\n        rebind = true;\n    }\n    for (var p in thisArg) {\n        if (thisArg[p] && thisArg[p].orig) {\n            if (rebind) {\n                thisArg[p] = _$rapyd$_bind(thisArg[p], thisArg);\n            } else {\n                thisArg[p] = thisArg[p].orig;\n            }\n        }\n    }\n};\n\n_$rapyd$_rebind_all.__argnames__ = [\"thisArg\", \"rebind\"];\n\nfunction _$rapyd$_eslice(arr, step, start, end) {\n    var isString;\n    arr = arr.slice(0);\n    if (typeof arr === \"string\" || arr instanceof String) {\n        isString = true;\n        arr = arr.split(\"\");\n    }\n    if (step < 0) {\n        step = -step;\n        arr.reverse();\n        if (typeof start !== \"undefined\") {\n            start = arr.length - start - 1;\n        }\n        if (typeof end !== \"undefined\") {\n            end = arr.length - end - 1;\n        }\n    }\n    if (typeof start === \"undefined\") {\n        start = 0;\n    }\n    if (typeof end === \"undefined\") {\n        end = arr.length;\n    }\n    arr = arr.slice(start, end).filter((function() {\n        var _$rapyd$_anonfunc = function (e, i) {\n            return i % step === 0;\n        };\n\n        _$rapyd$_anonfunc.__argnames__ = [\"e\", \"i\"];\n        return _$rapyd$_anonfunc;\n    })());\n    return (isString) ? arr.join(\"\") : arr;\n};\n\n_$rapyd$_eslice.__argnames__ = [\"arr\", \"step\", \"start\", \"end\"];\n\nfunction _$rapyd$_mixin(target, source, overwrite) {\n    for (var i in source) {\n        if (source.hasOwnProperty(i) && overwrite || typeof target[i] === \"undefined\") {\n            target[i] = source[i];\n        }\n    }\n};\n\n_$rapyd$_mixin.__argnames__ = [\"target\", \"source\", \"overwrite\"];\n\nfunction _$rapyd$_print() {\n    var parts;\n    if (typeof console === \"object\") {\n        parts = [];\n        for (var i = 0; i < arguments.length; i++) {\n            parts.push(_$rapyd$_str(arguments[i]));\n        }\n        console.log(parts.join(\" \"));\n    }\n};\n\nfunction _$rapyd$_int(val, base) {\n    var ans;\n    ans = parseInt(val, base || 10);\n    if (isNaN(ans)) {\n        throw new ValueError(\"Invalid literal for int with base \" + (base || 10) + \": \" + val);\n    }\n    return ans;\n};\n\n_$rapyd$_int.__argnames__ = [\"val\", \"base\"];\n\nfunction _$rapyd$_float() {\n    var ans;\n    ans = parseFloat.apply(null, arguments);\n    if (isNaN(ans)) {\n        throw new ValueError(\"Could not convert string to float: \" + arguments[0]);\n    }\n    return ans;\n};\n\nfunction _$rapyd$_arraylike_creator() {\n    var names;\n    names = \"Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array\".split(\" \");\n    if (typeof HTMLCollection === \"function\") {\n        names = names.concat(\"HTMLCollection NodeList NamedNodeMap\".split(\" \"));\n    }\n    return (function() {\n        var _$rapyd$_anonfunc = function (x) {\n            if (Array.isArray(x) || typeof x === \"string\" || names.indexOf(Object.prototype.toString.call(x).slice(8, -1)) > -1) {\n                return true;\n            }\n            return false;\n        };\n\n        _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n        return _$rapyd$_anonfunc;\n    })();\n};\n\nfunction options_object(f) {\n    return (function() {\n        var _$rapyd$_anonfunc = function () {\n            if (typeof arguments[arguments.length - 1] === \"object\") {\n                arguments[arguments.length - 1][_$rapyd$_kwargs_symbol] = true;\n            }\n            return f.apply(this, arguments);\n        };\n        return _$rapyd$_anonfunc;\n    })();\n};\n\noptions_object.__argnames__ = [\"f\"];\n\nfunction _$rapyd$_id(x) {\n    return x._$rapyd$_object_id;\n};\n\n_$rapyd$_id.__argnames__ = [\"x\"];\n\nfunction _$rapyd$_dir(item) {\n    var arr;\n    arr = _$rapyd$_list_decorate([]);\n    for (var i in item) {\n        arr.push(i);\n    }\n    return arr;\n};\n\n_$rapyd$_dir.__argnames__ = [\"item\"];\n\nfunction _$rapyd$_ord(x) {\n    var ans, second;\n    ans = x.charCodeAt(0);\n    if (55296 <= ans && ans <= 56319) {\n        second = x.charCodeAt(1);\n        if (56320 <= second && second <= 57343) {\n            return (ans - 55296) * 1024 + second - 56320 + 65536;\n        }\n        throw new TypeError(\"string is missing the low surrogate char\");\n    }\n    return ans;\n};\n\n_$rapyd$_ord.__argnames__ = [\"x\"];\n\nfunction _$rapyd$_chr(code) {\n    if (code <= 65535) {\n        return String.fromCharCode(code);\n    }\n    code -= 65536;\n    return String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n};\n\n_$rapyd$_chr.__argnames__ = [\"code\"];\n\nfunction _$rapyd$_callable(x) {\n    return typeof x === \"function\";\n};\n\n_$rapyd$_callable.__argnames__ = [\"x\"];\n\nfunction _$rapyd$_bin(x) {\n    var ans;\n    if (typeof x !== \"number\" || x % 1 !== 0) {\n        throw new TypeError(\"integer required\");\n    }\n    ans = x.toString(2);\n    if (ans[0] === \"-\") {\n        ans = \"-\" + \"0b\" + ans.slice(1);\n    } else {\n        ans = \"0b\" + ans;\n    }\n    return ans;\n};\n\n_$rapyd$_bin.__argnames__ = [\"x\"];\n\nfunction _$rapyd$_hex(x) {\n    var ans;\n    if (typeof x !== \"number\" || x % 1 !== 0) {\n        throw new TypeError(\"integer required\");\n    }\n    ans = x.toString(16);\n    if (ans[0] === \"-\") {\n        ans = \"-\" + \"0x\" + ans.slice(1);\n    } else {\n        ans = \"0x\" + ans;\n    }\n    return ans;\n};\n\n_$rapyd$_hex.__argnames__ = [\"x\"];\n\nfunction _$rapyd$_enumerate(iterable) {\n    var ans, iterator;\n    if (_$rapyd$_arraylike(iterable)) {\n        ans = {\n            \"_i\": -1,\n            \"next\": (function() {\n                var _$rapyd$_anonfunc = function () {\n                    this._i += 1;\n                    if (this._i < iterable.length) {\n                        return {\n                            \"done\": false,\n                            \"value\": _$rapyd$_list_decorate([ this._i, iterable[this._i] ])\n                        };\n                    }\n                    return {\n                        \"done\": true\n                    };\n                };\n                return _$rapyd$_anonfunc;\n            })()\n        };\n        ans[_$rapyd$_iterator_symbol] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this;\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        return ans;\n    }\n    if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n        ans = {\n            \"_iterator\": iterator,\n            \"_i\": -1,\n            \"next\": (function() {\n                var _$rapyd$_anonfunc = function () {\n                    var r;\n                    r = this._iterator.next();\n                    if (r.done) {\n                        return {\n                            \"done\": true\n                        };\n                    }\n                    this._i += 1;\n                    return {\n                        \"done\": false,\n                        \"value\": _$rapyd$_list_decorate([ this._i, r.value ])\n                    };\n                };\n                return _$rapyd$_anonfunc;\n            })()\n        };\n        ans[_$rapyd$_iterator_symbol] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this;\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        return ans;\n    }\n    return _$rapyd$_enumerate(Object.keys(iterable));\n};\n\n_$rapyd$_enumerate.__argnames__ = [\"iterable\"];\n\nfunction _$rapyd$_reversed(iterable) {\n    var ans;\n    if (_$rapyd$_arraylike(iterable)) {\n        ans = {\n            \"_i\": iterable.length,\n            \"next\": (function() {\n                var _$rapyd$_anonfunc = function () {\n                    this._i -= 1;\n                    if (this._i > -1) {\n                        return {\n                            \"done\": false,\n                            \"value\": iterable[this._i]\n                        };\n                    }\n                    return {\n                        \"done\": true\n                    };\n                };\n                return _$rapyd$_anonfunc;\n            })()\n        };\n        ans[_$rapyd$_iterator_symbol] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this;\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        return ans;\n    }\n    throw new TypeError(\"reversed() can only be called on arrays or strings\");\n};\n\n_$rapyd$_reversed.__argnames__ = [\"iterable\"];\n\nfunction _$rapyd$_iter(iterable) {\n    var ans;\n    if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n        return (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n    }\n    if (_$rapyd$_arraylike(iterable)) {\n        ans = {\n            \"_i\": -1,\n            \"next\": (function() {\n                var _$rapyd$_anonfunc = function () {\n                    this._i += 1;\n                    if (this._i < iterable.length) {\n                        return {\n                            \"done\": false,\n                            \"value\": iterable[this._i]\n                        };\n                    }\n                    return {\n                        \"done\": true\n                    };\n                };\n                return _$rapyd$_anonfunc;\n            })()\n        };\n        ans[_$rapyd$_iterator_symbol] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this;\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        return ans;\n    }\n    return _$rapyd$_iter(Object.keys(iterable));\n};\n\n_$rapyd$_iter.__argnames__ = [\"iterable\"];\n\nfunction _$rapyd$_range(start, stop, step) {\n    var length;\n    if (arguments.length <= 1) {\n        stop = start || 0;\n        start = 0;\n    }\n    step = arguments[2] || 1;\n    length = Math.max(Math.ceil((stop - start) / step), 0);\n    return (function(){\n        var _$rapyd$_d = {};\n        _$rapyd$_d[_$rapyd$_iterator_symbol] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this;\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        _$rapyd$_d[\"_i\"] = start - step;\n        _$rapyd$_d[\"_idx\"] = -1;\n        _$rapyd$_d[\"next\"] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                this._i += step;\n                this._idx += 1;\n                if (this._idx >= length) {\n                    return {\n                        \"done\": true\n                    };\n                }\n                return {\n                    \"done\": false,\n                    \"value\": this._i\n                };\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        return _$rapyd$_d;\n    })();\n};\n\n_$rapyd$_range.__argnames__ = [\"start\", \"stop\", \"step\"];\n\nfunction _$rapyd$_getattr(obj, name, defval) {\n    var ret;\n    try {\n        ret = obj[name];\n    } catch (_$rapyd$_Exception) {\n        if (_$rapyd$_Exception instanceof TypeError) {\n            if (defval === undefined) {\n                throw new AttributeError(\"The attribute \" + name + \" is not present\");\n            }\n            return defval;\n        } else {\n            throw _$rapyd$_Exception;\n        }\n    }\n    if (ret === undefined && !(name in obj)) {\n        if (defval === undefined) {\n            throw new AttributeError(\"The attribute \" + name + \" is not present\");\n        }\n        ret = defval;\n    }\n    return ret;\n};\n\n_$rapyd$_getattr.__argnames__ = [\"obj\", \"name\", \"defval\"];\n\nfunction _$rapyd$_setattr(obj, name, value) {\n    obj[name] = value;\n};\n\n_$rapyd$_setattr.__argnames__ = [\"obj\", \"name\", \"value\"];\n\nfunction _$rapyd$_hasattr(obj, name) {\n    return name in obj;\n};\n\n_$rapyd$_hasattr.__argnames__ = [\"obj\", \"name\"];\n\n_$rapyd$_len = (function() {\n    var _$rapyd$_anonfunc = function () {\n        function len(obj) {\n            if (_$rapyd$_arraylike(obj)) {\n                return obj.length;\n            }\n            if (typeof obj.__len__ === \"function\") {\n                return obj.__len__();\n            }\n            if (obj instanceof Set || obj instanceof Map) {\n                return obj.size;\n            }\n            return Object.keys(obj).length;\n        };\n\n        len.__argnames__ = [\"obj\"];\n\n        function len5(obj) {\n            if (_$rapyd$_arraylike(obj)) {\n                return obj.length;\n            }\n            if (typeof obj.__len__ === \"function\") {\n                return obj.__len__();\n            }\n            return Object.keys(obj).length;\n        };\n\n        len5.__argnames__ = [\"obj\"];\n\n        return (typeof Set === \"function\" && typeof Map === \"function\") ? len : len5;\n    };\n    return _$rapyd$_anonfunc;\n})()();\nvar abs = Math.abs, max = Math.max, min = Math.min;\nvar bool = _$rapyd$_bool, bind = _$rapyd$_bind, rebind_all = _$rapyd$_rebind_all;\nvar float = _$rapyd$_float, int = _$rapyd$_int, arraylike = _$rapyd$_arraylike_creator(), _$rapyd$_arraylike = arraylike;\nvar mixin = _$rapyd$_mixin, print = _$rapyd$_print, eslice = _$rapyd$_eslice, id = _$rapyd$_id;\nvar dir = _$rapyd$_dir, ord = _$rapyd$_ord, chr = _$rapyd$_chr, bin = _$rapyd$_bin, hex = _$rapyd$_hex, callable = _$rapyd$_callable;\nvar enumerate = _$rapyd$_enumerate, iter = _$rapyd$_iter, reversed = _$rapyd$_reversed, len = _$rapyd$_len;\nvar range = _$rapyd$_range, getattr = _$rapyd$_getattr, setattr = _$rapyd$_setattr, hasattr = _$rapyd$_hasattr;var _$rapyd$_chain_assign_temp;\nfunction _$rapyd$_equals(a, b) {\n    var _$rapyd$_unpack, akeys, bkeys, key;\n    if (a === b) {\n        return true;\n    }\n    if (a && typeof a.__eq__ === \"function\") {\n        return a.__eq__(b);\n    }\n    if (b && typeof b.__eq__ === \"function\") {\n        return b.__eq__(a);\n    }\n    if (_$rapyd$_arraylike(a) && _$rapyd$_arraylike(b)) {\n        if ((a.length !== b.length && (typeof a.length !== \"object\" || _$rapyd$_not_equals(a.length, b.length)))) {\n            return false;\n        }\n        for (var i=0; i < a.length; i++) {\n            if (!((a[i] === b[i] || typeof a[i] === \"object\" && _$rapyd$_equals(a[i], b[i])))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (a && b && a.constructor === b.constructor && a.constructor === Object) {\n        _$rapyd$_unpack = [Object.keys(a), Object.keys(b)];\n        akeys = _$rapyd$_unpack[0];\n        bkeys = _$rapyd$_unpack[1];\n        if (akeys.length !== bkeys.length) {\n            return false;\n        }\n        for (var j=0; j < akeys.length; j++) {\n            key = akeys[j];\n            if (!((a[key] === b[key] || typeof a[key] === \"object\" && _$rapyd$_equals(a[key], b[key])))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n_$rapyd$_equals.__argnames__ = [\"a\", \"b\"];\n\nfunction _$rapyd$_not_equals(a, b) {\n    if (a === b) {\n        return false;\n    }\n    if (a && typeof a.__ne__ === \"function\") {\n        return a.__ne__(b);\n    }\n    if (b && typeof b.__ne__ === \"function\") {\n        return b.__ne__(a);\n    }\n    return !_$rapyd$_equals(a, b);\n};\n\n_$rapyd$_not_equals.__argnames__ = [\"a\", \"b\"];\n\nvar equals = _$rapyd$_equals;\nfunction _$rapyd$_list_extend(iterable) {\n    var start, iterator, result;\n    if (Array.isArray(iterable) || typeof iterable === \"string\") {\n        start = this.length;\n        this.length += iterable.length;\n        for (var i = 0; i < iterable.length; i++) {\n            this[start + i] = iterable[i];\n        }\n    } else {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n        result = iterator.next();\n        while (!result.done) {\n            this.push(result.value);\n            result = iterator.next();\n        }\n    }\n};\n\n_$rapyd$_list_extend.__argnames__ = [\"iterable\"];\n\nfunction _$rapyd$_list_index(val, start, stop) {\n    var idx;\n    start = start || 0;\n    if (start < 0) {\n        start = this.length + start;\n    }\n    if (start < 0) {\n        throw new ValueError(val + \" is not in list\");\n    }\n    if (stop === undefined) {\n        idx = this.indexOf(val, start);\n        if (idx === -1) {\n            throw new ValueError(val + \" is not in list\");\n        }\n        return idx;\n    }\n    if (stop < 0) {\n        stop = this.length + stop;\n    }\n    for (var i = start; i < stop; i++) {\n        if ((this[i] === val || typeof this[i] === \"object\" && _$rapyd$_equals(this[i], val))) {\n            return i;\n        }\n    }\n    throw new ValueError(val + \" is not in list\");\n};\n\n_$rapyd$_list_index.__argnames__ = [\"val\", \"start\", \"stop\"];\n\nfunction _$rapyd$_list_pop(index) {\n    var ans;\n    if (this.length === 0) {\n        throw new IndexError(\"list is empty\");\n    }\n    ans = this.splice(index, 1);\n    if (!ans.length) {\n        throw new IndexError(\"pop index out of range\");\n    }\n    return ans[0];\n};\n\n_$rapyd$_list_pop.__argnames__ = [\"index\"];\n\nfunction _$rapyd$_list_remove(value) {\n    var idx;\n    idx = this.indexOf(value);\n    if (idx === -1) {\n        throw new ValueError(value + \" not in list\");\n    }\n    this.splice(idx, 1);\n};\n\n_$rapyd$_list_remove.__argnames__ = [\"value\"];\n\nfunction _$rapyd$_list_to_string() {\n    return \"[\" + this.join(\", \") + \"]\";\n};\n\nfunction _$rapyd$_list_insert(index, val) {\n    if (index < 0) {\n        index += this.length;\n    }\n    index = min(this.length, max(index, 0));\n    if (index === 0) {\n        this.unshift(val);\n        return;\n    }\n    for (var i = this.length; i > index; i--) {\n        this[i] = this[i - 1];\n    }\n    this[index] = val;\n};\n\n_$rapyd$_list_insert.__argnames__ = [\"index\", \"val\"];\n\nfunction _$rapyd$_list_copy() {\n    return _$rapyd$_list_constructor(this);\n};\n\nfunction _$rapyd$_list_clear() {\n    this.length = 0;\n};\n\nfunction _$rapyd$_list_as_array() {\n    return Array.prototype.slice.call(this);\n};\n\nfunction _$rapyd$_list_count(value) {\n    return this.reduce((function() {\n        var _$rapyd$_anonfunc = function (n, val) {\n            return n + (val === value);\n        };\n\n        _$rapyd$_anonfunc.__argnames__ = [\"n\", \"val\"];\n        return _$rapyd$_anonfunc;\n    })(), 0);\n};\n\n_$rapyd$_list_count.__argnames__ = [\"value\"];\n\nfunction _$rapyd$_list_sort_key(value) {\n    var t;\n    t = typeof value;\n    if (t === \"string\" || t === \"number\") {\n        return value;\n    }\n    return value.toString();\n};\n\n_$rapyd$_list_sort_key.__argnames__ = [\"value\"];\n\nfunction _$rapyd$_list_sort_cmp(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n};\n\n_$rapyd$_list_sort_cmp.__argnames__ = [\"a\", \"b\"];\n\nfunction _$rapyd$_list_sort(key, reverse) {\n    var mult, keymap, k;\n    key = key || _$rapyd$_list_sort_key;\n    mult = (reverse) ? -1 : 1;\n    keymap = dict();\n    for (var i=0; i < this.length; i++) {\n        k = this[i];\n        keymap.set(k, key(k));\n    }\n    this.sort((function() {\n        var _$rapyd$_anonfunc = function (a, b) {\n            return mult * _$rapyd$_list_sort_cmp(keymap.get(a), keymap.get(b));\n        };\n\n        _$rapyd$_anonfunc.__argnames__ = [\"a\", \"b\"];\n        return _$rapyd$_anonfunc;\n    })());\n};\n\n_$rapyd$_list_sort.__argnames__ = [\"key\", \"reverse\"];\n\nfunction _$rapyd$_list_concat() {\n    var ans;\n    ans = Array.prototype.concat.apply(this, arguments);\n    _$rapyd$_list_decorate(ans);\n    return ans;\n};\n\nfunction _$rapyd$_list_slice() {\n    var ans;\n    ans = Array.prototype.slice.apply(this, arguments);\n    _$rapyd$_list_decorate(ans);\n    return ans;\n};\n\nfunction _$rapyd$_list_iterator(value) {\n    var self;\n    self = this;\n    return {\n        \"_i\": -1,\n        \"_list\": self,\n        \"next\": (function() {\n            var _$rapyd$_anonfunc = function () {\n                this._i += 1;\n                if (this._i >= this._list.length) {\n                    return {\n                        \"done\": true\n                    };\n                }\n                return {\n                    \"done\": false,\n                    \"value\": this._list[this._i]\n                };\n            };\n            return _$rapyd$_anonfunc;\n        })()\n    };\n};\n\n_$rapyd$_list_iterator.__argnames__ = [\"value\"];\n\nfunction _$rapyd$_list_len() {\n    return this.length;\n};\n\nfunction _$rapyd$_list_contains(val) {\n    for (var i = 0; i < this.length; i++) {\n        if ((this[i] === val || typeof this[i] === \"object\" && _$rapyd$_equals(this[i], val))) {\n            return true;\n        }\n    }\n    return false;\n};\n\n_$rapyd$_list_contains.__argnames__ = [\"val\"];\n\nfunction _$rapyd$_list_eq(other) {\n    if (!_$rapyd$_arraylike(other)) {\n        return false;\n    }\n    if ((this.length !== other.length && (typeof this.length !== \"object\" || _$rapyd$_not_equals(this.length, other.length)))) {\n        return false;\n    }\n    for (var i = 0; i < this.length; i++) {\n        if (!((this[i] === other[i] || typeof this[i] === \"object\" && _$rapyd$_equals(this[i], other[i])))) {\n            return false;\n        }\n    }\n    return true;\n};\n\n_$rapyd$_list_eq.__argnames__ = [\"other\"];\n\nfunction _$rapyd$_list_decorate(ans) {\n    ans.append = Array.prototype.push;\n    ans.toString = _$rapyd$_list_to_string;\n    ans.inspect = _$rapyd$_list_to_string;\n    ans.extend = _$rapyd$_list_extend;\n    ans.index = _$rapyd$_list_index;\n    ans.pypop = _$rapyd$_list_pop;\n    ans.remove = _$rapyd$_list_remove;\n    ans.insert = _$rapyd$_list_insert;\n    ans.copy = _$rapyd$_list_copy;\n    ans.clear = _$rapyd$_list_clear;\n    ans.count = _$rapyd$_list_count;\n    ans.concat = _$rapyd$_list_concat;\n    ans.pysort = _$rapyd$_list_sort;\n    ans.slice = _$rapyd$_list_slice;\n    ans.as_array = _$rapyd$_list_as_array;\n    ans.__len__ = _$rapyd$_list_len;\n    ans.__contains__ = _$rapyd$_list_contains;\n    ans.__eq__ = _$rapyd$_list_eq;\n    ans.constructor = _$rapyd$_list_constructor;\n    if (typeof ans[_$rapyd$_iterator_symbol] !== \"function\") {\n        ans[_$rapyd$_iterator_symbol] = _$rapyd$_list_iterator;\n    }\n    return ans;\n};\n\n_$rapyd$_list_decorate.__argnames__ = [\"ans\"];\n\nfunction _$rapyd$_list_constructor(iterable) {\n    var ans, iterator, result;\n    if (iterable === undefined) {\n        ans = [];\n    } else if (_$rapyd$_arraylike(iterable)) {\n        ans = new Array(iterable.length);\n        for (var i = 0; i < iterable.length; i++) {\n            ans[i] = iterable[i];\n        }\n    } else if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n        ans = _$rapyd$_list_decorate([]);\n        result = iterator.next();\n        while (!result.done) {\n            ans.push(result.value);\n            result = iterator.next();\n        }\n    } else if (typeof iterable === \"number\") {\n        ans = new Array(iterable);\n    } else {\n        ans = Object.keys(iterable);\n    }\n    return _$rapyd$_list_decorate(ans);\n};\n\n_$rapyd$_list_constructor.__argnames__ = [\"iterable\"];\n\n_$rapyd$_list_constructor.__name__ = \"list\";\nvar list = _$rapyd$_list_constructor, list_wrap = _$rapyd$_list_decorate;\nfunction sorted() {\n    var iterable = ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true) ? undefined : arguments[0];\n    var key = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? sorted.__defaults__.key : arguments[1];\n    var reverse = (arguments[2] === undefined || ( 2 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? sorted.__defaults__.reverse : arguments[2];\n    var _$rapyd$_kwargs_obj = arguments[arguments.length-1];\n    if (_$rapyd$_kwargs_obj === null || typeof _$rapyd$_kwargs_obj !== \"object\" || _$rapyd$_kwargs_obj [_$rapyd$_kwargs_symbol] !== true) _$rapyd$_kwargs_obj = {};\n    if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"key\")){\n        key = _$rapyd$_kwargs_obj.key;\n    }\n    if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"reverse\")){\n        reverse = _$rapyd$_kwargs_obj.reverse;\n    }\n    var ans;\n    ans = _$rapyd$_list_constructor(iterable);\n    ans.pysort(key, reverse);\n    return ans;\n};\n\nsorted.__defaults__ = {\n    key:null, \n    reverse:false\n};\n\nsorted.__handles_kwarg_interpolation__ = true;\n\nsorted.__argnames__ = [\"iterable\", \"key\", \"reverse\"];\n\nvar _$rapyd$_global_object_id = 0, _$rapyd$_set_implementation;\nfunction _$rapyd$_set_keyfor(x) {\n    var t, ans;\n    t = typeof x;\n    if (t === \"string\" || t === \"number\" || t === \"boolean\") {\n        return \"_\" + t[0] + x;\n    }\n    if (x === null) {\n        return \"__!@#$0\";\n    }\n    ans = x._$rapyd$_hash_key_prop;\n    if (ans === undefined) {\n        ans = \"_!@#$\" + (++_$rapyd$_global_object_id);\n        Object.defineProperty(x, \"_$rapyd$_hash_key_prop\", {\n            \"value\": ans\n        });\n    }\n    return ans;\n};\n\n_$rapyd$_set_keyfor.__argnames__ = [\"x\"];\n\nfunction _$rapyd$_set_polyfill() {\n    this._store = {};\n    this.size = 0;\n};\n\n_$rapyd$_set_polyfill.prototype.add = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        var key;\n        key = _$rapyd$_set_keyfor(x);\n        if (!Object.hasOwnProperty.call(this._store, key)) {\n            this.size += 1;\n            this._store[key] = x;\n        }\n        return this;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set_polyfill.prototype.clear = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        this._store = {};\n        this.size = 0;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set_polyfill.prototype.delete = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        var key;\n        key = _$rapyd$_set_keyfor(x);\n        if (Object.hasOwnProperty.call(this._store, key)) {\n            this.size -= 1;\n            delete this._store[key];\n            return true;\n        }\n        return false;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set_polyfill.prototype.has = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        return Object.hasOwnProperty.call(this._store, _$rapyd$_set_keyfor(x));\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set_polyfill.prototype.values = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        var keys, s;\n        keys = Object.keys(this._store);\n        s = this._store;\n        return (function(){\n            var _$rapyd$_d = {};\n            _$rapyd$_d[\"_keys\"] = keys;\n            _$rapyd$_d[\"_i\"] = -1;\n            _$rapyd$_d[\"_s\"] = s;\n            _$rapyd$_d[_$rapyd$_iterator_symbol] = (function() {\n                var _$rapyd$_anonfunc = function () {\n                    return this;\n                };\n                return _$rapyd$_anonfunc;\n            })();\n            _$rapyd$_d[\"next\"] = (function() {\n                var _$rapyd$_anonfunc = function () {\n                    this._i += 1;\n                    if (this._i >= this._keys.length) {\n                        return {\n                            \"done\": true\n                        };\n                    }\n                    return {\n                        \"done\": false,\n                        \"value\": s[this._keys[this._i]]\n                    };\n                };\n                return _$rapyd$_anonfunc;\n            })();\n            return _$rapyd$_d;\n        })();\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\nif (typeof Set !== \"function\" || typeof Set.prototype.delete !== \"function\") {\n    _$rapyd$_set_implementation = _$rapyd$_set_polyfill;\n} else {\n    _$rapyd$_set_implementation = Set;\n}\nfunction _$rapyd$_set(iterable) {\n    var ans, s, iterator, result, keys;\n    if (this instanceof _$rapyd$_set) {\n        this.jsset = new _$rapyd$_set_implementation;\n        ans = this;\n        if (iterable === undefined) {\n            return ans;\n        }\n        s = ans.jsset;\n        if (_$rapyd$_arraylike(iterable)) {\n            for (var i = 0; i < iterable.length; i++) {\n                s.add(iterable[i]);\n            }\n        } else if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n            iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n            result = iterator.next();\n            while (!result.done) {\n                s.add(result.value);\n                result = iterator.next();\n            }\n        } else {\n            keys = Object.keys(iterable);\n            for (var j=0; j < keys.length; j++) {\n                s.add(keys[j]);\n            }\n        }\n        return ans;\n    } else {\n        return new _$rapyd$_set(iterable);\n    }\n};\n\n_$rapyd$_set.__argnames__ = [\"iterable\"];\n\n_$rapyd$_set.prototype.__name__ = \"set\";\nObject.defineProperties(_$rapyd$_set.prototype, {\n    \"length\": {\n        \"get\": (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this.jsset.size;\n            };\n            return _$rapyd$_anonfunc;\n        })()\n    },\n    \"size\": {\n        \"get\": (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this.jsset.size;\n            };\n            return _$rapyd$_anonfunc;\n        })()\n    }\n});\n_$rapyd$_set.prototype.__len__ = (function() {\n    var _$rapyd$_anonfunc = function () {\n        return this.jsset.size;\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_chain_assign_temp = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        return this.jsset.has(x);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.has = _$rapyd$_chain_assign_temp;\n_$rapyd$_set.prototype.__contains__ = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_set.prototype.add = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        this.jsset.add(x);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.clear = (function() {\n    var _$rapyd$_anonfunc = function () {\n        this.jsset.clear();\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.copy = (function() {\n    var _$rapyd$_anonfunc = function () {\n        return _$rapyd$_set(this);\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.discard = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        this.jsset.delete(x);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype[_$rapyd$_iterator_symbol] = (function() {\n    var _$rapyd$_anonfunc = function () {\n        return this.jsset.values();\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.difference = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var ans, s, iterator, r, x, has;\n        ans = new _$rapyd$_set;\n        s = ans.jsset;\n        iterator = this.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            has = false;\n            for (var i = 0; i < arguments.length; i++) {\n                if (arguments[i].has(x)) {\n                    has = true;\n                    break;\n                }\n            }\n            if (!has) {\n                s.add(x);\n            }\n            r = iterator.next();\n        }\n        return ans;\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.difference_update = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var s, remove, iterator, r, x;\n        s = this.jsset;\n        remove = [];\n        iterator = s.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            for (var i = 0; i < arguments.length; i++) {\n                if (arguments[i].has(x)) {\n                    remove.push(x);\n                    break;\n                }\n            }\n            r = iterator.next();\n        }\n        for (var j = 0; j < remove.length; j++) {\n            s.delete(remove[j]);\n        }\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.intersection = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var ans, s, iterator, r, x, has;\n        ans = new _$rapyd$_set;\n        s = ans.jsset;\n        iterator = this.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            has = true;\n            for (var i = 0; i < arguments.length; i++) {\n                if (!arguments[i].has(x)) {\n                    has = false;\n                    break;\n                }\n            }\n            if (has) {\n                s.add(x);\n            }\n            r = iterator.next();\n        }\n        return ans;\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.intersection_update = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var s, remove, iterator, r, x;\n        s = this.jsset;\n        remove = [];\n        iterator = s.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            for (var i = 0; i < arguments.length; i++) {\n                if (!arguments[i].has(x)) {\n                    remove.push(x);\n                    break;\n                }\n            }\n            r = iterator.next();\n        }\n        for (var j = 0; j < remove.length; j++) {\n            s.delete(remove[j]);\n        }\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.isdisjoint = (function() {\n    var _$rapyd$_anonfunc = function (other) {\n        var iterator, r, x;\n        iterator = this.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            if (other.has(x)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"other\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.issubset = (function() {\n    var _$rapyd$_anonfunc = function (other) {\n        var iterator, r, x;\n        iterator = this.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            if (!other.has(x)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"other\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.issuperset = (function() {\n    var _$rapyd$_anonfunc = function (other) {\n        var s, iterator, r, x;\n        s = this.jsset;\n        iterator = other.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            if (!s.has(x)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"other\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.pop = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var iterator, r;\n        iterator = this.jsset.values();\n        r = iterator.next();\n        if (r.done) {\n            throw new KeyError(\"pop from an empty set\");\n        }\n        this.jsset.delete(r.value);\n        return r.value;\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.remove = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        if (!this.jsset.delete(x)) {\n            throw new KeyError(x.toString());\n        }\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.symmetric_difference = (function() {\n    var _$rapyd$_anonfunc = function (other) {\n        return this.union(other).difference(this.intersection(other));\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"other\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.symmetric_difference_update = (function() {\n    var _$rapyd$_anonfunc = function (other) {\n        var common;\n        common = this.intersection(other);\n        this.update(other);\n        this.difference_update(common);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"other\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.union = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var ans;\n        ans = _$rapyd$_set(this);\n        ans.update.apply(ans, arguments);\n        return ans;\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.update = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var s, iterator, r;\n        s = this.jsset;\n        for (var i=0; i < arguments.length; i++) {\n            iterator = arguments[i][_$rapyd$_iterator_symbol]();\n            r = iterator.next();\n            while (!r.done) {\n                s.add(r.value);\n                r = iterator.next();\n            }\n        }\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_chain_assign_temp = (function() {\n    var _$rapyd$_anonfunc = function () {\n        return \"{\" + list(this).join(\", \") + \"}\";\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_set.prototype.toString = _$rapyd$_chain_assign_temp;\n_$rapyd$_set.prototype.inspect = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_set.prototype.__eq__ = (function() {\n    var _$rapyd$_anonfunc = function (other) {\n        var iterator, r;\n        if (!(other instanceof this.constructor)) {\n            return false;\n        }\n        if (other.size !== this.size) {\n            return false;\n        }\n        if (other.size === 0) {\n            return true;\n        }\n        iterator = other[_$rapyd$_iterator_symbol]();\n        r = iterator.next();\n        while (!r.done) {\n            if (!this.has(r.value)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"other\"];\n    return _$rapyd$_anonfunc;\n})();\nfunction _$rapyd$_set_wrap(x) {\n    var ans;\n    ans = new _$rapyd$_set;\n    ans.jsset = x;\n    return ans;\n};\n\n_$rapyd$_set_wrap.__argnames__ = [\"x\"];\n\nvar set = _$rapyd$_set, set_wrap = _$rapyd$_set_wrap;\nvar _$rapyd$_dict_implementation;\nfunction _$rapyd$_dict_polyfill() {\n    this._store = {};\n    this.size = 0;\n};\n\n_$rapyd$_dict_polyfill.prototype.set = (function() {\n    var _$rapyd$_anonfunc = function (x, value) {\n        var key;\n        key = _$rapyd$_set_keyfor(x);\n        if (!Object.hasOwnProperty.call(this._store, key)) {\n            this.size += 1;\n        }\n        this._store[key] = [x, value];\n        return this;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\", \"value\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict_polyfill.prototype.clear = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        this._store = {};\n        this.size = 0;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict_polyfill.prototype.delete = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        var key;\n        key = _$rapyd$_set_keyfor(x);\n        if (Object.hasOwnProperty.call(this._store, key)) {\n            this.size -= 1;\n            delete this._store[key];\n            return true;\n        }\n        return false;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict_polyfill.prototype.has = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        return Object.hasOwnProperty.call(this._store, _$rapyd$_set_keyfor(x));\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict_polyfill.prototype.get = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        try {\n            return this._store[_$rapyd$_set_keyfor(x)][1];\n        } catch (_$rapyd$_Exception) {\n            if (_$rapyd$_Exception instanceof TypeError) {\n                return undefined;\n            } else {\n                throw _$rapyd$_Exception;\n            }\n        }\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict_polyfill.prototype.values = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        var keys, s;\n        keys = Object.keys(this._store);\n        s = this._store;\n        return (function(){\n            var _$rapyd$_d = {};\n            _$rapyd$_d[\"_keys\"] = keys;\n            _$rapyd$_d[\"_i\"] = -1;\n            _$rapyd$_d[\"_s\"] = s;\n            _$rapyd$_d[_$rapyd$_iterator_symbol] = (function() {\n                var _$rapyd$_anonfunc = function () {\n                    return this;\n                };\n                return _$rapyd$_anonfunc;\n            })();\n            _$rapyd$_d[\"next\"] = (function() {\n                var _$rapyd$_anonfunc = function () {\n                    this._i += 1;\n                    if (this._i >= this._keys.length) {\n                        return {\n                            \"done\": true\n                        };\n                    }\n                    return {\n                        \"done\": false,\n                        \"value\": s[this._keys[this._i]][1]\n                    };\n                };\n                return _$rapyd$_anonfunc;\n            })();\n            return _$rapyd$_d;\n        })();\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict_polyfill.prototype.keys = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        var keys, s;\n        keys = Object.keys(this._store);\n        s = this._store;\n        return (function(){\n            var _$rapyd$_d = {};\n            _$rapyd$_d[\"_keys\"] = keys;\n            _$rapyd$_d[\"_i\"] = -1;\n            _$rapyd$_d[\"_s\"] = s;\n            _$rapyd$_d[_$rapyd$_iterator_symbol] = (function() {\n                var _$rapyd$_anonfunc = function () {\n                    return this;\n                };\n                return _$rapyd$_anonfunc;\n            })();\n            _$rapyd$_d[\"next\"] = (function() {\n                var _$rapyd$_anonfunc = function () {\n                    this._i += 1;\n                    if (this._i >= this._keys.length) {\n                        return {\n                            \"done\": true\n                        };\n                    }\n                    return {\n                        \"done\": false,\n                        \"value\": s[this._keys[this._i]][0]\n                    };\n                };\n                return _$rapyd$_anonfunc;\n            })();\n            return _$rapyd$_d;\n        })();\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict_polyfill.prototype.entries = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        var keys, s;\n        keys = Object.keys(this._store);\n        s = this._store;\n        return (function(){\n            var _$rapyd$_d = {};\n            _$rapyd$_d[\"_keys\"] = keys;\n            _$rapyd$_d[\"_i\"] = -1;\n            _$rapyd$_d[\"_s\"] = s;\n            _$rapyd$_d[_$rapyd$_iterator_symbol] = (function() {\n                var _$rapyd$_anonfunc = function () {\n                    return this;\n                };\n                return _$rapyd$_anonfunc;\n            })();\n            _$rapyd$_d[\"next\"] = (function() {\n                var _$rapyd$_anonfunc = function () {\n                    this._i += 1;\n                    if (this._i >= this._keys.length) {\n                        return {\n                            \"done\": true\n                        };\n                    }\n                    return {\n                        \"done\": false,\n                        \"value\": s[this._keys[this._i]]\n                    };\n                };\n                return _$rapyd$_anonfunc;\n            })();\n            return _$rapyd$_d;\n        })();\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\nif (typeof Map !== \"function\" || typeof Map.prototype.delete !== \"function\") {\n    _$rapyd$_dict_implementation = _$rapyd$_dict_polyfill;\n} else {\n    _$rapyd$_dict_implementation = Map;\n}\nfunction _$rapyd$_dict(iterable) {\n    if (this instanceof _$rapyd$_dict) {\n        this.jsmap = new _$rapyd$_dict_implementation;\n        if (iterable !== undefined) {\n            this.update(iterable);\n        }\n        return this;\n    } else {\n        return new _$rapyd$_dict(iterable);\n    }\n};\n\n_$rapyd$_dict.__argnames__ = [\"iterable\"];\n\n_$rapyd$_dict.prototype.__name__ = \"dict\";\nObject.defineProperties(_$rapyd$_dict.prototype, {\n    \"length\": {\n        \"get\": (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this.jsmap.size;\n            };\n            return _$rapyd$_anonfunc;\n        })()\n    },\n    \"size\": {\n        \"get\": (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this.jsmap.size;\n            };\n            return _$rapyd$_anonfunc;\n        })()\n    }\n});\n_$rapyd$_dict.prototype.__len__ = (function() {\n    var _$rapyd$_anonfunc = function () {\n        return this.jsmap.size;\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_chain_assign_temp = (function() {\n    var _$rapyd$_anonfunc = function (x) {\n        return this.jsmap.has(x);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"x\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.has = _$rapyd$_chain_assign_temp;\n_$rapyd$_dict.prototype.__contains__ = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_chain_assign_temp = (function() {\n    var _$rapyd$_anonfunc = function (key, value) {\n        this.jsmap.set(key, value);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"key\", \"value\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.set = _$rapyd$_chain_assign_temp;\n_$rapyd$_dict.prototype.__setitem__ = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_dict.prototype.clear = (function() {\n    var _$rapyd$_anonfunc = function () {\n        this.jsmap.clear();\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.copy = (function() {\n    var _$rapyd$_anonfunc = function () {\n        return _$rapyd$_dict(this);\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.keys = (function() {\n    var _$rapyd$_anonfunc = function () {\n        return this.jsmap.keys();\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.values = (function() {\n    var _$rapyd$_anonfunc = function () {\n        return this.jsmap.values();\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_chain_assign_temp = (function() {\n    var _$rapyd$_anonfunc = function () {\n        return this.jsmap.entries();\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.items = _$rapyd$_chain_assign_temp;\n_$rapyd$_dict.prototype.entries = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_dict.prototype[_$rapyd$_iterator_symbol] = (function() {\n    var _$rapyd$_anonfunc = function () {\n        return this.jsmap.keys();\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.__getitem__ = (function() {\n    var _$rapyd$_anonfunc = function (key) {\n        var ans;\n        ans = this.jsmap.get(key);\n        if (ans === undefined && !this.jsmap.has(key)) {\n            throw new KeyError(key + \"\");\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"key\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.get = (function() {\n    var _$rapyd$_anonfunc = function (key, defval) {\n        var ans;\n        ans = this.jsmap.get(key);\n        if (ans === undefined && !this.jsmap.has(key)) {\n            return (defval === undefined) ? null : defval;\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"key\", \"defval\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.set_default = (function() {\n    var _$rapyd$_anonfunc = function (key, defval) {\n        var j;\n        j = this.jsmap;\n        if (!j.has(key)) {\n            j.set(key, defval);\n            return defval;\n        }\n        return j.get(key);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"key\", \"defval\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_chain_assign_temp = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var iterable = ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true) ? undefined : arguments[0];\n        var value = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [_$rapyd$_kwargs_symbol] === true)) ? _$rapyd$_anonfunc.__defaults__.value : arguments[1];\n        var _$rapyd$_kwargs_obj = arguments[arguments.length-1];\n        if (_$rapyd$_kwargs_obj === null || typeof _$rapyd$_kwargs_obj !== \"object\" || _$rapyd$_kwargs_obj [_$rapyd$_kwargs_symbol] !== true) _$rapyd$_kwargs_obj = {};\n        if (Object.prototype.hasOwnProperty.call(_$rapyd$_kwargs_obj, \"value\")){\n            value = _$rapyd$_kwargs_obj.value;\n        }\n        var ans, iterator, r;\n        ans = _$rapyd$_dict();\n        iterator = iter(iterable);\n        r = iterator.next();\n        while (!r.done) {\n            ans.set(r.value, value);\n            r = iterator.next();\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__defaults__ = {\n        value:null\n    };\n\n    _$rapyd$_anonfunc.__handles_kwarg_interpolation__ = true;\n\n    _$rapyd$_anonfunc.__argnames__ = [\"iterable\", \"value\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.fromkeys = _$rapyd$_chain_assign_temp;\n_$rapyd$_dict.prototype.fromkeys = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_dict.prototype.pop = (function() {\n    var _$rapyd$_anonfunc = function (key, defval) {\n        var ans;\n        ans = this.jsmap.get(key);\n        if (ans === undefined && !this.jsmap.has(key)) {\n            if (defval === undefined) {\n                throw new KeyError(key);\n            }\n            return defval;\n        }\n        this.jsmap.delete(key);\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"key\", \"defval\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.popitem = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var r;\n        r = this.jsmap.entries().next();\n        if (r.done) {\n            throw new KeyError(\"dict is empty\");\n        }\n        this.jsmap.delete(r.value[0]);\n        return r.value;\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.update = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var m, iterable, iterator, result, keys;\n        if (arguments.length === 0) {\n            return;\n        }\n        m = this.jsmap;\n        iterable = arguments[0];\n        if (Array.isArray(iterable)) {\n            for (var i = 0; i < iterable.length; i++) {\n                m.set(iterable[i][0], iterable[i][1]);\n            }\n        } else if (iterable instanceof _$rapyd$_dict) {\n            iterator = iterable.items();\n            result = iterator.next();\n            while (!result.done) {\n                m.set(result.value[0], result.value[1]);\n                result = iterator.next();\n            }\n        } else if (typeof Map === \"function\" && iterable instanceof Map) {\n            iterator = iterable.entries();\n            result = iterator.next();\n            while (!result.done) {\n                m.set(result.value[0], result.value[1]);\n                result = iterator.next();\n            }\n        } else if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n            iterator = iterable[_$rapyd$_iterator_symbol]();\n            result = iterator.next();\n            while (!result.done) {\n                m.set(result.value[0], result.value[1]);\n                result = iterator.next();\n            }\n        } else {\n            keys = Object.keys(iterable);\n            for (var j=0; j < keys.length; j++) {\n                if (keys[j] !== _$rapyd$_iterator_symbol) {\n                    m.set(keys[j], iterable[keys[j]]);\n                }\n            }\n        }\n        if (arguments.length > 1) {\n            _$rapyd$_dict.prototype.update.call(this, arguments[1]);\n        }\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_chain_assign_temp = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var entries, iterator, r;\n        entries = [];\n        iterator = this.jsmap.entries();\n        r = iterator.next();\n        while (!r.done) {\n            entries.push(r.value[0] + \": \" + r.value[1]);\n            r = iterator.next();\n        }\n        return \"{\" + entries.join(\", \") + \"}\";\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.toString = _$rapyd$_chain_assign_temp;\n_$rapyd$_dict.prototype.inspect = _$rapyd$_chain_assign_temp;\n;\n_$rapyd$_dict.prototype.__eq__ = (function() {\n    var _$rapyd$_anonfunc = function (other) {\n        var iterator, r, x;\n        if (!(other instanceof this.constructor)) {\n            return false;\n        }\n        if (other.size !== this.size) {\n            return false;\n        }\n        if (other.size === 0) {\n            return true;\n        }\n        iterator = other.items();\n        r = iterator.next();\n        while (!r.done) {\n            x = this.jsmap.get(r.value[0]);\n            if (x === undefined && !this.jsmap.has(r.value[0]) || x !== r.value[1]) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"other\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_dict.prototype.as_object = (function() {\n    var _$rapyd$_anonfunc = function (other) {\n        var ans, iterator, r;\n        ans = {};\n        iterator = this.jsmap.entries();\n        r = iterator.next();\n        while (!r.done) {\n            ans[r.value[0]] = r.value[1];\n            r = iterator.next();\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"other\"];\n    return _$rapyd$_anonfunc;\n})();\nfunction _$rapyd$_dict_wrap(x) {\n    var ans;\n    ans = new _$rapyd$_dict;\n    ans.jsmap = x;\n    return ans;\n};\n\n_$rapyd$_dict_wrap.__argnames__ = [\"x\"];\n\nvar dict = _$rapyd$_dict, dict_wrap = _$rapyd$_dict_wrap;var Exception = Error;\nfunction AttributeError() {\n    if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n    AttributeError.prototype.__init__.apply(this, arguments);\n}\n_$rapyd$_extends(AttributeError, Error);\nAttributeError.prototype.__init__ = function __init__(msg) {\n    var self = this;\n    self.message = msg;\n    self.stack = (new Error).stack;\n};\n\nAttributeError.prototype.__init__.__argnames__ = [\"msg\"];\nAttributeError.__argnames__ = AttributeError.prototype.__init__.__argnames__;\nAttributeError.__handles_kwarg_interpolation__ = AttributeError.prototype.__init__.__handles_kwarg_interpolation__;\nAttributeError.prototype.__repr__ = function __repr__ () {\n    return \"<\" + __name__ + \".\" + \"AttributeError\" + \" #\" + this._$rapyd$_object_id + \">\";\n};\nAttributeError.prototype.__str__ = function __str__ () {\n    return this.__repr__();\n};\nAttributeError.prototype.name = \"AttributeError\";\n\nfunction IndexError() {\n    if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n    IndexError.prototype.__init__.apply(this, arguments);\n}\n_$rapyd$_extends(IndexError, Error);\nIndexError.prototype.__init__ = function __init__(msg) {\n    var self = this;\n    self.message = msg;\n    self.stack = (new Error).stack;\n};\n\nIndexError.prototype.__init__.__argnames__ = [\"msg\"];\nIndexError.__argnames__ = IndexError.prototype.__init__.__argnames__;\nIndexError.__handles_kwarg_interpolation__ = IndexError.prototype.__init__.__handles_kwarg_interpolation__;\nIndexError.prototype.__repr__ = function __repr__ () {\n    return \"<\" + __name__ + \".\" + \"IndexError\" + \" #\" + this._$rapyd$_object_id + \">\";\n};\nIndexError.prototype.__str__ = function __str__ () {\n    return this.__repr__();\n};\nIndexError.prototype.name = \"IndexError\";\n\nfunction KeyError() {\n    if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n    KeyError.prototype.__init__.apply(this, arguments);\n}\n_$rapyd$_extends(KeyError, Error);\nKeyError.prototype.__init__ = function __init__(msg) {\n    var self = this;\n    self.message = msg;\n    self.stack = (new Error).stack;\n};\n\nKeyError.prototype.__init__.__argnames__ = [\"msg\"];\nKeyError.__argnames__ = KeyError.prototype.__init__.__argnames__;\nKeyError.__handles_kwarg_interpolation__ = KeyError.prototype.__init__.__handles_kwarg_interpolation__;\nKeyError.prototype.__repr__ = function __repr__ () {\n    return \"<\" + __name__ + \".\" + \"KeyError\" + \" #\" + this._$rapyd$_object_id + \">\";\n};\nKeyError.prototype.__str__ = function __str__ () {\n    return this.__repr__();\n};\nKeyError.prototype.name = \"KeyError\";\n\nfunction ValueError() {\n    if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n    ValueError.prototype.__init__.apply(this, arguments);\n}\n_$rapyd$_extends(ValueError, Error);\nValueError.prototype.__init__ = function __init__(msg) {\n    var self = this;\n    self.message = msg;\n    self.stack = (new Error).stack;\n};\n\nValueError.prototype.__init__.__argnames__ = [\"msg\"];\nValueError.__argnames__ = ValueError.prototype.__init__.__argnames__;\nValueError.__handles_kwarg_interpolation__ = ValueError.prototype.__init__.__handles_kwarg_interpolation__;\nValueError.prototype.__repr__ = function __repr__ () {\n    return \"<\" + __name__ + \".\" + \"ValueError\" + \" #\" + this._$rapyd$_object_id + \">\";\n};\nValueError.prototype.__str__ = function __str__ () {\n    return this.__repr__();\n};\nValueError.prototype.name = \"ValueError\";\n\nfunction UnicodeDecodeError() {\n    if (this._$rapyd$_object_id === undefined) Object.defineProperty(this, \"_$rapyd$_object_id\", {\"value\":++_$rapyd$_object_counter});\n    UnicodeDecodeError.prototype.__init__.apply(this, arguments);\n}\n_$rapyd$_extends(UnicodeDecodeError, ValueError);\nUnicodeDecodeError.prototype.__init__ = function __init__ () {\n    ValueError.prototype.__init__ && ValueError.prototype.__init__.apply(this, arguments);\n};\nUnicodeDecodeError.prototype.__repr__ = function __repr__ () {\n    return \"<\" + __name__ + \".\" + \"UnicodeDecodeError\" + \" #\" + this._$rapyd$_object_id + \">\";\n};\nUnicodeDecodeError.prototype.__str__ = function __str__ () {\n    return this.__repr__();\n};\nUnicodeDecodeError.prototype.name = \"UnicodeDecodeError\";\nvar _$rapyd$_in, _$rapyd$_desugar_kwargs;\nfunction _$rapyd$_flatten(arr) {\n    var ans, value;\n    ans = _$rapyd$_list_decorate([]);\n    for (var i=0; i<arr.length; i++) {\n        value = arr[i];\n        if (Array.isArray(value)) {\n            ans = ans.concat(_$rapyd$_flatten(value));\n        } else {\n            ans.push(value);\n        }\n    }\n    return ans;\n};\n\n_$rapyd$_flatten.__argnames__ = [\"arr\"];\n\nfunction _$rapyd$_extends(child, parent) {\n    child.prototype = Object.create(parent.prototype);\n    child.prototype.constructor = child;\n};\n\n_$rapyd$_extends.__argnames__ = [\"child\", \"parent\"];\n\n_$rapyd$_in = (function() {\n    var _$rapyd$_anonfunc = function () {\n        if (typeof Map === \"function\" && typeof Set === \"function\") {\n            return (function() {\n                var _$rapyd$_anonfunc = function (val, arr) {\n                    if (typeof arr === \"string\") {\n                        return arr.indexOf(val) !== -1;\n                    }\n                    if (typeof arr.__contains__ === \"function\") {\n                        return arr.__contains__(val);\n                    }\n                    if ((arr instanceof Map || arr instanceof Set)) {\n                        return arr.has(val);\n                    }\n                    if (_$rapyd$_arraylike(arr)) {\n                        return _$rapyd$_list_contains.call(arr, val);\n                    }\n                    return Object.prototype.hasOwnProperty.call(arr, val);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"val\", \"arr\"];\n                return _$rapyd$_anonfunc;\n            })();\n        }\n        return (function() {\n            var _$rapyd$_anonfunc = function (val, arr) {\n                if (typeof arr === \"string\") {\n                    return arr.indexOf(val) !== -1;\n                }\n                if (typeof arr.__contains__ === \"function\") {\n                    return arr.__contains__(val);\n                }\n                if (_$rapyd$_arraylike(arr)) {\n                    return _$rapyd$_list_contains.call(arr, val);\n                }\n                return Object.prototype.hasOwnProperty.call(arr, val);\n            };\n\n            _$rapyd$_anonfunc.__argnames__ = [\"val\", \"arr\"];\n            return _$rapyd$_anonfunc;\n        })();\n    };\n    return _$rapyd$_anonfunc;\n})()();\nfunction _$rapyd$_Iterable(iterable) {\n    var iterator, ans, result;\n    if (_$rapyd$_arraylike(iterable)) {\n        return iterable;\n    }\n    if (typeof iterable[_$rapyd$_iterator_symbol] === \"function\") {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]();\n        ans = _$rapyd$_list_decorate([]);\n        result = iterator.next();\n        while (!result.done) {\n            ans.push(result.value);\n            result = iterator.next();\n        }\n        return ans;\n    }\n    return Object.keys(iterable);\n};\n\n_$rapyd$_Iterable.__argnames__ = [\"iterable\"];\n\n_$rapyd$_desugar_kwargs = (function() {\n    var _$rapyd$_anonfunc = function () {\n        if (typeof Object.assign === \"function\") {\n            return (function() {\n                var _$rapyd$_anonfunc = function () {\n                    var ans;\n                    ans = {};\n                    ans[_$rapyd$_kwargs_symbol] = true;\n                    for (var i = 0; i < arguments.length; i++) {\n                        Object.assign(ans, arguments[i]);\n                    }\n                    return ans;\n                };\n                return _$rapyd$_anonfunc;\n            })();\n        }\n        return (function() {\n            var _$rapyd$_anonfunc = function () {\n                var ans, keys;\n                ans = {};\n                ans[_$rapyd$_kwargs_symbol] = true;\n                for (var i = 0; i < arguments.length; i++) {\n                    keys = Object.keys(arguments[i]);\n                    for (var j = 0; j < keys.length; j++) {\n                        ans[keys[j]] = arguments[i][keys[j]];\n                    }\n                }\n                return ans;\n            };\n            return _$rapyd$_anonfunc;\n        })();\n    };\n    return _$rapyd$_anonfunc;\n})()();\nfunction _$rapyd$_interpolate_kwargs(f, supplied_args) {\n    var has_prop, kwobj, args, prop;\n    if (!f.__argnames__) {\n        return f.apply(this, supplied_args);\n    }\n    has_prop = Object.prototype.hasOwnProperty;\n    kwobj = supplied_args.pop();\n    if (f.__handles_kwarg_interpolation__) {\n        args = new Array(Math.max(supplied_args.length, f.__argnames__.length) + 1);\n        args[args.length-1] = kwobj;\n        for (var i = 0; i < args.length - 1; i++) {\n            if (i < f.__argnames__.length) {\n                prop = f.__argnames__[i];\n                if (has_prop.call(kwobj, prop)) {\n                    args[i] = kwobj[prop];\n                    delete kwobj[prop];\n                } else if (i < supplied_args.length) {\n                    args[i] = supplied_args[i];\n                }\n            } else {\n                args[i] = supplied_args[i];\n            }\n        }\n        return f.apply(this, args);\n    }\n    for (var i = 0; i < f.__argnames__.length; i++) {\n        prop = f.__argnames__[i];\n        if (has_prop.call(kwobj, prop)) {\n            supplied_args[i] = kwobj[prop];\n        }\n    }\n    return f.apply(this, supplied_args);\n};\n\n_$rapyd$_interpolate_kwargs.__argnames__ = [\"f\", \"supplied_args\"];\n\nfunction _$rapyd$_interpolate_kwargs_constructor(apply, f, supplied_args) {\n    if (apply) {\n        f.apply(this, supplied_args);\n    } else {\n        _$rapyd$_interpolate_kwargs.call(this, f, supplied_args);\n    }\n    return this;\n};\n\n_$rapyd$_interpolate_kwargs_constructor.__argnames__ = [\"apply\", \"f\", \"supplied_args\"];\n\nfunction _$rapyd$_getitem(obj, key) {\n    return (obj.__getitem__) ? obj.__getitem__(key) : obj[key];\n};\n\n_$rapyd$_getitem.__argnames__ = [\"obj\", \"key\"];\n\nfunction _$rapyd$_setitem(obj, key, val) {\n    if (obj.__setitem__) {\n        obj.__setitem__(key, val);\n    } else {\n        obj[key] = val;\n    }\n};\n\n_$rapyd$_setitem.__argnames__ = [\"obj\", \"key\", \"val\"];\nfunction sum(iterable, start) {\n    var ans, iterator, r;\n    if (Array.isArray(iterable)) {\n        return iterable.reduce((function() {\n            var _$rapyd$_anonfunc = function (prev, cur) {\n                return prev + cur;\n            };\n\n            _$rapyd$_anonfunc.__argnames__ = [\"prev\", \"cur\"];\n            return _$rapyd$_anonfunc;\n        })(), start || 0);\n    }\n    ans = start || 0;\n    iterator = iter(iterable);\n    r = iterator.next();\n    while (!r.done) {\n        ans += r.value;\n        r = iterator.next();\n    }\n    return ans;\n};\n\nsum.__argnames__ = [\"iterable\", \"start\"];\n\nfunction map() {\n    var func, iterators, args;\n    func = arguments[0];\n    iterators = new Array(arguments.length - 1);\n    args = new Array(arguments.length - 1);\n    for (var i = 1; i < arguments.length; i++) {\n        iterators[i - 1] = iter(arguments[i]);\n    }\n    return (function(){\n        var _$rapyd$_d = {};\n        _$rapyd$_d[\"_func\"] = func;\n        _$rapyd$_d[\"_iterators\"] = iterators;\n        _$rapyd$_d[\"_args\"] = args;\n        _$rapyd$_d[\"next\"] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                var r;\n                for (var i = 0; i < this._iterators.length; i++) {\n                    r = this._iterators[i].next();\n                    if (r.done) {\n                        return {\n                            \"done\": true\n                        };\n                    }\n                    this._args[i] = r.value;\n                }\n                return {\n                    \"done\": false,\n                    \"value\": this._func.apply(undefined, this._args)\n                };\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        _$rapyd$_d[_$rapyd$_iterator_symbol] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this;\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        return _$rapyd$_d;\n    })();\n};\n\nfunction filter(func_or_none, iterable) {\n    return (function(){\n        var _$rapyd$_d = {};\n        _$rapyd$_d[\"_iterator\"] = iter(iterable);\n        _$rapyd$_d[\"_func\"] = (func_or_none === null) ? bool : func_or_none;\n        _$rapyd$_d[\"next\"] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                var r;\n                r = this._iterator.next();\n                while (!r.done) {\n                    if (this._func(r.value)) {\n                        return r;\n                    }\n                    r = this._iterator.next();\n                }\n                return {\n                    \"done\": true\n                };\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        _$rapyd$_d[_$rapyd$_iterator_symbol] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this;\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        return _$rapyd$_d;\n    })();\n};\n\nfilter.__argnames__ = [\"func_or_none\", \"iterable\"];\n\nfunction zip() {\n    var iterators;\n    iterators = new Array(arguments.length);\n    for (var i = 0; i < arguments.length; i++) {\n        iterators[i] = iter(arguments[i]);\n    }\n    return (function(){\n        var _$rapyd$_d = {};\n        _$rapyd$_d[\"_iterators\"] = iterators;\n        _$rapyd$_d[\"next\"] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                var args, r;\n                args = new Array(this._iterators.length);\n                for (var i = 0; i < this._iterators.length; i++) {\n                    r = this._iterators[i].next();\n                    if (r.done) {\n                        return {\n                            \"done\": true\n                        };\n                    }\n                    args[i] = r.value;\n                }\n                return {\n                    \"done\": false,\n                    \"value\": args\n                };\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        _$rapyd$_d[_$rapyd$_iterator_symbol] = (function() {\n            var _$rapyd$_anonfunc = function () {\n                return this;\n            };\n            return _$rapyd$_anonfunc;\n        })();\n        return _$rapyd$_d;\n    })();\n};\nfunction _$rapyd$_repr_js_builtin(x, as_array) {\n    var ans, b, keys, key;\n    ans = [];\n    b = \"{}\";\n    if (as_array) {\n        b = \"[]\";\n        for (var i = 0; i < x.length; i++) {\n            ans.push(_$rapyd$_repr(x[i]));\n        }\n    } else {\n        keys = Object.keys(x);\n        for (var k = 0; k < keys.length; k++) {\n            key = keys[k];\n            ans.push(JSON.stringify(key) + \":\" + _$rapyd$_repr(x[key]));\n        }\n    }\n    return b[0] + ans.join(\", \") + b[1];\n};\n\n_$rapyd$_repr_js_builtin.__argnames__ = [\"x\", \"as_array\"];\n\nfunction _$rapyd$_repr(x) {\n    var ans, name;\n    if (x === null) {\n        return \"None\";\n    }\n    if (x === undefined) {\n        return \"undefined\";\n    }\n    ans = x;\n    if (typeof x.__repr__ === \"function\") {\n        ans = x.__repr__();\n    } else if (x === true || x === false) {\n        ans = (x) ? \"True\" : \"False\";\n    } else if (Array.isArray(x)) {\n        ans = _$rapyd$_repr_js_builtin(x, true);\n    } else if (typeof x === \"function\") {\n        ans = x.toString();\n    } else {\n        name = Object.prototype.toString.call(x).slice(8, -1);\n        if (_$rapyd$_not_equals(\"Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array\".indexOf(name), -1)) {\n            return name + \"([\" + x.map((function() {\n                var _$rapyd$_anonfunc = function (i) {\n                    return str.format(\"0x{:02x}\", i);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"i\"];\n                return _$rapyd$_anonfunc;\n            })()).join(\", \") + \"])\";\n        }\n        ans = (typeof x.toString === \"function\") ? x.toString() : x;\n        if (ans === \"[object Object]\") {\n            return _$rapyd$_repr_js_builtin(x);\n        }\n        try {\n            ans = JSON.stringify(x);\n        } catch (_$rapyd$_Exception) {\n        }\n    }\n    return ans + \"\";\n};\n\n_$rapyd$_repr.__argnames__ = [\"x\"];\n\nfunction _$rapyd$_str(x) {\n    var ans, name;\n    if (x === null) {\n        return \"None\";\n    }\n    if (x === undefined) {\n        return \"undefined\";\n    }\n    ans = x;\n    if (typeof x.__str__ === \"function\") {\n        ans = x.__str__();\n    } else if (typeof x.__repr__ === \"function\") {\n        ans = x.__repr__();\n    } else if (x === true || x === false) {\n        ans = (x) ? \"True\" : \"False\";\n    } else if (Array.isArray(x)) {\n        ans = _$rapyd$_repr_js_builtin(x, true);\n    } else if (typeof x.toString === \"function\") {\n        name = Object.prototype.toString.call(x).slice(8, -1);\n        if (_$rapyd$_not_equals(\"Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array\".indexOf(name), -1)) {\n            return name + \"([\" + x.map((function() {\n                var _$rapyd$_anonfunc = function (i) {\n                    return str.format(\"0x{:02x}\", i);\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"i\"];\n                return _$rapyd$_anonfunc;\n            })()).join(\", \") + \"])\";\n        }\n        ans = x.toString();\n        if (ans === \"[object Object]\") {\n            ans = _$rapyd$_repr_js_builtin(x);\n        }\n    }\n    return ans + \"\";\n};\n\n_$rapyd$_str.__argnames__ = [\"x\"];\n\n_$rapyd$_str.format = (function() {\n    var _$rapyd$_anonfunc = function () {\n        var template, args, kwargs, explicit, implicit, _$rapyd$_chain_assign_temp, idx, ans, pos, in_brace, markup, ch;\n        template = arguments[0];\n        if (template === undefined) {\n            throw new TypeError(\"Template is required\");\n        }\n        args = Array.prototype.slice.call(arguments, 1);\n        kwargs = {};\n        if (args.length && args[args.length-1][_$rapyd$_kwargs_symbol] !== undefined) {\n            kwargs = args[args.length-1];\n            args = args.slice(0, -1);\n        }\n        _$rapyd$_chain_assign_temp = false;\n        explicit = _$rapyd$_chain_assign_temp;\n        implicit = _$rapyd$_chain_assign_temp;\n;\n        idx = 0;\n        if (_$rapyd$_str.format._template_resolve_pat === undefined) {\n            _$rapyd$_str.format._template_resolve_pat = /[.\\[]/;\n        }\n        function resolve(arg, object) {\n            var _$rapyd$_unpack, first, key, rest, ans;\n            if (!arg) {\n                return object;\n            }\n            _$rapyd$_unpack = [arg[0], arg.slice(1)];\n            first = _$rapyd$_unpack[0];\n            arg = _$rapyd$_unpack[1];\n            key = arg.split(_$rapyd$_str.format._template_resolve_pat, 1)[0];\n            rest = arg.slice(key.length);\n            ans = (first === \"[\") ? object[key.slice(0, -1)] : getattr(object, key);\n            if (ans === undefined) {\n                throw new KeyError((first === \"[\") ? key.slice(0, -1) : key);\n            }\n            return resolve(rest, ans);\n        };\n\n        resolve.__argnames__ = [\"arg\", \"object\"];\n\n        function resolve_format_spec(format_spec) {\n            if (_$rapyd$_str.format._template_resolve_fs_pat === undefined) {\n                _$rapyd$_str.format._template_resolve_fs_pat = /[{]([a-zA-Z0-9_]+)[}]/g;\n            }\n            return format_spec.replace(_$rapyd$_str.format._template_resolve_fs_pat, (function() {\n                var _$rapyd$_anonfunc = function (match, key) {\n                    if (!Object.prototype.hasOwnProperty.call(kwargs, key)) {\n                        return \"\";\n                    }\n                    return \"\" + kwargs[key];\n                };\n\n                _$rapyd$_anonfunc.__argnames__ = [\"match\", \"key\"];\n                return _$rapyd$_anonfunc;\n            })());\n        };\n\n        resolve_format_spec.__argnames__ = [\"format_spec\"];\n\n        function apply_formatting(value, format_spec) {\n            var _$rapyd$_unpack, fill, align, sign, fhash, zeropad, width, comma, precision, ftype, is_numeric, is_int, lftype, code, exp, nval, is_positive, left, right;\n            if (format_spec.indexOf(\"{\") !== -1) {\n                format_spec = resolve_format_spec(format_spec);\n            }\n            if (_$rapyd$_str.format._template_format_pat === undefined) {\n                _$rapyd$_str.format._template_format_pat = /([^{}](?=[<>=^]))?([<>=^])?([-+\\x20])?(\\#)?(0)?(\\d+)?(,)?(?:\\.(\\d+))?([bcdeEfFgGnosxX%])?/;\n            }\n            try {\n                _$rapyd$_unpack = format_spec.match(_$rapyd$_str.format._template_format_pat).slice(1);\n                fill = _$rapyd$_unpack[0];\n                align = _$rapyd$_unpack[1];\n                sign = _$rapyd$_unpack[2];\n                fhash = _$rapyd$_unpack[3];\n                zeropad = _$rapyd$_unpack[4];\n                width = _$rapyd$_unpack[5];\n                comma = _$rapyd$_unpack[6];\n                precision = _$rapyd$_unpack[7];\n                ftype = _$rapyd$_unpack[8];\n            } catch (_$rapyd$_Exception) {\n                if (_$rapyd$_Exception instanceof TypeError) {\n                    return value;\n                } else {\n                    throw _$rapyd$_Exception;\n                }\n            }\n            if (zeropad) {\n                fill = fill || \"0\";\n                align = align || \"=\";\n            } else {\n                fill = fill || \" \";\n                align = align || \">\";\n            }\n            is_numeric = Number(value) === value;\n            is_int = is_numeric && value % 1 === 0;\n            precision = parseInt(precision, 10);\n            lftype = (ftype || \"\").toLowerCase();\n            if (ftype === \"n\") {\n                is_numeric = true;\n                if (is_int) {\n                    if (comma) {\n                        throw new ValueError(\"Cannot specify ',' with 'n'\");\n                    }\n                    value = parseInt(value, 10).toLocaleString();\n                } else {\n                    value = parseFloat(value).toLocaleString();\n                }\n            } else if (['b', 'c', 'd', 'o', 'x'].indexOf(lftype) !== -1) {\n                value = parseInt(value, 10);\n                is_numeric = true;\n                if (!isNaN(value)) {\n                    if (ftype === \"b\") {\n                        value = (value >>> 0).toString(2);\n                        if (fhash) {\n                            value = \"0b\" + value;\n                        }\n                    } else if (ftype === \"c\") {\n                        if (value > 65535) {\n                            code = value - 65536;\n                            value = String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n                        } else {\n                            value = String.fromCharCode(value);\n                        }\n                    } else if (ftype === \"d\") {\n                        if (comma) {\n                            value = value.toLocaleString(\"en-US\");\n                        } else {\n                            value = value.toString(10);\n                        }\n                    } else if (ftype === \"o\") {\n                        value = value.toString(8);\n                        if (fhash) {\n                            value = \"0o\" + value;\n                        }\n                    } else if (lftype === \"x\") {\n                        value = value.toString(16);\n                        value = (ftype === \"x\") ? value.toLowerCase() : value.toUpperCase();\n                        if (fhash) {\n                            value = \"0x\" + value;\n                        }\n                    }\n                }\n            } else if (['e','f','g','%'].indexOf(lftype) !== -1) {\n                is_numeric = true;\n                value = parseFloat(value);\n                if (lftype === \"e\") {\n                    value = value.toExponential((isNaN(precision)) ? 6 : precision);\n                    value = (ftype === \"E\") ? value.toUpperCase() : value.toLowerCase();\n                } else if (lftype === \"f\") {\n                    value = value.toFixed((isNaN(precision)) ? 6 : precision);\n                    value = (ftype === \"F\") ? value.toUpperCase() : value.toLowerCase();\n                } else if (ftype === \"%\") {\n                    value *= 100;\n                    value = value.toFixed((isNaN(precision)) ? 6 : precision) + \"%\";\n                } else if (lftype === \"g\") {\n                    if (isNaN(precision)) {\n                        precision = 6;\n                    }\n                    precision = max(1, precision);\n                    exp = parseInt(value.toExponential(precision - 1).toLowerCase().split(\"e\")[1], 10);\n                    if (-4 <= exp && exp < precision) {\n                        value = value.toFixed(precision - 1 - exp);\n                    } else {\n                        value = value.toExponential(precision - 1);\n                    }\n                    value = value.replace(/0+$/g, \"\");\n                    if (value[value.length-1] === \".\") {\n                        value = value.slice(0, -1);\n                    }\n                    if (ftype === \"G\") {\n                        value = value.toUpperCase();\n                    }\n                }\n            } else {\n                value += \"\";\n                if (!isNaN(precision)) {\n                    value = value.slice(0, precision);\n                }\n            }\n            value += \"\";\n            if (is_numeric && sign) {\n                nval = Number(value);\n                is_positive = !isNaN(nval) && nval >= 0;\n                if (is_positive && (sign === \" \" || sign === \"+\")) {\n                    value = sign + value;\n                }\n            }\n            function repeat(char, num) {\n                return (new Array(num+1)).join(char);\n            };\n\n            repeat.__argnames__ = [\"char\", \"num\"];\n\n            if (is_numeric && width && width[0] === \"0\") {\n                width = width.slice(1);\n                _$rapyd$_unpack = [\"0\", \"=\"];\n                fill = _$rapyd$_unpack[0];\n                align = _$rapyd$_unpack[1];\n            }\n            width = parseInt(width || \"-1\", 10);\n            if (isNaN(width)) {\n                throw new ValueError(\"Invalid width specification: \" + width);\n            }\n            if (fill && value.length < width) {\n                if (align === \"<\") {\n                    value = value + repeat(fill, width - value.length);\n                } else if (align === \">\") {\n                    value = repeat(fill, width - value.length) + value;\n                } else if (align === \"^\") {\n                    left = Math.floor((width - value.length) / 2);\n                    right = width - left - value.length;\n                    value = repeat(fill, left) + value + repeat(fill, right);\n                } else if (align === \"=\") {\n                    if (_$rapyd$_in(value[0], \"+- \")) {\n                        value = value[0] + repeat(fill, width - value.length) + value.slice(1);\n                    } else {\n                        value = repeat(fill, width - value.length) + value;\n                    }\n                } else {\n                    throw new ValueError(\"Unrecognized alignment: \" + align);\n                }\n            }\n            return value;\n        };\n\n        apply_formatting.__argnames__ = [\"value\", \"format_spec\"];\n\n        function parse_markup(markup) {\n            var key, transformer, format_spec, _$rapyd$_chain_assign_temp, pos, state, ch;\n            _$rapyd$_chain_assign_temp = \"\";\n            key = _$rapyd$_chain_assign_temp;\n            transformer = _$rapyd$_chain_assign_temp;\n            format_spec = _$rapyd$_chain_assign_temp;\n;\n            pos = 0;\n            state = 0;\n            while (pos < markup.length) {\n                ch = markup[pos];\n                if (state === 0) {\n                    if (ch === \"!\") {\n                        state = 1;\n                    } else if (ch === \":\") {\n                        state = 2;\n                    } else {\n                        key += ch;\n                    }\n                } else if (state === 1) {\n                    if (ch === \":\") {\n                        state = 2;\n                    } else {\n                        transformer += ch;\n                    }\n                } else {\n                    format_spec += ch;\n                }\n                pos += 1;\n            }\n            return [key, transformer, format_spec];\n        };\n\n        parse_markup.__argnames__ = [\"markup\"];\n\n        function render_markup(markup) {\n            var _$rapyd$_unpack, key, transformer, format_spec, lkey, nvalue, object, ans;\n            _$rapyd$_unpack = parse_markup(markup);\n            key = _$rapyd$_unpack[0];\n            transformer = _$rapyd$_unpack[1];\n            format_spec = _$rapyd$_unpack[2];\n            if (transformer && ['a', 'r', 's'].indexOf(transformer) === -1) {\n                throw new ValueError(\"Unknown conversion specifier: \" + transformer);\n            }\n            lkey = key.length && key.split(/[.\\[]/, 1)[0];\n            if (lkey) {\n                explicit = true;\n                if (implicit) {\n                    throw new ValueError(\"cannot switch from automatic field numbering to manual field specification\");\n                }\n                nvalue = parseInt(lkey);\n                object = (isNaN(nvalue)) ? kwargs[lkey] : args[nvalue];\n                if (object === undefined) {\n                    if (isNaN(nvalue)) {\n                        throw new KeyError(lkey);\n                    }\n                    throw new IndexError(lkey);\n                }\n                object = resolve(key.slice(lkey.length), object);\n            } else {\n                implicit = true;\n                if (explicit) {\n                    throw new ValueError(\"cannot switch from manual field specification to automatic field numbering\");\n                }\n                if (idx >= args.length) {\n                    throw new IndexError(\"Not enough arguments to match template: \" + template);\n                }\n                object = args[idx];\n                idx += 1;\n            }\n            if (typeof object === \"function\") {\n                object = object();\n            }\n            ans = \"\" + object;\n            if (format_spec) {\n                ans = apply_formatting(ans, format_spec);\n            }\n            return ans;\n        };\n\n        render_markup.__argnames__ = [\"markup\"];\n\n        ans = \"\";\n        pos = 0;\n        in_brace = 0;\n        markup = \"\";\n        while (pos < template.length) {\n            ch = template[pos];\n            if (in_brace) {\n                if (ch === \"{\") {\n                    in_brace += 1;\n                    markup += \"{\";\n                } else if (ch === \"}\") {\n                    in_brace -= 1;\n                    if (in_brace > 0) {\n                        markup += \"}\";\n                    } else {\n                        ans += render_markup(markup);\n                    }\n                } else {\n                    markup += ch;\n                }\n            } else {\n                if (ch === \"{\") {\n                    if (template[pos + 1] === \"{\") {\n                        pos += 1;\n                        ans += \"{\";\n                    } else {\n                        in_brace = 1;\n                        markup = \"\";\n                    }\n                } else {\n                    ans += ch;\n                }\n            }\n            pos += 1;\n        }\n        if (in_brace) {\n            throw new ValueError(\"expected '}' before end of string\");\n        }\n        return ans;\n    };\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.capitalize = (function() {\n    var _$rapyd$_anonfunc = function (string) {\n        if (string) {\n            string = string[0].toUpperCase() + string.slice(1).toLowerCase();\n        }\n        return string;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.center = (function() {\n    var _$rapyd$_anonfunc = function (string, width, fill) {\n        var left, right;\n        left = Math.floor((width - string.length) / 2);\n        right = width - left - string.length;\n        fill = fill || \" \";\n        return new Array(left+1).join(fill) + string + new Array(right+1).join(fill);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"width\", \"fill\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.count = (function() {\n    var _$rapyd$_anonfunc = function (string, needle, start, end) {\n        var _$rapyd$_unpack, pos, step, ans;\n        start = start || 0;\n        end = end || string.length;\n        if (start < 0 || end < 0) {\n            string = string.slice(start, end);\n            _$rapyd$_unpack = [0, string.length];\n            start = _$rapyd$_unpack[0];\n            end = _$rapyd$_unpack[1];\n        }\n        pos = start;\n        step = needle.length;\n        ans = 0;\n        while (pos !== -1) {\n            pos = string.indexOf(needle, pos);\n            if (pos !== -1) {\n                ans += 1;\n                pos += step;\n            }\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"needle\", \"start\", \"end\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.endswith = (function() {\n    var _$rapyd$_anonfunc = function (string, suffixes, start, end) {\n        var q;\n        start = start || 0;\n        if (typeof suffixes === \"string\") {\n            suffixes = [suffixes];\n        }\n        if (end !== undefined) {\n            string = string.slice(0, end);\n        }\n        for (var i = 0; i < suffixes.length; i++) {\n            q = suffixes[i];\n            if (string.indexOf(q, Math.max(start, string.length - q.length)) !== -1) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"suffixes\", \"start\", \"end\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.startswith = (function() {\n    var _$rapyd$_anonfunc = function (string, prefixes, start, end) {\n        var prefix;\n        start = start || 0;\n        if (typeof prefixes === \"string\") {\n            prefixes = [prefixes];\n        }\n        for (var i = 0; i < prefixes.length; i++) {\n            prefix = prefixes[i];\n            end = (end === undefined) ? string.length : end;\n            if (end - start >= prefix.length && prefix === string.slice(start, start + prefix.length)) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"prefixes\", \"start\", \"end\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.find = (function() {\n    var _$rapyd$_anonfunc = function (string, needle, start, end) {\n        var ans;\n        while (start < 0) {\n            start += string.length;\n        }\n        ans = string.indexOf(needle, start);\n        if (end !== undefined && ans !== -1) {\n            while (end < 0) {\n                end += string.length;\n            }\n            if (ans >= end - needle.length) {\n                return -1;\n            }\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"needle\", \"start\", \"end\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.rfind = (function() {\n    var _$rapyd$_anonfunc = function (string, needle, start, end) {\n        var ans;\n        while (end < 0) {\n            end += string.length;\n        }\n        ans = string.lastIndexOf(needle, end - 1);\n        if (start !== undefined && ans !== -1) {\n            while (start < 0) {\n                start += string.length;\n            }\n            if (ans < start) {\n                return -1;\n            }\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"needle\", \"start\", \"end\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.index = (function() {\n    var _$rapyd$_anonfunc = function (string, needle, start, end) {\n        var ans;\n        ans = _$rapyd$_str.find.apply(null, arguments);\n        if (ans === -1) {\n            throw new ValueError(\"substring not found\");\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"needle\", \"start\", \"end\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.rindex = (function() {\n    var _$rapyd$_anonfunc = function (string, needle, start, end) {\n        var ans;\n        ans = _$rapyd$_str.rfind.apply(null, arguments);\n        if (ans === -1) {\n            throw new ValueError(\"substring not found\");\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"needle\", \"start\", \"end\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.islower = (function() {\n    var _$rapyd$_anonfunc = function (string) {\n        return string.length > 0 && string.toUpperCase() !== string;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.isupper = (function() {\n    var _$rapyd$_anonfunc = function (string) {\n        return string.length > 0 && string.toLowerCase() !== string;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.isspace = (function() {\n    var _$rapyd$_anonfunc = function (string) {\n        return string.length > 0 && /^\\s+$/.test(string);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.join = (function() {\n    var _$rapyd$_anonfunc = function (string, iterable) {\n        var ans, r;\n        if (Array.isArray(iterable)) {\n            return iterable.join(string);\n        }\n        ans = \"\";\n        r = iterable.next();\n        while (!r.done) {\n            if (ans) {\n                ans += string;\n            }\n            ans += r.value;\n            r = iterable.next();\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"iterable\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.ljust = (function() {\n    var _$rapyd$_anonfunc = function (string, width, fill) {\n        if (width > string.length) {\n            fill = fill || \" \";\n            string += new Array(width - string.length + 1).join(fill);\n        }\n        return string;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"width\", \"fill\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.rjust = (function() {\n    var _$rapyd$_anonfunc = function (string, width, fill) {\n        if (width > string.length) {\n            fill = fill || \" \";\n            string = new Array(width - string.length + 1).join(fill) + string;\n        }\n        return string;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"width\", \"fill\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.lower = (function() {\n    var _$rapyd$_anonfunc = function (string) {\n        return string.toLowerCase();\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.upper = (function() {\n    var _$rapyd$_anonfunc = function (string) {\n        return string.toUpperCase();\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.lstrip = (function() {\n    var _$rapyd$_anonfunc = function (string, chars) {\n        var pos;\n        pos = 0;\n        chars = chars || _$rapyd$_str.whitespace;\n        while (chars.indexOf(string[pos]) !== -1) {\n            pos += 1;\n        }\n        if (pos) {\n            string = string.slice(pos);\n        }\n        return string;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"chars\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.rstrip = (function() {\n    var _$rapyd$_anonfunc = function (string, chars) {\n        var pos;\n        pos = string.length - 1;\n        chars = chars || _$rapyd$_str.whitespace;\n        while (chars.indexOf(string[pos]) !== -1) {\n            pos -= 1;\n        }\n        if (pos < string.length - 1) {\n            string = string.slice(0, pos + 1);\n        }\n        return string;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"chars\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.strip = (function() {\n    var _$rapyd$_anonfunc = function (string, chars) {\n        return _$rapyd$_str.lstrip(_$rapyd$_str.rstrip(string, chars), chars);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"chars\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.partition = (function() {\n    var _$rapyd$_anonfunc = function (string, sep) {\n        var idx;\n        idx = string.indexOf(sep);\n        if (idx === -1) {\n            return [string, \"\", \"\"];\n        }\n        return [string.slice(0, idx), sep, string.slice(idx + sep.length)];\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"sep\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.rpartition = (function() {\n    var _$rapyd$_anonfunc = function (string, sep) {\n        var idx;\n        idx = string.lastIndexOf(sep);\n        if (idx === -1) {\n            return [\"\", \"\", string];\n        }\n        return [string.slice(0, idx), sep, string.slice(idx + sep.length)];\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"sep\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.replace = (function() {\n    var _$rapyd$_anonfunc = function (string, old, repl, count) {\n        var pos, idx;\n        if (count === 1) {\n            return string.replace(old, repl);\n        }\n        if (count < 1) {\n            return string;\n        }\n        count = count || Number.MAX_VALUE;\n        pos = 0;\n        while (count > 0) {\n            count -= 1;\n            idx = string.indexOf(old, pos);\n            if (idx === -1) {\n                break;\n            }\n            pos = idx + repl.length;\n            string = string.slice(0, idx) + repl + string.slice(idx + old.length);\n        }\n        return string;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"old\", \"repl\", \"count\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.split = (function() {\n    var _$rapyd$_anonfunc = function (string, sep, maxsplit) {\n        var ans, extra, parts;\n        if (maxsplit === 0) {\n            return _$rapyd$_list_decorate([ string ]);\n        }\n        if (sep === undefined || sep === null) {\n            if (maxsplit > 0) {\n                ans = string.split(/(\\s+)/);\n                extra = \"\";\n                parts = [];\n                for (var i = 0; i < ans.length; i++) {\n                    if (parts.length >= maxsplit + 1) {\n                        extra += ans[i];\n                    } else if (i % 2 === 0) {\n                        parts.push(ans[i]);\n                    }\n                }\n                parts[parts.length-1] += extra;\n                ans = parts;\n            } else {\n                ans = string.split(/\\s+/);\n            }\n        } else {\n            if (sep === \"\") {\n                throw new ValueError(\"empty separator\");\n            }\n            ans = string.split(sep);\n            if (maxsplit > 0 && ans.length > maxsplit) {\n                extra = ans.slice(maxsplit).join(sep);\n                ans = ans.slice(0, maxsplit);\n                ans.push(extra);\n            }\n        }\n        return _$rapyd$_list_decorate(ans);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"sep\", \"maxsplit\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.rsplit = (function() {\n    var _$rapyd$_anonfunc = function (string, sep, maxsplit) {\n        var ans, is_space, pos, current, spc, ch, end, _$rapyd$_chain_assign_temp, idx;\n        if (!maxsplit) {\n            return _$rapyd$_str.split.call(null, string, sep, maxsplit);\n        }\n        if (sep === undefined || sep === null) {\n            if (maxsplit > 0) {\n                ans = [];\n                is_space = /\\s/;\n                pos = string.length - 1;\n                current = \"\";\n                while (pos > -1 && maxsplit > 0) {\n                    spc = false;\n                    ch = string[pos];\n                    while (pos > -1 && is_space.test(ch)) {\n                        spc = true;\n                        ch = string[--pos];\n                    }\n                    if (spc) {\n                        if (current) {\n                            ans.push(current);\n                            maxsplit -= 1;\n                        }\n                        current = ch;\n                    } else {\n                        current += ch;\n                    }\n                    pos -= 1;\n                }\n                ans.push(string.slice(0, pos + 1) + current);\n                ans.reverse();\n            } else {\n                ans = string.split(/\\s+/);\n            }\n        } else {\n            if (sep === \"\") {\n                throw new ValueError(\"empty separator\");\n            }\n            ans = [];\n            _$rapyd$_chain_assign_temp = string.length;\n            pos = _$rapyd$_chain_assign_temp;\n            end = _$rapyd$_chain_assign_temp;\n;\n            while (pos > -1 && maxsplit > 0) {\n                maxsplit -= 1;\n                idx = string.lastIndexOf(sep, pos);\n                if (idx === -1) {\n                    break;\n                }\n                ans.push(string.slice(idx + sep.length, end));\n                pos = idx - 1;\n                end = idx;\n            }\n            ans.push(string.slice(0, end));\n            ans.reverse();\n        }\n        return _$rapyd$_list_decorate(ans);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"sep\", \"maxsplit\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.splitlines = (function() {\n    var _$rapyd$_anonfunc = function (string, keepends) {\n        var parts, ans;\n        if (keepends) {\n            parts = string.split(/((?:\\r?\\n)|\\r)/);\n            ans = [];\n            for (var i = 0; i < parts.length; i++) {\n                if (i % 2 === 0) {\n                    ans.push(parts[i]);\n                } else {\n                    ans[ans.length-1] += parts[i];\n                }\n            }\n        } else {\n            ans = string.split(/(?:\\r?\\n)|\\r/);\n        }\n        return _$rapyd$_list_decorate(ans);\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"keepends\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.swapcase = (function() {\n    var _$rapyd$_anonfunc = function (string) {\n        var ans, a, b;\n        ans = new Array(string.length);\n        for (var i = 0; i < ans.length; i++) {\n            a = string[i];\n            b = a.toLowerCase();\n            if (a === b) {\n                b = a.toUpperCase();\n            }\n            ans[i] = b;\n        }\n        return ans.join(\"\");\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.zfill = (function() {\n    var _$rapyd$_anonfunc = function (string, width) {\n        if (width > string.length) {\n            string = new Array(width - string.length + 1).join(\"0\") + string;\n        }\n        return string;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"width\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.uchrs = (function() {\n    var _$rapyd$_anonfunc = function (string, with_positions) {\n        return (function(){\n            var _$rapyd$_d = {};\n            _$rapyd$_d[\"_string\"] = string;\n            _$rapyd$_d[\"_pos\"] = 0;\n            _$rapyd$_d[_$rapyd$_iterator_symbol] = (function() {\n                var _$rapyd$_anonfunc = function () {\n                    return this;\n                };\n                return _$rapyd$_anonfunc;\n            })();\n            _$rapyd$_d[\"next\"] = (function() {\n                var _$rapyd$_anonfunc = function () {\n                    var length, pos, value, ans, extra;\n                    length = this._string.length;\n                    if (this._pos >= length) {\n                        return {\n                            \"done\": true\n                        };\n                    }\n                    pos = this._pos;\n                    value = this._string.charCodeAt(this._pos++);\n                    ans = \"\\ufffd\";\n                    if (55296 <= value && value <= 56319) {\n                        if (this._pos < length) {\n                            extra = this._string.charCodeAt(this._pos++);\n                            if ((extra & 56320) === 56320) {\n                                ans = String.fromCharCode(value, extra);\n                            }\n                        }\n                    } else if ((value & 56320) !== 56320) {\n                        ans = String.fromCharCode(value);\n                    }\n                    if (with_positions) {\n                        return {\n                            \"done\": false,\n                            \"value\": _$rapyd$_list_decorate([ pos, ans ])\n                        };\n                    } else {\n                        return {\n                            \"done\": false,\n                            \"value\": ans\n                        };\n                    }\n                };\n                return _$rapyd$_anonfunc;\n            })();\n            return _$rapyd$_d;\n        })();\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"with_positions\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.uslice = (function() {\n    var _$rapyd$_anonfunc = function (string, start, end) {\n        var items, iterator, r;\n        items = [];\n        iterator = _$rapyd$_str.uchrs(string);\n        r = iterator.next();\n        while (!r.done) {\n            items.push(r.value);\n            r = iterator.next();\n        }\n        return items.slice(start || 0, (end === undefined) ? items.length : end).join(\"\");\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\", \"start\", \"end\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.ulen = (function() {\n    var _$rapyd$_anonfunc = function (string) {\n        var iterator, r, ans;\n        iterator = _$rapyd$_str.uchrs(string);\n        r = iterator.next();\n        ans = 0;\n        while (!r.done) {\n            r = iterator.next();\n            ans += 1;\n        }\n        return ans;\n    };\n\n    _$rapyd$_anonfunc.__argnames__ = [\"string\"];\n    return _$rapyd$_anonfunc;\n})();\n_$rapyd$_str.ascii_lowercase = \"abcdefghijklmnopqrstuvwxyz\";\n_$rapyd$_str.ascii_uppercase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n_$rapyd$_str.ascii_letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n_$rapyd$_str.digits = \"0123456789\";\n_$rapyd$_str.punctuation = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\n_$rapyd$_str.printable = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~ \\t\\n\\r\\u000b\\f\";\n_$rapyd$_str.whitespace = \" \\t\\n\\r\\u000b\\f\";\nvar str = _$rapyd$_str, repr = _$rapyd$_repr;","tools/web_repl.js":"/* vim:fileencoding=utf-8\n * \n * Copyright (C) 2016 Kovid Goyal <kovid at kovidgoyal.net>\n *\n * Distributed under terms of the BSD license\n */\n\"use strict\";  /*jshint node:true */\nvar vm = require('vm');\nvar embedded_compiler = require('tools/embedded_compiler.js');\n\nmodule.exports = function(compiler, baselib) {\n    var ctx = vm.createContext();\n    var LINE_CONTINUATION_CHARS = ':\\\\';\n    var find_completions = null;\n    var streaming_compiler = embedded_compiler(compiler, baselib, function(js) { return vm.runInContext(js, ctx); }, '__repl__');\n\n    return {\n        'in_block_mode': false,\n\n        'replace_print': function replace_print(write_line_func) {\n            ctx.print = function() {\n                var parts = [];\n                for (var i = 0; i < arguments.length; i++) \n                    parts.push(ctx._$rapyd$_str(arguments[i]));\n                write_line_func(parts.join(' '));\n            };\n        },\n\n        'is_input_complete': function is_input_complete(source) {\n            if (!source || !source.trim()) return false;\n            var lines = source.split('\\n');\n            var last_line = lines[lines.length - 1].trimRight();\n            if (this.in_block_mode) {\n                // In a block only exit after two blank lines\n                if (lines.length < 2) return false;\n                var second_last_line = lines[lines.length - 2].trimRight();\n                var block_ended = !!(!last_line && !second_last_line);\n                if (!block_ended) return false;\n                this.in_block_mode = false;\n                return true;\n            }\n\n            if (last_line && LINE_CONTINUATION_CHARS.indexOf(last_line.substr(last_line.length - 1)) > -1) {\n                this.in_block_mode = true;\n                return false;\n            }\n            try {\n                compiler.parse(source, {'filename': '<repl>', 'basedir': '__stdlib__'});\n            } catch(e) {\n                if (e.is_eof && e.line === lines.length && e.col > 0) {\n                    return false;\n                }\n                this.in_block_mode = false;\n                return true;\n            }\n            this.in_block_mode = false;\n            return true;\n        },\n\n        'compile': function web_repl_compile(code, filename) {\n            return streaming_compiler.compile(code, filename);\n        },\n\n        'runjs': function runjs(code) {\n            var ans = vm.runInContext(code, ctx);\n            if (ans !== undefined || ans === null) {\n                ctx._$rapyd$_repl_val = ans;\n                var q = vm.runInContext('_$rapyd$_repr(_$rapyd$_repl_val)', ctx);\n                ans = (q === 'undefined') ? ans.toString() : q;\n            }\n            return ans;\n        },\n\n        'init_completions': function init_completions(completelib) {\n            find_completions = completelib(compiler);\n        },\n\n        'find_completions': function find_completions_(line) {\n            return find_completions(line, ctx);\n        },\n\n    };\n};\n\n","tools/embedded_compiler.js":"/* vim:fileencoding=utf-8\n * \n * Copyright (C) 2016 Kovid Goyal <kovid at kovidgoyal.net>\n *\n * Distributed under terms of the BSD license\n */\n\"use strict\";  /*jshint node:true */\n\n\nmodule.exports = function(compiler, baselib, runjs, name) {\n    compiler.AST_Node.warn_function = function() {};\n    var LINE_CONTINUATION_CHARS = ':\\\\';\n    runjs = runjs || eval;\n    runjs(print_ast(compiler.parse(''), true));\n    runjs('var __name__ = \"' + (name || '__embedded__') + '\";');\n\n    function print_ast(ast, keep_baselib) {\n        var output_options = {omit_baselib:!keep_baselib, write_name:false, private_scope:false, beautify:true, js_version: 6};\n        if (keep_baselib) output_options.baselib_plain = baselib;\n        var output = new compiler.OutputStream(output_options);\n        ast.print(output);\n        return output.get();\n    }\n\n    return {\n        'toplevel': null,\n\n        'compile': function web_repl_compile(code, filename) {\n            var classes = (this.toplevel) ? this.toplevel.classes : undefined;\n            var scoped_flags = (this.toplevel) ? this.toplevel.scoped_flags: undefined;\n            this.toplevel = compiler.parse(code, {\n                'filename': filename || '<embedded>',\n                'basedir': '__stdlib__',\n                'classes': classes,\n            });\n            var ans = print_ast(this.toplevel);\n            if (classes) {\n                var exports = {};\n                var self = this;\n                this.toplevel.exports.forEach(function (name) { exports[name] = true; });\n                Object.getOwnPropertyNames(classes).forEach(function (name) {\n                    if (!exports.hasOwnProperty(name) && !self.toplevel.classes.hasOwnProperty(name))\n                        self.toplevel.classes[name] = classes[name];\n                });\n            }\n            scoped_flags = this.toplevel.scoped_flags;\n    \n            return ans;\n        },\n\n    };\n};\n\n","tools/utils.js":"/* vim:fileencoding=utf-8\n * \n * Copyright (C) 2015 Kovid Goyal <kovid at kovidgoyal.net>\n *\n * Distributed under terms of the BSD license\n */\n\"use strict\";  /*jshint node:true */\n\nvar comment_contents = /\\/\\*!?(?:\\@preserve)?[ \\t]*(?:\\r\\n|\\n)([\\s\\S]*?)(?:\\r\\n|\\n)[ \\t]*\\*\\//;\nvar colors = ['red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'];\n\nfunction ansi(code) {\n    code = code || 0;\n    return String.fromCharCode(27) + '[' + code + 'm';\n}\n\nfunction path_exists(path) {\n    var fs = require('fs');\n    try {\n        fs.statSync(path);\n        return true;\n    } catch(e) {\n        if (e.code != 'ENOENT') throw e;\n    }\n}\n\nfunction colored(string, color, bold) {\n    var prefix = [];\n    if (bold) prefix.push(ansi(1));\n    if (color) prefix.push(ansi(colors.indexOf(color) + 31));\n    return prefix.join('') + string + ansi(0);\n}\n\nfunction supports_color(stdout) {\n    stdout = stdout || process.stdout;\n\tif (stdout && !stdout.isTTY) {\n\t\treturn false;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\treturn false;\n\t}\n\n\tif ('COLORTERM' in process.env) {\n\t\treturn true;\n\t}\n\n\tif (process.env.TERM === 'dumb') {\n\t\treturn false;\n\t}\n\n\tif (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {\n\t\treturn true;\n\t}\n\n    return false;\n\n}\n\nfunction safe_colored(string) {\n    return string;\n}\n\nfunction repeat(str, num) {\n    return new Array( num + 1 ).join( str );\n}\n\nfunction generators_available() {\n    var gen;\n    try {\n        eval('gen = function *(){}'); // jshint ignore:line\n        return typeof gen === 'function' && gen.constructor.name == 'GeneratorFunction';\n    } catch(e) {\n        return false;\n    }\n}\n\nfunction wrap(lines, width) {\n\tvar ans = [];\n\tvar prev = '';\n\tlines.forEach(function (line) {\n\t\tline = prev + line;\n\t\tprev = '';\n\t\tif (line.length > width) {\n\t\t\tprev = line.substr(width);\n            if (prev) prev += ' ';\n\t\t\tline = line.substr(0, width - 1);\n\t\t\tif (line.substr(line.length - 1 !== ' ')) line += '-';\n\t\t} \n\t\tans.push(line);\n\t});\n\tif (prev) ans = ans.concat(wrap([prev]));\n\treturn ans;\n}\n\nfunction merge() {\n    // Simple merge of properties from all objects\n    var ans = {};\n    Array.prototype.slice.call(arguments).forEach(function (arg) {\n        Object.keys(arg).forEach(function(key) {\n            ans[key] = arg[key];\n        });\n    });\n    return ans;\n}\n\nfunction get_import_dirs(paths_string, ignore_env) {\n    var path = require('path');\n    var paths = [];\n    function merge(new_path) {\n        if (paths.indexOf(new_path) == -1) paths.push(new_path);\n    }\n    if (!ignore_env && process && process.env && process.env.RAPYDSCRIPT_IMPORT_PATH) {\n        process.env.RAPYDSCRIPT_IMPORT_PATH.split(path.delimiter).forEach(merge);\n    }\n    if (paths_string) paths_string.split(path.delimiter).forEach(merge);\n    return paths;\n}\n\nexports.comment_contents = comment_contents;\nexports.repeat = repeat;\nexports.wrap = wrap;\nexports.merge = merge;\nexports.colored = colored;\nexports.safe_colored = (supports_color()) ? colored : safe_colored;\nexports.generators_available = generators_available;\nexports.get_import_dirs = get_import_dirs;\nexports.path_exists = path_exists;\n","tools/completer.js":"/* vim:fileencoding=utf-8\n * \n * Copyright (C) 2016 Kovid Goyal <kovid at kovidgoyal.net>\n *\n * Distributed under terms of the BSD license\n */\n\n\nmodule.exports = function(compiler, options) {\n    \"use strict\";\n    var all_keywords = compiler.ALL_KEYWORDS.split(' ');\n    var vm = require('vm');\n    options = options || {};\n    if (!options.enum_global) options.enum_global = \"var global = Function('return this')(); Object.getOwnPropertyNames(global);\";\n\n    function global_names(ctx) {\n        try {\n            var ans = vm.runInContext(options.enum_global, ctx);\n            ans = ans.concat(all_keywords);\n            ans.sort();\n            var seen = {};\n            ans.filter(function (item) { \n                if (Object.prototype.hasOwnProperty.call(seen, item)) return false;\n                seen[item] = true;\n                return true;\n            });\n            return ans;\n        } catch(e) {\n            console.log(e.stack || e.toString());\n        }\n        return [];\n    }\n\n    function object_names(obj, prefix) {\n        if (obj === null || obj === undefined) return [];\n        var groups = [], prefix_len = prefix.length, p;\n\n        function prefix_filter(name) { return (prefix_len) ? (name.substr(0, prefix_len) === prefix) : true; }\n\n        function add(o) {\n            var items = Object.getOwnPropertyNames(o).filter(prefix_filter);\n            if (items.length) groups.push(items);\n        }\n\n        if (typeof obj === 'object' || typeof obj === 'function') {\n            add(obj);\n            p = Object.getPrototypeOf(obj);\n        } else p = obj.constructor ? obj.constructor.prototype : null; \n\n        // Walk the prototype chain\n        try {\n            var sentinel = 5;\n            while (p !== null && sentinel > 0) {\n                add(p);\n                p = Object.getPrototypeOf(p);\n                // Circular refs possible? Let's guard against that.\n                sentinel--;\n            }\n        } catch (e) {\n            // console.error(\"completion error walking prototype chain:\" + e);\n        }\n        if (!groups.length) return [];\n        var seen = {}, ans = [];\n        function uniq(name) {\n            if (Object.prototype.hasOwnProperty.call(seen, name)) return false;\n            seen[name] = true;\n            return true;\n        }\n        for (var i = 0; i < groups.length; i++) {\n            var group = groups[i];\n            group.sort();\n            ans = ans.concat(group.filter(uniq));\n            ans.push('');  // group separator\n\n        }\n        while (ans.length && ans[ans.length - 1] === '') ans.pop();\n        return ans;\n    }\n\n    function prefix_matches(prefix, items) {\n        var len = prefix.length;\n        var ans = items.filter(function(item) { return item.substr(0, len) === prefix; });\n        ans.sort();\n        return ans;\n    }\n\n    function find_completions(line, ctx) {\n        var t;\n        try {\n            t = compiler.tokenizer(line, '<repl>');\n        } catch(e) { return []; }\n        var tokens = [], token;\n        while (true) {\n            try {\n                token = t();\n            } catch (e) { return []; }\n            if (token.type === 'eof') break;\n            if (token.type === 'punc' && '(){},;:'.indexOf(token.value) > -1)\n                tokens = [];\n            tokens.push(token);\n        }\n        if (!tokens.length) {\n            // New line or trailing space\n            return [global_names(ctx), ''];\n        }\n        var last_tok = tokens[tokens.length - 1];\n        if (last_tok.value === '.' || (last_tok.type === 'name' && compiler.IDENTIFIER_PAT.test(last_tok.value))) {\n            last_tok = last_tok.value;\n            if (last_tok === '.') {\n                tokens.push({'value':''});\n                last_tok = '';\n            }\n            if (tokens.length > 1 && tokens[tokens.length - 2].value === '.') {\n                // A compound expression\n                var prefix = '', result;\n                tokens.slice(0, tokens.length - 2).forEach(function (tok) { prefix += tok.value; });\n                if (prefix) {\n                    try {\n                        result = vm.runInContext(prefix, ctx, {'displayErrors':false});\n                    } catch(e) { return []; }\n                    return [object_names(result, last_tok), last_tok];\n                }\n            } else {\n                return [prefix_matches(last_tok, global_names(ctx)), last_tok];\n            }\n        }\n        return [];\n    }\n\n    return find_completions;\n};\n","__stdlib__/aes.pyj":"# vim:fileencoding=utf-8\n# License: BSD Copyright: 2016, Kovid Goyal <kovid at kovidgoyal.net>\n\n# globals: crypto\n\n# Internal API {{{\n\ndef string_to_bytes_encoder(string):\n    return TextEncoder('utf-8').encode(string + '')\n\ndef string_to_bytes_slow(string):\n    escstr = encodeURIComponent(string)\n    binstr = escstr.replace(/%([0-9A-F]{2})/g, def(match, p1):\n        return String.fromCharCode('0x' + p1)\n    )\n    ua = Uint8Array(binstr.length)\n    Array.prototype.forEach.call(binstr, def(ch, i):\n        ua[i] = ch.charCodeAt(0)\n    )\n    return ua\n\ndef as_hex(array, sep=''):\n    num = array.BYTES_PER_ELEMENT or 1\n    fmt = '{:0' + num * 2 + 'x}'\n    return [str.format(fmt, x) for x in array].join(sep)\n\ndef bytes_to_string_decoder(bytes, offset):\n    offset = offset or 0\n    if offset:\n        bytes = bytes.subarray(offset)\n    return TextDecoder('utf-8').decode(bytes)\n\ndef bytes_to_string_slow(bytes, offset):\n    ans = v'[]'\n    i = offset or 0\n    while i < bytes.length:\n        c = bytes[i]\n        if c < 128:\n            ans.push(String.fromCharCode(c))\n            i += 1\n        elif 191 < c < 224:\n            ans.push(String.fromCharCode(((c & 0x1f) << 6) | (bytes[i + 1] & 0x3f)))\n            i += 2\n        else:\n            ans.push(String.fromCharCode(((c & 0x0f) << 12) | ((bytes[i + 1] & 0x3f) << 6) | (bytes[i + 2] & 0x3f)))\n            i += 3\n    return ans.join('')\n\nstring_to_bytes = string_to_bytes_encoder if type(TextEncoder) is 'function' else string_to_bytes_slow\nbytes_to_string = bytes_to_string_decoder if type(TextDecoder) is 'function' else bytes_to_string_slow\n\ndef increment_counter(c):\n    # c must be a Uint8Array of length 16\n    for v'var i = 15; i >= 12; i--':\n        if c[i] is 255:\n            c[i] = 0\n        else:\n            c[i] += 1\n            break\n\ndef convert_to_int32(bytes, output, offset, length):\n    offset = offset or 0\n    length = length or bytes.length\n    for v'var i = offset, j = 0; i < offset + length; i += 4, j++':\n        output[j] = (bytes[i] << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] <<  8) | bytes[i + 3]\n\ndef convert_to_int32_pad(bytes):\n    extra = bytes.length % 4\n    if extra:\n        t = Uint8Array(bytes.length + 4 - extra)\n        t.set(bytes)\n        bytes = t\n    ans = Uint32Array(bytes.length / 4)\n    convert_to_int32(bytes, ans)\n    return ans\n\nif not Uint8Array.prototype.fill:\n    Uint8Array.prototype.fill = Uint32Array.prototype.fill = def(val, start, end):\n        start = start or 0\n        if end is undefined:\n            end = this.length\n        if start < 0:\n            start += this.length\n        if end < 0:\n            end += this.length\n        for v'var i = start; i < end; i++':\n            this[i] = val\n\ndef from_64_to_32(num):\n  # convert 64-bit number to two BE Int32s\n  ans = Uint32Array(2)\n  ans[0] = (num / 0x100000000) | 0\n  ans[1] = num & 0xFFFFFFFF\n  return ans\n\n# Lookup tables for AES {{{\n# Number of rounds by keysize\nnumber_of_rounds = {16: 10, 24: 12, 32: 14}\n# Round constant words\nrcon = v'new Uint32Array([0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91])'\n\n# S-box and Inverse S-box (S is for Substitution)\nS = v'new Uint32Array([0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16])'\nSi = v'new Uint32Array([0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d])'\n\n# Transformations for encryption\nT1 = v'new Uint32Array([0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a])'\nT2 = v'new Uint32Array([0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616])'\nT3 = v'new Uint32Array([0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16])'\nT4 = v'new Uint32Array([0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c])'\n\n# Transformations for decryption\nT5 = v'new Uint32Array([0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742])'\nT6 = v'new Uint32Array([0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857])'\nT7 = v'new Uint32Array([0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8])'\nT8 = v'new Uint32Array([0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0])'\n\n# Transformations for decryption key expansion\nU1 = v'new Uint32Array([0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3])'\nU2 = v'new Uint32Array([0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697])'\nU3 = v'new Uint32Array([0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46])'\nU4 = v'new Uint32Array([0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d])'\n\n# }}}\n\nclass AES: # {{{\n\n    def __init__(self, key):\n        self.working_mem = [Uint32Array(4), Uint32Array(4)]\n        rounds = number_of_rounds[key.length]\n        if not rounds:\n            raise ValueError('invalid key size (must be length 16, 24 or 32)')\n\n        # encryption round keys\n        self._Ke = v'[]'\n\n        # decryption round keys\n        self._Kd = v'[]'\n\n        for v'var i = 0; i <= rounds; i++':\n            self._Ke.push(Uint32Array(4))\n            self._Kd.push(Uint32Array(4))\n\n        round_key_count = (rounds + 1) * 4\n        KC = key.length / 4\n\n        # convert the key into ints\n        tk = Uint32Array(KC)\n        convert_to_int32(key, tk)\n\n        # copy values into round key arrays\n        index = 0\n        for v'var i = 0; i < KC; i++':\n            index = i >> 2\n            self._Ke[index][i % 4] = tk[i]\n            self._Kd[rounds - index][i % 4] = tk[i]\n\n        # key expansion (fips-197 section 5.2)\n        rconpointer = 0\n        t = KC\n        while t < round_key_count:\n            tt = tk[KC - 1]\n            tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^\n                      (S[(tt >>  8) & 0xFF] << 16) ^\n                      (S[ tt        & 0xFF] <<  8) ^\n                       S[(tt >> 24) & 0xFF]        ^\n                      (rcon[rconpointer] << 24))\n            rconpointer += 1\n\n            # key expansion (for non-256 bit)\n            if KC != 8:\n                for v'var i = 1; i < KC; i++':\n                    tk[i] ^= tk[i - 1]\n\n            # key expansion for 256-bit keys is \"slightly different\" (fips-197)\n            else:\n                for v'var i = 1; i < (KC / 2); i++':\n                    tk[i] ^= tk[i - 1]\n                tt = tk[(KC / 2) - 1]\n\n                tk[KC / 2] ^= (S[ tt        & 0xFF]        ^\n                              (S[(tt >>  8) & 0xFF] <<  8) ^\n                              (S[(tt >> 16) & 0xFF] << 16) ^\n                              (S[(tt >> 24) & 0xFF] << 24))\n\n                for v'var i = (KC / 2) + 1; i < KC; i++':\n                    tk[i] ^= tk[i - 1]\n\n            # copy values into round key arrays\n            i = 0\n            while i < KC and t < round_key_count:\n                r = t >> 2\n                c = t % 4\n                self._Ke[r][c] = tk[i]\n                self._Kd[rounds - r][c] = tk[v'i++']\n                t += 1\n\n        # inverse-cipher-ify the decryption round key (fips-197 section 5.3)\n        for v'var r = 1; r < rounds; r++':\n            for v'var c = 0; c < 4; c++':\n                tt = self._Kd[r][c]\n                self._Kd[r][c] = (U1[(tt >> 24) & 0xFF] ^\n                                  U2[(tt >> 16) & 0xFF] ^\n                                  U3[(tt >>  8) & 0xFF] ^\n                                  U4[ tt        & 0xFF])\n\n    def _crypt(self, ciphertext, offset, encrypt):\n        if encrypt:\n            R1 = T1; R2 = T2; R3 = T3; R4 = T4\n            o1 = 1; o3 = 3\n            SB = S\n            K = self._Ke\n        else:\n            R1 = T5; R2 = T6; R3 = T7; R4 = T8\n            o1 = 3; o3 = 1\n            SB = Si\n            K = self._Kd\n        rounds = K.length - 1\n        a = self.working_mem[0]\n        t = self.working_mem[1]\n\n        # XOR plaintext with key\n        for v'var i = 0; i < 4; i++':\n            t[i] ^= K[0][i]\n\n        # apply round transforms\n        for v'var r = 1; r < rounds; r++':\n            for v'var i = 0; i < 4; i++':\n                a[i] = (R1[(t[i] >> 24) & 0xff] ^\n                        R2[(t[(i + o1) % 4] >> 16) & 0xff] ^\n                        R3[(t[(i +  2) % 4] >>  8) & 0xff] ^\n                        R4[ t[(i + o3) % 4]        & 0xff] ^\n                        K[r][i])\n            t.set(a)\n\n        # the last round is special\n        for v'var i = 0; i < 4; i++':\n            tt = K[rounds][i]\n            ciphertext[offset + 4 * i] = (SB[(t[i] >> 24) & 0xff] ^ (tt >> 24)) & 0xff\n            ciphertext[offset + 4 * i + 1] = (SB[(t[(i + o1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff\n            ciphertext[offset + 4 * i + 2] = (SB[(t[(i +  2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff\n            ciphertext[offset + 4 * i + 3] = (SB[ t[(i + o3) % 4]        & 0xff] ^  tt       ) & 0xff\n\n    def encrypt(self, plaintext, ciphertext, offset):\n        convert_to_int32(plaintext, self.working_mem[1], offset, 16)\n        return self._crypt(ciphertext, offset, True)\n\n    def encrypt32(self, plaintext, ciphertext, offset):\n        self.working_mem[1].set(plaintext)\n        return self._crypt(ciphertext, offset, True)\n\n    def decrypt(self, ciphertext, plaintext, offset):\n        convert_to_int32(ciphertext, self.working_mem[1], offset, 16)\n        return self._crypt(plaintext, offset, False)\n\n    def decrypt32(self, ciphertext, plaintext, offset):\n        self.working_mem[1].set(ciphertext)\n        return self._crypt(plaintext, offset, False)\n# }}}\n\ndef random_bytes_insecure(sz):\n    ans = Uint8Array(sz)\n    for v'var i = 0; i < sz; i++':\n        ans[i] = Math.floor(Math.random() * 256)\n    return ans\n\ndef random_bytes_secure(sz):\n    ans = Uint8Array(sz)\n    crypto.getRandomValues(ans)\n    return ans\n\nrandom_bytes = random_bytes_secure if type(crypto) is not 'undefined' and type(crypto.getRandomValues) is 'function' else random_bytes_insecure\nif random_bytes is random_bytes_insecure:\n    try:\n        noderandom = require('crypto').randomBytes\n        random_bytes = def(sz):\n            return Uint8Array(noderandom(sz))\n    except:\n        print('WARNING: Using insecure RNG for AES')\n\nclass ModeOfOperation:  # {{{\n\n    def __init__(self, key):\n        self.key = key or generate_key(32)\n        self.aes = AES(self.key)\n\n    @property\n    def key_as_js(self):\n        return typed_array_as_js(self.key)\n\n    def tag_as_bytes(self, tag):\n        if isinstance(tag, Uint8Array):\n            return tag\n        if not tag:\n            return Uint8Array(0)\n        if type(tag) is 'string':\n            return string_to_bytes(tag)\n        raise TypeError('Invalid tag, must be a string or a Uint8Array')\n# }}}\n\nclass GaloisField:  # {{{\n\n    def __init__(self, sub_key):\n        k32 = Uint32Array(4)\n        convert_to_int32(sub_key, k32, 0)\n        self.m = self.generate_hash_table(k32)\n        self.wmem = Uint32Array(4)\n\n    def power(self, x, out):\n        lsb = x[3] & 1\n        for v'var i = 3; i > 0; --i':\n            out[i] = (x[i] >>> 1) | ((x[i - 1] & 1) << 31)\n        out[0] = x[0] >>> 1\n        if lsb:\n            out[0] ^= 0xE1000000\n\n    def multiply(self, x, y):\n        z_i = Uint32Array(4)\n        v_i = Uint32Array(y)\n        for v'var i = 0; i < 128; ++i':\n            x_i = x[(i / 32) | 0] & (1 << (31 - i % 32))\n            if x_i:\n                z_i[0] ^= v_i[0]\n                z_i[1] ^= v_i[1]\n                z_i[2] ^= v_i[2]\n                z_i[3] ^= v_i[3]\n            self.power(v_i, v_i)\n        return z_i\n\n    def generate_sub_hash_table(self, mid):\n        bits = mid.length\n        size = 1 << bits\n        half = size >>> 1\n        m = Array(size)\n        m[half] = Uint32Array(mid)\n        i = half >>> 1\n        while i > 0:\n            m[i] = Uint32Array(4)\n            self.power(m[2 * i], m[i])\n            i >>= 1\n        i = 2\n        while i < half:\n            for v'var j = 1; j < i; ++j':\n                m_i = m[i]\n                m_j = m[j]\n                m[i + j] = x = Uint32Array(4)\n                for v'var c = 0; c < 4; c++':\n                    x[c] = m_i[c] ^ m_j[c]\n            i *= 2\n        m[0] = Uint32Array(4)\n        for v'i = half + 1; i < size; ++i':\n            x = m[i ^ half]\n            m[i] = y = Uint32Array(4)\n            for v'var c = 0; c < 4; c++':\n                y[c] = mid[c] ^ x[c]\n        return m\n\n    def generate_hash_table(self, key_as_int32_array):\n        bits = key_as_int32_array.length\n        multiplier = 8 / bits\n        per_int = 4 * multiplier\n        size = 16 * multiplier\n        ans = Array(size)\n        for v'var i =0; i < size; ++i':\n            tmp = Uint32Array(4)\n            idx = (i/ per_int) | 0\n            shft = ((per_int - 1 - (i % per_int)) * bits)\n            tmp[idx] = (1 << (bits - 1)) << shft\n            ans[i] = self.generate_sub_hash_table(self.multiply(tmp, key_as_int32_array))\n        return ans\n\n    def table_multiply(self, x):\n        z = Uint32Array(4)\n        for v'var i = 0; i < 32; ++i':\n            idx = (i / 8) | 0\n            x_i = (x[idx] >>> ((7 - (i % 8)) * 4)) & 0xF\n            ah = self.m[i][x_i]\n            z[0] ^= ah[0]\n            z[1] ^= ah[1]\n            z[2] ^= ah[2]\n            z[3] ^= ah[3]\n        return z\n\n    def ghash(self, x, y):\n        # Corresponds to the XOR + mult_H operation from the paper\n        z = self.wmem\n        z[0] = y[0] ^ x[0]\n        z[1] = y[1] ^ x[1]\n        z[2] = y[2] ^ x[2]\n        z[3] = y[3] ^ x[3]\n        return self.table_multiply(z)\n\n# }}}\n\n# }}}\n\ndef generate_key(sz):\n    if not number_of_rounds[sz]:\n        raise ValueError('Invalid key size, must be: 16, 24 or 32')\n    return random_bytes(sz)\n\ndef generate_tag(sz):\n    return random_bytes(sz or 32)\n\ndef typed_array_as_js(x):\n    name = x.constructor.name or 'Uint8Array'\n    return '(new ' + name + '(' + JSON.stringify(Array.prototype.slice.call(x)) + '))'\n\nclass CBC(ModeOfOperation):  # {{{\n\n    def encrypt_bytes(self, bytes, tag_bytes, iv):\n        iv = first_iv = iv or random_bytes(16)\n        mlen = bytes.length + tag_bytes.length\n        padsz = (16 - (mlen % 16)) % 16\n        inputbytes = Uint8Array(mlen + padsz)\n        if tag_bytes.length:\n            inputbytes.set(tag_bytes)\n        inputbytes.set(bytes, tag_bytes.length)\n\n        offset = 0\n        outputbytes = Uint8Array(inputbytes.length)\n        for v'var block = 0; block < inputbytes.length; block += 16':\n            if block > 0:\n                iv, offset = outputbytes, block - 16\n            for v'var i = 0; i < 16; i++':\n                inputbytes[block + i] ^= iv[offset + i]\n            self.aes.encrypt(inputbytes, outputbytes, block)\n        return {'iv':first_iv, 'cipherbytes':outputbytes}\n\n    def encrypt(self, plaintext, tag):\n        return self.encrypt_bytes(string_to_bytes(plaintext), self.tag_as_bytes(tag))\n\n    def decrypt_bytes(self, inputbytes, tag_bytes, iv):\n        offset = 0\n        outputbytes = Uint8Array(inputbytes.length)\n        for v'var block = 0; block < inputbytes.length; block += 16':\n            self.aes.decrypt(inputbytes, outputbytes, block)\n            if block > 0:\n                iv, offset = inputbytes, block - 16\n            for v'var i = 0; i < 16; i++':\n                outputbytes[block + i] ^= iv[offset + i]\n        for v'var i = 0; i < tag_bytes.length; i++':\n            if tag_bytes[i] != outputbytes[i]:\n                raise ValueError('Corrupt message')\n        outputbytes = outputbytes.subarray(tag_bytes.length)\n        return outputbytes\n\n    def decrypt(self, output_from_encrypt, tag):\n        ans = self.decrypt_bytes(output_from_encrypt.cipherbytes, self.tag_as_bytes(tag), output_from_encrypt.iv)\n        return str.rstrip(bytes_to_string(ans), '\\0')\n# }}}\n\nclass CTR(ModeOfOperation):  # {{{\n\n    # Note that this mode of operation requires the pair of (counterbytes,\n    # secret key) to always be unique, for every block. Therefore, if you are\n    # using it for bi-directional messaging it is best to use a different\n    # secret key for each direction\n\n    def __init__(self, key, iv):\n        ModeOfOperation.__init__(self, key)\n        self.wmem = Uint8Array(16)\n        self.counter_block = Uint8Array(iv or 16)\n        if self.counter_block.length != 16:\n            raise ValueError('iv must be 16 bytes long')\n        self.counter_index = 16\n\n    def _crypt(self, bytes):\n        for v'var i = 0; i < bytes.length; i++, self.counter_index++':\n            if self.counter_index is 16:\n                self.counter_index = 0\n                self.aes.encrypt(self.counter_block, self.wmem, 0)\n                increment_counter(self.counter_block)\n            bytes[i] ^= self.wmem[self.counter_index]\n        self.counter_index = 16\n\n    def encrypt(self, plaintext, tag):\n        outbytes = string_to_bytes(plaintext)\n        counterbytes = Uint8Array(self.counter_block)\n        if tag:\n            tag_bytes = self.tag_as_bytes(tag)\n            t = Uint8Array(outbytes.length + tag_bytes.length)\n            t.set(tag_bytes)\n            t.set(outbytes, tag_bytes.length)\n            outbytes = t\n        self._crypt(outbytes)\n        return {'cipherbytes':outbytes, 'counterbytes':counterbytes}\n\n    def __enter__(self):\n        self.before_index = self.counter_index\n        self.before_counter = Uint8Array(self.counter_block)\n\n    def __exit__(self):\n        self.counter_index = self.before_index\n        self.counter_block = self.before_counter\n\n    def decrypt(self, output_from_encrypt, tag):\n        b = Uint8Array(output_from_encrypt.cipherbytes)\n        with self:\n            self.counter_block = output_from_encrypt.counterbytes\n            self.counter_index = 16\n            self._crypt(b)\n        offset = 0\n        if tag:\n            tag_bytes = self.tag_as_bytes(tag)\n            for v'var i = 0; i < tag_bytes.length; i++':\n                if tag_bytes[i] != b[i]:\n                    raise ValueError('Corrupted message')\n            offset = tag_bytes.length\n        return bytes_to_string(b, offset)\n# }}}\n\nclass GCM(ModeOfOperation):  # {{{\n\n    # Note that this mode of operation requires the pair of (iv,\n    # secret key) to always be unique, for every message. Therefore, if you are\n    # using it for bi-directional messaging it is best to use a different\n    # secret key for each direction (you could also use random_key,\n    # but that has a non-zero probability of repeating keys).\n    # See http://web.cs.ucdavis.edu/~rogaway/ocb/gcm.pdf\n\n    def __init__(self, key, random_iv=False):\n        ModeOfOperation.__init__(self, key)\n        self.random_iv = random_iv\n        if not random_iv:\n            self.current_iv = Uint8Array(12)\n\n        # Generate the hash subkey\n        H = Uint8Array(16)\n        self.aes.encrypt(Uint8Array(16), H, 0)\n        self.galois = GaloisField(H)\n\n        # Working memory\n        self.J0 = Uint32Array(4)\n        self.wmem = Uint32Array(4)\n        self.byte_block = Uint8Array(16)\n\n    def increment_iv(self):\n        c = self.current_iv\n        for v'var i = 11; i >=0; i--':\n            if c[i] is 255:\n                if i is 0:\n                    raise ValueError('The GCM IV space is exhausted, cannot encrypt anymore messages with this key as doing so would cause the IV to repeat')\n                c[i] = 0\n            else:\n                c[i] += 1\n                break\n\n    def _create_j0(self, iv):\n        J0 = self.J0\n        if iv.length is 12:\n            convert_to_int32(iv, J0)\n            J0[3] = 1\n        else:\n            J0.fill(0)\n            tmp = convert_to_int32_pad(iv)\n            while tmp.length:\n                J0 = self.galois.ghash(J0, tmp)\n                tmp = tmp.subarray(4)\n            tmp = Uint32Array(4)\n            tmp.set(from_64_to_32(iv.length * 8), 2)\n            J0 = self.galois.ghash(J0, tmp)\n        return J0\n\n    def _start(self, iv, additional_data):\n        J0 = self._create_j0(iv)\n        # Generate initial counter block\n        in_block = Uint32Array(J0)\n        in_block[3] = (in_block[3] + 1) & 0xFFFFFFFF  # increment counter\n\n        # Process additional_data\n        S = Uint32Array(4)\n        overflow = additional_data.length % 16\n        for v'var i = 0; i < additional_data.length - overflow; i += 16':\n            convert_to_int32(additional_data, self.wmem, i, 16)\n            S = self.galois.ghash(S, self.wmem)\n        if overflow:\n            self.byte_block.fill(0)\n            self.byte_block.set(additional_data.subarray(additional_data.length - overflow))\n            convert_to_int32(self.byte_block, self.wmem)\n            S = self.galois.ghash(S, self.wmem)\n        return J0, in_block, S\n\n    def _finish(self, iv, J0, adata_len, S, outbytes):\n        # Mix the lengths into S\n        lengths = Uint32Array(4)\n        lengths.set(from_64_to_32(adata_len * 8))\n        lengths.set(from_64_to_32(outbytes.length * 8), 2)\n        S = self.galois.ghash(S, lengths)\n\n        # Create the tag\n        self.aes.encrypt32(J0, self.byte_block, 0)\n        convert_to_int32(self.byte_block, self.wmem)\n        tag = Uint32Array(4)\n        for v'var i = 0; i < S.length; i++':\n            tag[i] = S[i] ^ self.wmem[i]\n        return {'iv':iv, 'cipherbytes':outbytes, 'tag':tag}\n\n    def _crypt(self, iv, bytes, additional_data, decrypt):\n        ghash = self.galois.ghash.bind(self.galois)\n        outbytes = Uint8Array(bytes.length)\n        J0, in_block, S = self._start(iv, additional_data)\n        bb = self.byte_block\n        enc = self.aes.encrypt32.bind(self.aes)\n        hash_bytes = bytes if decrypt else outbytes\n\n        # Create the ciphertext, encrypting block by block\n        for v'var i = 0, counter_index = 16; i < bytes.length; i++, counter_index++':\n            if counter_index is 16:\n                # Encrypt counter and increment it\n                enc(in_block, bb, 0)\n                in_block[3] = (in_block[3] + 1) & 0xFFFFFFFF  # increment counter\n                counter_index = 0\n            # Output is XOR of encrypted counter with input\n            outbytes[i] = bytes[i] ^ bb[counter_index]\n            if counter_index is 15:\n                # We have completed a block, update the hash\n                convert_to_int32(hash_bytes, self.wmem, i - 15, 16)\n                S = ghash(S, self.wmem)\n\n        # Check if we have a last partial block\n        overflow = outbytes.length % 16\n        if overflow:\n            # partial output block\n            bb.fill(0)\n            bb.set(hash_bytes.subarray(hash_bytes.length - overflow))\n            convert_to_int32(bb, self.wmem)\n            S = ghash(S, self.wmem)\n\n        return self._finish(iv, J0, additional_data.length, S, outbytes)\n\n    def encrypt(self, plaintext, tag):\n        if self.random_iv:\n            iv = random_bytes(12)\n        else:\n            self.increment_iv()\n            iv = self.current_iv\n        return self._crypt(iv, string_to_bytes(plaintext), self.tag_as_bytes(tag), False)\n\n    def decrypt(self, output_from_encrypt, tag):\n        if output_from_encrypt.tag.length != 4:\n            raise ValueError('Corrupted message')\n        ans = self._crypt(output_from_encrypt.iv, output_from_encrypt.cipherbytes, self.tag_as_bytes(tag), True)\n        if ans.tag != output_from_encrypt.tag:\n            raise ValueError('Corrupted message')\n        return bytes_to_string(ans.cipherbytes)\n# }}}\n","__stdlib__/elementmaker.pyj":"# vim:fileencoding=utf-8\n# License: GPL v3 Copyright: 2015, Kovid Goyal <kovid at kovidgoyal.net>\n\nhtml_elements = {\n    'a', 'abbr', 'acronym', 'address', 'area',\n    'article', 'aside', 'audio', 'b', 'big', 'blockquote', 'br', 'button',\n    'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup',\n    'command', 'datagrid', 'datalist', 'dd', 'del', 'details', 'dfn',\n    'dialog', 'dir', 'div', 'dl', 'dt', 'em', 'event-source', 'fieldset',\n    'figcaption', 'figure', 'footer', 'font', 'form', 'header', 'h1',\n    'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'iframe', 'img', 'input', 'ins',\n    'keygen', 'kbd', 'label', 'legend', 'li', 'm', 'map', 'menu', 'meter',\n    'multicol', 'nav', 'nextid', 'ol', 'output', 'optgroup', 'option',\n    'p', 'pre', 'progress', 'q', 's', 'samp', 'script', 'section', 'select',\n    'small', 'sound', 'source', 'spacer', 'span', 'strike', 'strong', 'style',\n    'sub', 'sup', 'table', 'tbody', 'td', 'textarea', 'time', 'tfoot',\n    'th', 'thead', 'tr', 'tt', 'u', 'ul', 'var', 'video'\n}\n\nmathml_elements = {\n    'maction', 'math', 'merror', 'mfrac', 'mi',\n    'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom',\n    'mprescripts', 'mroot', 'mrow', 'mspace', 'msqrt', 'mstyle', 'msub',\n    'msubsup', 'msup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder',\n    'munderover', 'none'\n}\n\nsvg_elements = {\n    'a', 'animate', 'animateColor', 'animateMotion',\n    'animateTransform', 'clipPath', 'circle', 'defs', 'desc', 'ellipse',\n    'font-face', 'font-face-name', 'font-face-src', 'g', 'glyph', 'hkern',\n    'linearGradient', 'line', 'marker', 'metadata', 'missing-glyph',\n    'mpath', 'path', 'polygon', 'polyline', 'radialGradient', 'rect',\n    'set', 'stop', 'svg', 'switch', 'text', 'title', 'tspan', 'use'\n}\n\nhtml5_tags = html_elements.union(mathml_elements).union(svg_elements)\n\ndef _makeelement(tag, *args, **kwargs):\n    ans = this.createElement(tag)\n\n    for attr in kwargs:\n        vattr = str.replace(str.rstrip(attr, '_'), '_', '-')\n        val = kwargs[attr]\n        if callable(val):\n            if str.startswith(attr, 'on'):\n                attr = attr[2:]\n            ans.addEventListener(attr, val)\n        elif val is True:\n            ans.setAttribute(vattr, vattr)\n        elif val is not False:\n            ans.setAttribute(vattr, val)\n\n    for arg in args:\n        if type(arg) is 'string':\n            arg = this.createTextNode(arg)\n        ans.appendChild(arg)\n    return ans\n\ndef maker_for_document(document):\n    # Create an elementmaker to be used with the specified document\n    E = _makeelement.bind(document)\n    for tag in html5_tags:\n        Object.defineProperty(E, tag, {'value':_makeelement.bind(document, tag)})\n    return E\n\nif type(document) is 'undefined':\n    E = maker_for_document({\n        'createTextNode': def(value): return value;,\n        'createElement': def(name):\n            return  {\n                'name':name,\n                'children':[],\n                'attributes':{},\n                'setAttribute': def(name, val): this.attributes[name] = val;,\n                'appendChild': def(child): this.children.push(child);,\n            }\n    })\nelse:\n    E = maker_for_document(document)\n","__stdlib__/encodings.pyj":"# vim:fileencoding=utf-8\n# License: BSD Copyright: 2016, Kovid Goyal <kovid at kovidgoyal.net>\n\ndef base64encode(bytes):\n    # Convert an array of bytes into a base-64 encoded string\n    l = bytes.length\n    remainder = l % 3\n    main_length = l - remainder\n    encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n    ans = v'[]'\n    for v'var i = 0; i < main_length; i += 3':\n        chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]\n        ans.push(encodings[(chunk & 16515072) >> 18], encodings[(chunk & 258048) >> 12], encodings[(chunk & 4032) >> 6], encodings[chunk & 63])\n    if remainder is 1:\n        chunk = bytes[main_length]\n        ans.push(encodings[(chunk & 252) >> 2], encodings[(chunk & 3) << 4], '=', '=')\n    elif remainder is 2:\n        chunk = (bytes[main_length] << 8) | bytes[main_length + 1]\n        ans.push(encodings[(chunk & 64512) >> 10], encodings[(chunk & 1008) >> 4], encodings[(chunk & 15) << 2], '=')\n    return ans.join('')\n\ndef base64decode(string):\n    # convert the output of base64encode back into an array of bytes (Uint8Array)\n    if type(window) is not 'undefined':\n        chars = window.atob(string)\n    else:\n        chars = new Buffer(string, 'base64').toString('binary')  # noqa: undef\n    ans = Uint8Array(chars.length)\n    for i in range(ans.length):\n        ans[i] = chars.charCodeAt(i)\n    return ans\n\nutf8_decoder_table = v'''[\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 00..1f\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 20..3f\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 40..5f\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 60..7f\n  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, // 80..9f\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, // a0..bf\n  8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // c0..df\n  0xa,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x4,0x3,0x3, // e0..ef\n  0xb,0x6,0x6,0x6,0x5,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8, // f0..ff\n  0x0,0x1,0x2,0x3,0x5,0x8,0x7,0x1,0x1,0x1,0x4,0x6,0x1,0x1,0x1,0x1, // s0..s0\n  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1, // s1..s2\n  1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1, // s3..s4\n  1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,3,1,1,1,1,1,1, // s5..s6\n  1,3,1,1,1,1,1,3,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // s7..s8\n]'''\n\ndef _from_code_point(x):\n    if x <= 0xFFFF:\n        return String.fromCharCode(x)\n    x -= 0x10000\n    return String.fromCharCode((x >> 10) + 0xD800, (x % 0x400) + 0xDC00)\n\ndef utf8_decode(bytes, errors, replacement):\n    # Convert an array of UTF-8 encoded bytes into a string\n    state = 0\n    ans = v'[]'\n\n    for v'var i = 0, l = bytes.length; i < l; i++':  # noqa\n        byte = bytes[i]\n        typ = utf8_decoder_table[byte]\n        codep = (byte & 0x3f) | (codep << 6) if state is not 0 else (0xff >> typ) & (byte)\n        state = utf8_decoder_table[256 + state*16 + typ]\n        if state is 0:\n            ans.push(_from_code_point(codep))\n        elif state is 1:\n            if not errors or errors is 'strict':\n                raise UnicodeDecodeError(str.format('The byte 0x{:02x} at position {} is not valid UTF-8', byte, i))\n            elif errors is 'replace':\n                ans.push(replacement or '?')\n    return ans.join('')\n\ndef utf8_encode_js(string):\n    # Encode a string as an array of UTF-8 bytes\n    escstr = encodeURIComponent(string)\n    ans = v'[]'\n    for v'var i = 0; i < escstr.length; i++':\n        ch = escstr[i]\n        if ch is '%':\n            ans.push(parseInt(escstr[i+1:i+3], 16))\n            i += 2\n        else:\n            ans.push(ch.charCodeAt(0))\n    return Uint8Array(ans)\n\nif type(TextEncoder) is 'function':\n    _u8enc = TextEncoder('utf-8')\n    utf8_encode = _u8enc.encode.bind(_u8enc)\n    _u8enc = undefined\nelse:\n    utf8_encode = utf8_encode_js\n\ndef utf8_encode_native(string):\n    return _u8enc.encode(string)\n","__stdlib__/gettext.pyj":"# vim:fileencoding=utf-8\n# License: BSD Copyright: 2015, Kovid Goyal <kovid at kovidgoyal.net>\n\n# noqa: eol-semicolon\n\n# The Plural-Forms parser {{{\n# From: https://github.com/SlexAxton/Jed/blob/master/jed.js licensed under the WTFPL\n\nJed = {}\n\nvr'''\n  Jed.PF = {};\n\n  Jed.PF.parse = function ( p ) {\n    var plural_str = Jed.PF.extractPluralExpr( p );\n    return Jed.PF.parser.parse.call(Jed.PF.parser, plural_str);\n  };\n\n  Jed.PF.compile = function ( p ) {\n    // Handle trues and falses as 0 and 1\n    function imply( val ) {\n      return (val === true ? 1 : val ? val : 0);\n    }\n\n    var ast = Jed.PF.parse( p );\n    return function ( n ) {\n      return imply( Jed.PF.interpreter( ast )( n ) );\n    };\n  };\n\n  Jed.PF.interpreter = function ( ast ) {\n    return function ( n ) {\n      var res;\n      switch ( ast.type ) {\n        case 'GROUP':\n          return Jed.PF.interpreter( ast.expr )( n );\n        case 'TERNARY':\n          if ( Jed.PF.interpreter( ast.expr )( n ) ) {\n            return Jed.PF.interpreter( ast.truthy )( n );\n          }\n          return Jed.PF.interpreter( ast.falsey )( n );\n        case 'OR':\n          return Jed.PF.interpreter( ast.left )( n ) || Jed.PF.interpreter( ast.right )( n );\n        case 'AND':\n          return Jed.PF.interpreter( ast.left )( n ) && Jed.PF.interpreter( ast.right )( n );\n        case 'LT':\n          return Jed.PF.interpreter( ast.left )( n ) < Jed.PF.interpreter( ast.right )( n );\n        case 'GT':\n          return Jed.PF.interpreter( ast.left )( n ) > Jed.PF.interpreter( ast.right )( n );\n        case 'LTE':\n          return Jed.PF.interpreter( ast.left )( n ) <= Jed.PF.interpreter( ast.right )( n );\n        case 'GTE':\n          return Jed.PF.interpreter( ast.left )( n ) >= Jed.PF.interpreter( ast.right )( n );\n        case 'EQ':\n          return Jed.PF.interpreter( ast.left )( n ) == Jed.PF.interpreter( ast.right )( n );\n        case 'NEQ':\n          return Jed.PF.interpreter( ast.left )( n ) != Jed.PF.interpreter( ast.right )( n );\n        case 'MOD':\n          return Jed.PF.interpreter( ast.left )( n ) % Jed.PF.interpreter( ast.right )( n );\n        case 'VAR':\n          return n;\n        case 'NUM':\n          return ast.val;\n        default:\n          throw new Error(\"Invalid Token found.\");\n      }\n    };\n  };\n\n  Jed.PF.extractPluralExpr = function ( p ) {\n    // trim first\n    p = p.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n\n    if (! /;\\s*$/.test(p)) {\n      p = p.concat(';');\n    }\n\n    var nplurals_re = /nplurals\\=(\\d+);/,\n        plural_re = /plural\\=(.*);/,\n        nplurals_matches = p.match( nplurals_re ),\n        res = {},\n        plural_matches;\n\n    // Find the nplurals number\n    if ( nplurals_matches.length > 1 ) {\n      res.nplurals = nplurals_matches[1];\n    }\n    else {\n      throw new Error('nplurals not found in plural_forms string: ' + p );\n    }\n\n    // remove that data to get to the formula\n    p = p.replace( nplurals_re, \"\" );\n    plural_matches = p.match( plural_re );\n\n    if (!( plural_matches && plural_matches.length > 1 ) ) {\n      throw new Error('`plural` expression not found: ' + p);\n    }\n    return plural_matches[ 1 ];\n  };\n\n  /* Jison generated parser */\n  Jed.PF.parser = (function(){\n\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"expressions\":3,\"e\":4,\"EOF\":5,\"?\":6,\":\":7,\"||\":8,\"&&\":9,\"<\":10,\"<=\":11,\">\":12,\">=\":13,\"!=\":14,\"==\":15,\"%\":16,\"(\":17,\")\":18,\"n\":19,\"NUMBER\":20,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"EOF\",6:\"?\",7:\":\",8:\"||\",9:\"&&\",10:\"<\",11:\"<=\",12:\">\",13:\">=\",14:\"!=\",15:\"==\",16:\"%\",17:\"(\",18:\")\",19:\"n\",20:\"NUMBER\"},\nproductions_: [0,[3,2],[4,5],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,1],[4,1]],\nperformAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1: return { type : 'GROUP', expr: $$[$0-1] };\ncase 2:this.$ = { type: 'TERNARY', expr: $$[$0-4], truthy : $$[$0-2], falsey: $$[$0] };\nbreak;\ncase 3:this.$ = { type: \"OR\", left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 4:this.$ = { type: \"AND\", left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 5:this.$ = { type: 'LT', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 6:this.$ = { type: 'LTE', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 7:this.$ = { type: 'GT', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 8:this.$ = { type: 'GTE', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 9:this.$ = { type: 'NEQ', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 10:this.$ = { type: 'EQ', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 11:this.$ = { type: 'MOD', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 12:this.$ = { type: 'GROUP', expr: $$[$0-1] };\nbreak;\ncase 13:this.$ = { type: 'VAR' };\nbreak;\ncase 14:this.$ = { type: 'NUM', val: Number(yytext) };\nbreak;\n}\n},\ntable: [{3:1,4:2,17:[1,3],19:[1,4],20:[1,5]},{1:[3]},{5:[1,6],6:[1,7],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16]},{4:17,17:[1,3],19:[1,4],20:[1,5]},{5:[2,13],6:[2,13],7:[2,13],8:[2,13],9:[2,13],10:[2,13],11:[2,13],12:[2,13],13:[2,13],14:[2,13],15:[2,13],16:[2,13],18:[2,13]},{5:[2,14],6:[2,14],7:[2,14],8:[2,14],9:[2,14],10:[2,14],11:[2,14],12:[2,14],13:[2,14],14:[2,14],15:[2,14],16:[2,14],18:[2,14]},{1:[2,1]},{4:18,17:[1,3],19:[1,4],20:[1,5]},{4:19,17:[1,3],19:[1,4],20:[1,5]},{4:20,17:[1,3],19:[1,4],20:[1,5]},{4:21,17:[1,3],19:[1,4],20:[1,5]},{4:22,17:[1,3],19:[1,4],20:[1,5]},{4:23,17:[1,3],19:[1,4],20:[1,5]},{4:24,17:[1,3],19:[1,4],20:[1,5]},{4:25,17:[1,3],19:[1,4],20:[1,5]},{4:26,17:[1,3],19:[1,4],20:[1,5]},{4:27,17:[1,3],19:[1,4],20:[1,5]},{6:[1,7],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[1,28]},{6:[1,7],7:[1,29],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16]},{5:[2,3],6:[2,3],7:[2,3],8:[2,3],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[2,3]},{5:[2,4],6:[2,4],7:[2,4],8:[2,4],9:[2,4],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[2,4]},{5:[2,5],6:[2,5],7:[2,5],8:[2,5],9:[2,5],10:[2,5],11:[2,5],12:[2,5],13:[2,5],14:[2,5],15:[2,5],16:[1,16],18:[2,5]},{5:[2,6],6:[2,6],7:[2,6],8:[2,6],9:[2,6],10:[2,6],11:[2,6],12:[2,6],13:[2,6],14:[2,6],15:[2,6],16:[1,16],18:[2,6]},{5:[2,7],6:[2,7],7:[2,7],8:[2,7],9:[2,7],10:[2,7],11:[2,7],12:[2,7],13:[2,7],14:[2,7],15:[2,7],16:[1,16],18:[2,7]},{5:[2,8],6:[2,8],7:[2,8],8:[2,8],9:[2,8],10:[2,8],11:[2,8],12:[2,8],13:[2,8],14:[2,8],15:[2,8],16:[1,16],18:[2,8]},{5:[2,9],6:[2,9],7:[2,9],8:[2,9],9:[2,9],10:[2,9],11:[2,9],12:[2,9],13:[2,9],14:[2,9],15:[2,9],16:[1,16],18:[2,9]},{5:[2,10],6:[2,10],7:[2,10],8:[2,10],9:[2,10],10:[2,10],11:[2,10],12:[2,10],13:[2,10],14:[2,10],15:[2,10],16:[1,16],18:[2,10]},{5:[2,11],6:[2,11],7:[2,11],8:[2,11],9:[2,11],10:[2,11],11:[2,11],12:[2,11],13:[2,11],14:[2,11],15:[2,11],16:[2,11],18:[2,11]},{5:[2,12],6:[2,12],7:[2,12],8:[2,12],9:[2,12],10:[2,12],11:[2,12],12:[2,12],13:[2,12],14:[2,12],15:[2,12],16:[2,12],18:[2,12]},{4:30,17:[1,3],19:[1,4],20:[1,5]},{5:[2,2],6:[1,7],7:[2,2],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[2,2]}],\ndefaultActions: {6:[2,1]},\nparseError: function parseError(str, hash) {\n    throw new Error(str);\n},\nparse: function parse(input) {\n    var self = this,\n        stack = [0],\n        vstack = [null], // semantic value stack\n        lstack = [], // location stack\n        table = this.table,\n        yytext = '',\n        yylineno = 0,\n        yyleng = 0,\n        recovering = 0,\n        TERROR = 2,\n        EOF = 1;\n\n    //this.reductionCount = this.shiftCount = 0;\n\n    this.lexer.setInput(input);\n    this.lexer.yy = this.yy;\n    this.yy.lexer = this.lexer;\n    if (typeof this.lexer.yylloc == 'undefined')\n        this.lexer.yylloc = {};\n    var yyloc = this.lexer.yylloc;\n    lstack.push(yyloc);\n\n    if (typeof this.yy.parseError === 'function')\n        this.parseError = this.yy.parseError;\n\n    function popStack (n) {\n        stack.length = stack.length - 2*n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n\n    function lex() {\n        var token;\n        token = self.lexer.lex() || 1; // $end = 1\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n        return token;\n    }\n\n    var symbol, preErrorSymbol, state, action, a, r, yyval={},p,len,newState, expected, errStr;\n    while (true) {\n        // retreive state number from top of stack\n        state = stack[stack.length-1];\n\n        // use default actions if available\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || symbol === undefined)\n                symbol = lex();\n            // read action for current state and first input\n            action = table[state] && table[state][symbol];\n        }\n\n        // handle parse error\n        _handle_error:\n        if (typeof action === 'undefined' || !action.length || !action[0]) {\n\n            if (!recovering) {\n                // Report error\n                expected = [];\n                for (p in table[state]) if (this.terminals_[p] && p > 2) {\n                    expected.push(\"'\"+this.terminals_[p]+\"'\");\n                }\n                errStr = '';\n                if (this.lexer.showPosition) {\n                    errStr = 'Parse error on line '+(yylineno+1)+\":\\n\"+this.lexer.showPosition()+\"\\nExpecting \"+expected.join(', ') + \", got '\" + this.terminals_[symbol]+ \"'\";\n                } else {\n                    errStr = 'Parse error on line '+(yylineno+1)+\": Unexpected \" +\n                                  (symbol == 1 /*EOF*/ ? \"end of input\" :\n                                              (\"'\"+(this.terminals_[symbol] || symbol)+\"'\"));\n                }\n                this.parseError(errStr,\n                    {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});\n            }\n\n            // just recovered from another error\n            if (recovering == 3) {\n                if (symbol == EOF) {\n                    throw new Error(errStr || 'Parsing halted.');\n                }\n\n                // discard current lookahead and grab another\n                yyleng = this.lexer.yyleng;\n                yytext = this.lexer.yytext;\n                yylineno = this.lexer.yylineno;\n                yyloc = this.lexer.yylloc;\n                symbol = lex();\n            }\n\n            // try to recover from error\n            while (1) {\n                // check for error recovery rule in this state\n                if ((TERROR.toString()) in table[state]) {\n                    break;\n                }\n                if (state === 0) {\n                    throw new Error(errStr || 'Parsing halted.');\n                }\n                popStack(1);\n                state = stack[stack.length-1];\n            }\n\n            preErrorSymbol = symbol; // save the lookahead token\n            symbol = TERROR;         // insert generic error symbol as new lookahead\n            state = stack[stack.length-1];\n            action = table[state] && table[state][TERROR];\n            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\n        }\n\n        // this shouldn't happen, unless resolve defaults are off\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);\n        }\n\n        switch (action[0]) {\n\n            case 1: // shift\n                //this.shiftCount++;\n\n                stack.push(symbol);\n                vstack.push(this.lexer.yytext);\n                lstack.push(this.lexer.yylloc);\n                stack.push(action[1]); // push state\n                symbol = null;\n                if (!preErrorSymbol) { // normal execution/no error\n                    yyleng = this.lexer.yyleng;\n                    yytext = this.lexer.yytext;\n                    yylineno = this.lexer.yylineno;\n                    yyloc = this.lexer.yylloc;\n                    if (recovering > 0)\n                        recovering--;\n                } else { // error just occurred, resume old lookahead f/ before error\n                    symbol = preErrorSymbol;\n                    preErrorSymbol = null;\n                }\n                break;\n\n            case 2: // reduce\n                //this.reductionCount++;\n\n                len = this.productions_[action[1]][1];\n\n                // perform semantic action\n                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1\n                // default location, uses first token for firsts, last for lasts\n                yyval._$ = {\n                    first_line: lstack[lstack.length-(len||1)].first_line,\n                    last_line: lstack[lstack.length-1].last_line,\n                    first_column: lstack[lstack.length-(len||1)].first_column,\n                    last_column: lstack[lstack.length-1].last_column\n                };\n                r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n\n                if (typeof r !== 'undefined') {\n                    return r;\n                }\n\n                // pop off stack\n                if (len) {\n                    stack = stack.slice(0,-1*len*2);\n                    vstack = vstack.slice(0, -1*len);\n                    lstack = lstack.slice(0, -1*len);\n                }\n\n                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)\n                vstack.push(yyval.$);\n                lstack.push(yyval._$);\n                // goto new state = table[STATE][NONTERMINAL]\n                newState = table[stack[stack.length-2]][stack[stack.length-1]];\n                stack.push(newState);\n                break;\n\n            case 3: // accept\n                return true;\n        }\n\n    }\n\n    return true;\n}};/* Jison generated lexer */\nvar lexer = (function(){\n\nvar lexer = ({EOF:1,\nparseError:function parseError(str, hash) {\n        if (this.yy.parseError) {\n            this.yy.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\nsetInput:function (input) {\n        this._input = input;\n        this._more = this._less = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};\n        return this;\n    },\ninput:function () {\n        var ch = this._input[0];\n        this.yytext+=ch;\n        this.yyleng++;\n        this.match+=ch;\n        this.matched+=ch;\n        var lines = ch.match(/\\n/);\n        if (lines) this.yylineno++;\n        this._input = this._input.slice(1);\n        return ch;\n    },\nunput:function (ch) {\n        this._input = ch + this._input;\n        return this;\n    },\nmore:function () {\n        this._more = true;\n        return this;\n    },\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\\n/g, \"\");\n    },\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c+\"^\";\n    },\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) this.done = true;\n\n        var token,\n            match,\n            col,\n            lines;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i=0;i < rules.length; i++) {\n            match = this._input.match(this.rules[rules[i]]);\n            if (match) {\n                lines = match[0].match(/\\n.*/g);\n                if (lines) this.yylineno += lines.length;\n                this.yylloc = {first_line: this.yylloc.last_line,\n                               last_line: this.yylineno+1,\n                               first_column: this.yylloc.last_column,\n                               last_column: lines ? lines[lines.length-1].length-1 : this.yylloc.last_column + match[0].length};\n                this.yytext += match[0];\n                this.match += match[0];\n                this.matches = match;\n                this.yyleng = this.yytext.length;\n                this._more = false;\n                this._input = this._input.slice(match[0].length);\n                this.matched += match[0];\n                token = this.performAction.call(this, this.yy, this, rules[i],this.conditionStack[this.conditionStack.length-1]);\n                if (token) return token;\n                else return;\n            }\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\\n'+this.showPosition(),\n                    {text: \"\", token: null, line: this.yylineno});\n        }\n    },\nlex:function lex() {\n        var r = this.next();\n        if (typeof r !== 'undefined') {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\npopState:function popState() {\n        return this.conditionStack.pop();\n    },\n_currentRules:function _currentRules() {\n        return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;\n    },\ntopState:function () {\n        return this.conditionStack[this.conditionStack.length-2];\n    },\npushState:function begin(condition) {\n        this.begin(condition);\n    }});\nlexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\n\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:/* skip whitespace */\nbreak;\ncase 1:return 20\nbreak;\ncase 2:return 19\nbreak;\ncase 3:return 8\nbreak;\ncase 4:return 9\nbreak;\ncase 5:return 6\nbreak;\ncase 6:return 7\nbreak;\ncase 7:return 11\nbreak;\ncase 8:return 13\nbreak;\ncase 9:return 10\nbreak;\ncase 10:return 12\nbreak;\ncase 11:return 14\nbreak;\ncase 12:return 15\nbreak;\ncase 13:return 16\nbreak;\ncase 14:return 17\nbreak;\ncase 15:return 18\nbreak;\ncase 16:return 5\nbreak;\ncase 17:return 'INVALID'\nbreak;\n}\n};\nlexer.rules = [/^\\s+/,/^[0-9]+(\\.[0-9]+)?\\b/,/^n\\b/,/^\\|\\|/,/^&&/,/^\\?/,/^:/,/^<=/,/^>=/,/^</,/^>/,/^!=/,/^==/,/^%/,/^\\(/,/^\\)/,/^$/,/^./];\nlexer.conditions = {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17],\"inclusive\":true}};return lexer;})()\nparser.lexer = lexer;\nreturn parser;\n})();\n'''\nplural_forms_parser = Jed.PF\n# }}}\n\ndef _get_plural_forms_function(plural_forms_string):\n    return plural_forms_parser.compile(plural_forms_string or \"nplurals=2; plural=(n != 1);\")\n\n_gettext = def(text): return text\n\n_ngettext = def(text, plural, n): return text if n is 1 else plural\n\ndef gettext(text):\n    return _gettext(text)\n\ndef ngettext(text, plural, n):\n    return _ngettext(text, plural, n)\n\ndef install(translation_data):\n    t = new Translations(translation_data)\n    t.install()\n    return t\n\nclass Translations:\n\n    def __init__(self, translation_data):\n        translation_data = translation_data or {}\n        translation_data['func'] = _get_plural_forms_function(translation_data['plural_forms'])\n        self.translations = v'[translation_data]'\n        self.language = translation_data['language']\n\n    def add_fallback(self, fallback):\n        fallback['func'] = _get_plural_forms_function(fallback['plural_forms'])\n        self.translations.push(fallback or {})\n\n    def gettext(self, text):\n        for t in self.translations:\n            m = t['entries']\n            if Object.prototype.hasOwnProperty.call(m, text):\n                return m[text][0]\n        return text\n\n    def ngettext(self, text, plural, n):\n        for t in self.translations:\n            m = t['entries']\n            if Object.prototype.hasOwnProperty.call(m, text):\n                idx = t['func'](n)\n                return m[text][idx] or (text if n is 1 else plural)\n        return text if n is 1 else plural\n\n    def install(self):\n        nonlocal _gettext, _ngettext\n        _gettext = def ():\n            return self.gettext.apply(self, arguments)\n        _ngettext = def ():\n            return self.ngettext.apply(self, arguments)\n\n","__stdlib__/math.pyj":"###########################################################\n# RapydScript Standard Library\n# Author: Alexander Tsepkov\n# Copyright 2013 Pyjeon Software LLC\n# License: Apache License    2.0\n# This library is covered under Apache license, so that\n# you can distribute it with your RapydScript applications.\n###########################################################\n\n\n# basic implementation of Python's 'math' library\n\n# NOTE: this is only meant to aid those porting lots of Python code into RapydScript,\n# if you're writing a new RapydScript application, in most cases you probably want to\n# use JavaScript's Math module directly instead\n\n\npi = Math.PI\ne = Math.E\n\n########################################\n# Number-theoretic and representation functions\n########################################\ndef ceil(x):\n    return Math.ceil(x)\ndef copysign(x, y):\n    x = Math.abs(x)\n    if y < 0:\n        return -x\n    else:\n        return x\ndef fabs(x):\n    return Math.abs(x)\ndef factorial(x):\n    if Math.abs(int(x)) is not x:\n        raise ValueError(\"factorial() only accepts integral values\")\n    factorial.cache = []\n    r = def(n):\n        if n is 0 or n is 1:\n            return 1\n        if not factorial.cache[n]:\n            factorial.cache[n] = r(n-1) * n\n        return factorial.cache[n]\n    return r(x)\ndef floor(x):\n    return Math.floor(x)\ndef fmod(x, y):\n    # javascript's % operator isn't consistent with C fmod implementation, this function is\n    while y <= x:\n        x -= y\n    return x\ndef fsum(iterable):\n    # like Python's fsum, this method is much more resilient to rounding errors than regular sum\n    partials = []   # sorted, non-overlapping partial sums\n    for x in iterable:\n        i = 0\n        for y in partials:\n            if Math.abs(x) < Math.abs(y):\n                x, y = y, x\n            hi = x + y\n            lo = y - (hi - x)\n            if lo:\n                partials[i] = lo\n                i += 1\n            x = hi\n        #partials[i:] = [x]\n        partials.splice(i, partials.length-i, x)\n    return sum(partials)\ndef isinf(x):\n    return not isFinite(x)\ndef isnan(x):\n    return isNaN(x)\ndef modf(x):\n    m = fmod(x, 1)\n    return m, x-m\ndef trunc(x):\n    return x | 0\n\n########################################\n# Power and logarithmic functions\n########################################\ndef exp(x):\n    return Math.exp(x)\ndef expm1(x):\n    # NOTE: Math.expm1() is currently only implemented in Firefox, this provides alternative implementation\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/expm1\n    #return Math.expm1(x)\n    if Math.abs(x) < 1e-5:\n        return x + 0.5*x*x\n    else:\n        return Math.exp(x) - 1\ndef log(x, base=e):\n    return Math.log(x)/Math.log(base)\ndef log1p(x):\n    # NOTE: Math.log1p() is currently only implemented in Firefox, this provides alternative implementation\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log1p\n    # this version has been taken from http://phpjs.org/functions/log1p/\n    # admittedly it's not as accurate as MDN version, as you can see from math.log1p(1) result\n    ret = 0\n    n = 50\n    if x <= -1:\n        return Number.NEGATIVE_INFINITY\n    if x < 0 or x > 1:\n        return Math.log(1 + x)\n    for i in range(1, n):\n        if i % 2 is 0:\n            ret -= Math.pow(x, i) / i\n        else:\n            ret += Math.pow(x, i) / i\n    return ret\ndef log10(x):\n    # NOTE: Math.log10() is currently only implemented in Firefox, this provides alternative implementation\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log10\n    # I didn't find a more accurate algorithm so I'm using the basic implementation\n    return Math.log(x)/Math.LN10\ndef pow(x, y):\n    if x < 0 and int(y) is not y:\n        raise ValueError('math domain error')\n    if isnan(y) and x is 1:\n        return 1\n    return Math.pow(x, y)\ndef sqrt(x):\n    return Math.sqrt(x)\n\n########################################\n# Trigonometric functions\n########################################\ndef acos(x):        return Math.acos(x)\ndef asin(x):        return Math.asin(x)\ndef atan(x):        return Math.atan(x)\ndef atan2(y, x):    return Math.atan2(y, x)\ndef cos(x):         return Math.cos(x)\ndef sin(x):         return Math.sin(x)\ndef hypot(x, y):    return Math.sqrt(x*x + y*y)\ndef tan(x):         return Math.tan(x)\n\n########################################\n# Angular conversion\n########################################\ndef degrees(x):     return x*180/pi\ndef radians(x):     return x*pi/180\n\n########################################\n# Hyperbolic functions\n########################################\ndef acosh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/acosh\n    return Math.log(x + Math.sqrt(x*x - 1))\ndef asinh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/asinh\n    return Math.log(x + Math.sqrt(x*x + 1))\ndef atanh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atanh\n    return 0.5 * Math.log((1 + x) / (1 - x))\ndef cosh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cosh\n    return (Math.exp(x) + Math.exp(-x)) / 2\ndef sinh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sinh\n    return (Math.exp(x) - Math.exp(-x)) / 2\ndef tanh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/tanh\n    return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x))\n\n\n\n#import stdlib\n#print(math.ceil(4.2))\n#print(math.floor(4.2))\n#print(math.fabs(-6))\n#print(math.copysign(-5, 7))\n#print(math.factorial(4))\n#print(math.fmod(-1e100, 1e100))\n#\n#d = [0.9999999, 1, 2, 3]\n#print(sum(d), math.fsum(d))\n#print(math.isinf(5), math.isinf(Infinity))\n#print(math.modf(5.5))\n#print(math.trunc(2.6), math.trunc(-2.6))\n#print(math.exp(1e-5), math.expm1(1e-5))\n#print(math.log(10), math.log(10, 1000))\n#print(math.log1p(1e-15), math.log1p(1))\n#print(math.log10(1000), math.log(1000, 10))\n#print(math.pow(1, 0), math.pow(1, NaN), math.pow(0, 0), math.pow(NaN, 0), math.pow(4,3), math.pow(100, -2))\n#print(math.hypot(3,4))\n#print(math.acosh(2), math.asinh(1), math.atanh(0.5), math.cosh(1), math.cosh(-1), math.sinh(1), math.tanh(1))\n","__stdlib__/operator.pyj":"add = __add__ = def(x, y): return x + y\nsub = __sub__ = def(x, y): return x - y\nmul = __mul__ = def(x, y): return x * y\ndiv = __div__ = def(x, y): return x / y\n\nlt = __lt__ = def(x, y): return x < y\nle = __le__ = def(x, y): return x <= y\neq = __eq__ = def(x, y): return x is y\nne = __ne__ = def(x, y): return x is not y\nge = __ge__ = def(x, y): return x >= y\ngt = __gt__ = def(x, y): return x > y\n","__stdlib__/random.pyj":"###########################################################\n# RapydScript Standard Library\n# Author: Alexander Tsepkov\n# Copyright 2013 Pyjeon Software LLC\n# License: Apache License    2.0\n# This library is covered under Apache license, so that\n# you can distribute it with your RapydScript applications.\n###########################################################\n\n\n# basic implementation of Python's 'random' library\n\n# JavaScript's Math.random() does not allow seeding its random generator, to bypass that, this module implements its own\n# version that can be seeded. I decided on RC4 algorithm for this.\n\n# please don't mess with this from the outside\n\n_$rapyd$_seed_state = {\n    'key': [],\n    'key_i': 0,\n    'key_j': 0\n}\n\n_$rapyd$_get_random_byte = def():\n    _$rapyd$_seed_state.key_i = (_$rapyd$_seed_state.key_i + 1) % 256\n    _$rapyd$_seed_state.key_j = (_$rapyd$_seed_state.key_j + _$rapyd$_seed_state.key[_$rapyd$_seed_state.key_i]) % 256\n    _$rapyd$_seed_state.key[_$rapyd$_seed_state.key_i], _$rapyd$_seed_state.key[_$rapyd$_seed_state.key_j] = \\\n            _$rapyd$_seed_state.key[_$rapyd$_seed_state.key_j], _$rapyd$_seed_state.key[_$rapyd$_seed_state.key_i]\n    return _$rapyd$_seed_state.key[(_$rapyd$_seed_state.key[_$rapyd$_seed_state.key_i] + \\\n            _$rapyd$_seed_state.key[_$rapyd$_seed_state.key_j]) % 256]\n\ndef seed(x=Date().getTime()):\n    if type(x) is 'number':\n        x = x.toString()\n    elif type(x) is not 'string':\n        raise TypeError(\"unhashable type: '\" + type(x) + \"'\")\n    for i in range(256):\n        _$rapyd$_seed_state.key[i] = i\n    j = 0\n    for i in range(256):\n        j = (j + _$rapyd$_seed_state.key[i] + x.charCodeAt(i % x.length)) % 256\n        _$rapyd$_seed_state.key[i], _$rapyd$_seed_state.key[j] = _$rapyd$_seed_state.key[j], _$rapyd$_seed_state.key[i]\nseed()\n\ndef random():\n    n = 0\n    m = 1\n    for i in range(8):\n        n += _$rapyd$_get_random_byte() * m\n        m *= 256\n    return n / 18446744073709551616\n\n# unlike the python version, this DOES build a range object, feel free to reimplement\ndef randrange():\n    return choice(range.apply(this, arguments))\n\ndef randint(a, b):\n    return int(random()*(b-a+1) + a)\n\ndef uniform(a, b):\n    return random()*(b-a) + a\n\ndef choice(seq):\n    if seq.length > 0:\n        return seq[Math.floor(random()*seq.length)]\n    else:\n        raise IndexError()\n\n# uses Fisher-Yates algorithm to shuffle an array\ndef shuffle(x, random_f=random):\n    for i in range(x.length):\n        j = Math.floor(random_f() * (i+1))\n        x[i], x[j] = x[j], x[i]\n    return x\n\n# similar to shuffle, but only shuffles a subset and creates a copy\ndef sample(population, k):\n    x = population.slice()\n    for i in range(population.length-1, population.length-k-1, -1):\n        j = Math.floor(random() * (i+1))\n        x[i], x[j] = x[j], x[i]\n    return x.slice(population.length-k)\n\n\n#import stdlib\n#a = range(50)\n#random.seed(5)\n#print(random.choice(a))\n#print(random.shuffle(a))\n#print(random.randrange(10))\n#print(random.randint(1,5))\n#print(random.uniform(1,5))\n#print(random.sample(range(20),5))\n","__stdlib__/re.pyj":"# vim:fileencoding=utf-8\n# License: BSD\n# Copyright: 2015, Kovid Goyal <kovid at kovidgoyal.net>\n# Copyright: 2013, Alexander Tsepkov\n\n# globals: _$rapyd$_iterator_symbol, _$rapyd$_list_decorate\n\n# basic implementation of Python's 're' library\n\n\n# Alias DB from http://www.unicode.org/Public/8.0.0/ucd/NameAliases.txt {{{\n_ALIAS_MAP = {\"null\":0,\"nul\":0,\"start of heading\":1,\"soh\":1,\"start of text\":2,\"stx\":2,\"end of text\":3,\"etx\":3,\"end of transmission\":4,\"eot\":4,\"enquiry\":5,\"enq\":5,\"acknowledge\":6,\"ack\":6,\"alert\":7,\"bel\":7,\"backspace\":8,\"bs\":8,\"character tabulation\":9,\"horizontal tabulation\":9,\"ht\":9,\"tab\":9,\"line feed\":10,\"new line\":10,\"end of line\":10,\"lf\":10,\"nl\":10,\"eol\":10,\"line tabulation\":11,\"vertical tabulation\":11,\"vt\":11,\"form feed\":12,\"ff\":12,\"carriage return\":13,\"cr\":13,\"shift out\":14,\"locking-shift one\":14,\"so\":14,\"shift in\":15,\"locking-shift zero\":15,\"si\":15,\"data link escape\":16,\"dle\":16,\"device control one\":17,\"dc1\":17,\"device control two\":18,\"dc2\":18,\"device control three\":19,\"dc3\":19,\"device control four\":20,\"dc4\":20,\"negative acknowledge\":21,\"nak\":21,\"synchronous idle\":22,\"syn\":22,\"end of transmission block\":23,\"etb\":23,\"cancel\":24,\"can\":24,\"end of medium\":25,\"eom\":25,\"substitute\":26,\"sub\":26,\"escape\":27,\"esc\":27,\"information separator four\":28,\"file separator\":28,\"fs\":28,\"information separator three\":29,\"group separator\":29,\"gs\":29,\"information separator two\":30,\"record separator\":30,\"rs\":30,\"information separator one\":31,\"unit separator\":31,\"us\":31,\"sp\":32,\"delete\":127,\"del\":127,\"padding character\":128,\"pad\":128,\"high octet preset\":129,\"hop\":129,\"break permitted here\":130,\"bph\":130,\"no break here\":131,\"nbh\":131,\"index\":132,\"ind\":132,\"next line\":133,\"nel\":133,\"start of selected area\":134,\"ssa\":134,\"end of selected area\":135,\"esa\":135,\"character tabulation set\":136,\"horizontal tabulation set\":136,\"hts\":136,\"character tabulation with justification\":137,\"horizontal tabulation with justification\":137,\"htj\":137,\"line tabulation set\":138,\"vertical tabulation set\":138,\"vts\":138,\"partial line forward\":139,\"partial line down\":139,\"pld\":139,\"partial line backward\":140,\"partial line up\":140,\"plu\":140,\"reverse line feed\":141,\"reverse index\":141,\"ri\":141,\"single shift two\":142,\"single-shift-2\":142,\"ss2\":142,\"single shift three\":143,\"single-shift-3\":143,\"ss3\":143,\"device control string\":144,\"dcs\":144,\"private use one\":145,\"private use-1\":145,\"pu1\":145,\"private use two\":146,\"private use-2\":146,\"pu2\":146,\"set transmit state\":147,\"sts\":147,\"cancel character\":148,\"cch\":148,\"message waiting\":149,\"mw\":149,\"start of guarded area\":150,\"start of protected area\":150,\"spa\":150,\"end of guarded area\":151,\"end of protected area\":151,\"epa\":151,\"start of string\":152,\"sos\":152,\"single graphic character introducer\":153,\"sgc\":153,\"single character introducer\":154,\"sci\":154,\"control sequence introducer\":155,\"csi\":155,\"string terminator\":156,\"st\":156,\"operating system command\":157,\"osc\":157,\"privacy message\":158,\"pm\":158,\"application program command\":159,\"apc\":159,\"nbsp\":160,\"shy\":173,\"latin capital letter gha\":418,\"latin small letter gha\":419,\"cgj\":847,\"alm\":1564,\"syriac sublinear colon skewed left\":1801,\"kannada letter llla\":3294,\"lao letter fo fon\":3741,\"lao letter fo fay\":3743,\"lao letter ro\":3747,\"lao letter lo\":3749,\"tibetan mark bka- shog gi mgo rgyan\":4048,\"fvs1\":6155,\"fvs2\":6156,\"fvs3\":6157,\"mvs\":6158,\"zwsp\":8203,\"zwnj\":8204,\"zwj\":8205,\"lrm\":8206,\"rlm\":8207,\"lre\":8234,\"rle\":8235,\"pdf\":8236,\"lro\":8237,\"rlo\":8238,\"nnbsp\":8239,\"mmsp\":8287,\"wj\":8288,\"lri\":8294,\"rli\":8295,\"fsi\":8296,\"pdi\":8297,\"weierstrass elliptic function\":8472,\"micr on us symbol\":9288,\"micr dash symbol\":9289,\"leftwards triangle-headed arrow with double vertical stroke\":11130,\"rightwards triangle-headed arrow with double vertical stroke\":11132,\"yi syllable iteration mark\":40981,\"presentation form for vertical right white lenticular bracket\":65048,\"vs1\":65024,\"vs2\":65025,\"vs3\":65026,\"vs4\":65027,\"vs5\":65028,\"vs6\":65029,\"vs7\":65030,\"vs8\":65031,\"vs9\":65032,\"vs10\":65033,\"vs11\":65034,\"vs12\":65035,\"vs13\":65036,\"vs14\":65037,\"vs15\":65038,\"vs16\":65039,\"byte order mark\":65279,\"bom\":65279,\"zwnbsp\":65279,\"cuneiform sign nu11 tenu\":74452,\"cuneiform sign nu11 over nu11 bur over bur\":74453,\"byzantine musical symbol fthora skliron chroma vasis\":118981,\"vs17\":917760,\"vs18\":917761,\"vs19\":917762,\"vs20\":917763,\"vs21\":917764,\"vs22\":917765,\"vs23\":917766,\"vs24\":917767,\"vs25\":917768,\"vs26\":917769,\"vs27\":917770,\"vs28\":917771,\"vs29\":917772,\"vs30\":917773,\"vs31\":917774,\"vs32\":917775,\"vs33\":917776,\"vs34\":917777,\"vs35\":917778,\"vs36\":917779,\"vs37\":917780,\"vs38\":917781,\"vs39\":917782,\"vs40\":917783,\"vs41\":917784,\"vs42\":917785,\"vs43\":917786,\"vs44\":917787,\"vs45\":917788,\"vs46\":917789,\"vs47\":917790,\"vs48\":917791,\"vs49\":917792,\"vs50\":917793,\"vs51\":917794,\"vs52\":917795,\"vs53\":917796,\"vs54\":917797,\"vs55\":917798,\"vs56\":917799,\"vs57\":917800,\"vs58\":917801,\"vs59\":917802,\"vs60\":917803,\"vs61\":917804,\"vs62\":917805,\"vs63\":917806,\"vs64\":917807,\"vs65\":917808,\"vs66\":917809,\"vs67\":917810,\"vs68\":917811,\"vs69\":917812,\"vs70\":917813,\"vs71\":917814,\"vs72\":917815,\"vs73\":917816,\"vs74\":917817,\"vs75\":917818,\"vs76\":917819,\"vs77\":917820,\"vs78\":917821,\"vs79\":917822,\"vs80\":917823,\"vs81\":917824,\"vs82\":917825,\"vs83\":917826,\"vs84\":917827,\"vs85\":917828,\"vs86\":917829,\"vs87\":917830,\"vs88\":917831,\"vs89\":917832,\"vs90\":917833,\"vs91\":917834,\"vs92\":917835,\"vs93\":917836,\"vs94\":917837,\"vs95\":917838,\"vs96\":917839,\"vs97\":917840,\"vs98\":917841,\"vs99\":917842,\"vs100\":917843,\"vs101\":917844,\"vs102\":917845,\"vs103\":917846,\"vs104\":917847,\"vs105\":917848,\"vs106\":917849,\"vs107\":917850,\"vs108\":917851,\"vs109\":917852,\"vs110\":917853,\"vs111\":917854,\"vs112\":917855,\"vs113\":917856,\"vs114\":917857,\"vs115\":917858,\"vs116\":917859,\"vs117\":917860,\"vs118\":917861,\"vs119\":917862,\"vs120\":917863,\"vs121\":917864,\"vs122\":917865,\"vs123\":917866,\"vs124\":917867,\"vs125\":917868,\"vs126\":917869,\"vs127\":917870,\"vs128\":917871,\"vs129\":917872,\"vs130\":917873,\"vs131\":917874,\"vs132\":917875,\"vs133\":917876,\"vs134\":917877,\"vs135\":917878,\"vs136\":917879,\"vs137\":917880,\"vs138\":917881,\"vs139\":917882,\"vs140\":917883,\"vs141\":917884,\"vs142\":917885,\"vs143\":917886,\"vs144\":917887,\"vs145\":917888,\"vs146\":917889,\"vs147\":917890,\"vs148\":917891,\"vs149\":917892,\"vs150\":917893,\"vs151\":917894,\"vs152\":917895,\"vs153\":917896,\"vs154\":917897,\"vs155\":917898,\"vs156\":917899,\"vs157\":917900,\"vs158\":917901,\"vs159\":917902,\"vs160\":917903,\"vs161\":917904,\"vs162\":917905,\"vs163\":917906,\"vs164\":917907,\"vs165\":917908,\"vs166\":917909,\"vs167\":917910,\"vs168\":917911,\"vs169\":917912,\"vs170\":917913,\"vs171\":917914,\"vs172\":917915,\"vs173\":917916,\"vs174\":917917,\"vs175\":917918,\"vs176\":917919,\"vs177\":917920,\"vs178\":917921,\"vs179\":917922,\"vs180\":917923,\"vs181\":917924,\"vs182\":917925,\"vs183\":917926,\"vs184\":917927,\"vs185\":917928,\"vs186\":917929,\"vs187\":917930,\"vs188\":917931,\"vs189\":917932,\"vs190\":917933,\"vs191\":917934,\"vs192\":917935,\"vs193\":917936,\"vs194\":917937,\"vs195\":917938,\"vs196\":917939,\"vs197\":917940,\"vs198\":917941,\"vs199\":917942,\"vs200\":917943,\"vs201\":917944,\"vs202\":917945,\"vs203\":917946,\"vs204\":917947,\"vs205\":917948,\"vs206\":917949,\"vs207\":917950,\"vs208\":917951,\"vs209\":917952,\"vs210\":917953,\"vs211\":917954,\"vs212\":917955,\"vs213\":917956,\"vs214\":917957,\"vs215\":917958,\"vs216\":917959,\"vs217\":917960,\"vs218\":917961,\"vs219\":917962,\"vs220\":917963,\"vs221\":917964,\"vs222\":917965,\"vs223\":917966,\"vs224\":917967,\"vs225\":917968,\"vs226\":917969,\"vs227\":917970,\"vs228\":917971,\"vs229\":917972,\"vs230\":917973,\"vs231\":917974,\"vs232\":917975,\"vs233\":917976,\"vs234\":917977,\"vs235\":917978,\"vs236\":917979,\"vs237\":917980,\"vs238\":917981,\"vs239\":917982,\"vs240\":917983,\"vs241\":917984,\"vs242\":917985,\"vs243\":917986,\"vs244\":917987,\"vs245\":917988,\"vs246\":917989,\"vs247\":917990,\"vs248\":917991,\"vs249\":917992,\"vs250\":917993,\"vs251\":917994,\"vs252\":917995,\"vs253\":917996,\"vs254\":917997,\"vs255\":917998,\"vs256\":917999}\n# }}}\n\n_ASCII_CONTROL_CHARS = {'a':7, 'b':8, 'f': 12, 'n': 10, 'r': 13, 't': 9, 'v': 11}\n_HEX_PAT = /^[a-fA-F0-9]/\n_NUM_PAT =  /^[0-9]/\n_GROUP_PAT = /<([^>]+)>/\n_NAME_PAT = /^[a-zA-Z ]/\n\nI = IGNORECASE = 2\nL = LOCALE = 4\nM = MULTILINE = 8\nD = DOTALL = 16\nU = UNICODE = 32\nX = VERBOSE = 64\nDEBUG = 128\nA = ASCII = 256\n\nsupports_unicode = RegExp.prototype.unicode is not undefined\n\n_RE_ESCAPE = /[-\\/\\\\^$*+?.()|[\\]{}]/g\n\n_re_cache_map = {}\n_re_cache_items = v'[]'\n\nerror = SyntaxError  # This is the error JS throws for invalid regexps\n\ndef _expand(groups, repl, group_name_map):\n    i = 0\n\n    def next():\n        nonlocal i\n        return v'repl[i++]'\n\n    def peek():\n        return repl[i]\n\n    def read_digits(count, pat, base, maxval, prefix):\n        ans = prefix or ''\n        greedy = count is Number.MAX_VALUE\n        while count > 0:\n            count -= 1\n            if not pat.test(peek()):\n                if greedy:\n                    break\n                return ans\n            ans += next()\n        nval = parseInt(ans, base)\n        if nval > maxval:\n            return ans\n        return nval\n\n    def read_escape_sequence():\n        nonlocal i\n        q = next()\n        if not q or q is '\\\\':\n            return '\\\\'\n        if '\"\\''.indexOf(q) is not -1:\n            return q\n        if _ASCII_CONTROL_CHARS.hasOwnProperty(q):\n            return String.fromCharCode(_ASCII_CONTROL_CHARS[q])\n        if '0' <= q <= '9':\n            ans = read_digits(Number.MAX_VALUE, _NUM_PAT, 10, Number.MAX_VALUE, q)\n            if type(ans) is 'number':\n                return groups[ans] or ''\n            return '\\\\' + ans\n        if q is 'g':\n            m = _GROUP_PAT.exec(repl[i:])\n            if m is not None:\n                i += m[0].length\n                gn = m[1]\n                if isNaN(parseInt(gn, 10)):\n                    if not Object.prototype.hasOwnProperty.call(group_name_map, gn):\n                        return ''\n                    gn = group_name_map[gn][-1]\n                return groups[gn] or ''\n        if q is 'x':\n            code = read_digits(2, _HEX_PAT, 16, 0x10FFFF)\n            if type(code) is 'number':\n                return String.fromCharCode(code)\n            return '\\\\x' + code\n        if q is 'u':\n            code = read_digits(4, _HEX_PAT, 16, 0x10FFFF)\n            if type(code) is 'number':\n                return String.fromCharCode(code)\n            return '\\\\u' + code\n        if q is 'U':\n            code = read_digits(8, _HEX_PAT, 16, 0x10FFFF)\n            if type(code) is 'number':\n                if code <= 0xFFFF:\n                    return String.fromCharCode(code)\n                code -= 0x10000\n                return String.fromCharCode(0xD800+(code>>10), 0xDC00+(code&0x3FF))\n            return '\\\\U' + code\n        if q is 'N' and peek() is '{':\n            next()\n            name = ''\n            while _NAME_PAT.test(peek()):\n                name += next()\n            if peek() is not '}':\n                return '\\\\N{' + name\n            next()\n            key = (name or '').toLowerCase()\n            if not name or not Object.prototype.hasOwnProperty.call(_ALIAS_MAP, key):\n                return '\\\\N{' + name + '}'\n            code = _ALIAS_MAP[key]\n            if code <= 0xFFFF:\n                return String.fromCharCode(code)\n            code -= 0x10000\n            return String.fromCharCode(0xD800+(code>>10), 0xDC00+(code&0x3FF))\n\n        return '\\\\' + q\n\n    ans = ch = ''\n    while (ch = next()):\n        if ch is '\\\\':\n            ans += read_escape_sequence()\n        else:\n            ans += ch\n    return ans\n\ndef transform_regex(source, flags):\n    pos = 0\n    previous_backslash = in_class = False\n    ans = ''\n    group_map = {}\n    flags = flags or 0\n    group_count = 0\n\n    while pos < source.length:\n        ch = v'source[pos++]'\n        if previous_backslash:\n            ans += '\\\\' + ch\n            previous_backslash = False\n            continue\n\n        if in_class:\n            if ch is ']':\n                in_class = False\n            ans += ch\n            continue\n\n        if ch is '\\\\':\n            previous_backslash = True\n            continue\n\n        if ch is '[':\n            in_class = True\n            if source[pos] is ']':  # in python the empty set is not allowed, instead []] is the same as [\\]]\n                pos += 1\n                ch = r'[\\]'\n        elif ch is '(':\n            if source[pos] is '?':\n                extension = source[pos + 1]\n                if extension is '#':\n                    close = source.indexOf(')', pos + 1)\n                    if close is -1:\n                        raise ValueError('Expecting a closing )')\n                    pos = close + 1\n                    continue\n                if 'aiLmsux'.indexOf(extension) is not -1:\n                    flag_map = {'a':ASCII, 'i':IGNORECASE, 'L':LOCALE, 'm':MULTILINE, 's':DOTALL, 'u':UNICODE, 'x':VERBOSE}\n                    close = source.indexOf(')', pos + 1)\n                    if close is -1:\n                        raise SyntaxError('Expecting a closing )')\n                    flgs = source[pos+1:close]\n                    for v'var i = 0; i < flgs.length; i++':\n                        q = flgs[i]  # noqa:undef\n                        if not flag_map.hasOwnProperty(q):\n                            raise SyntaxError('Invalid flag: ' + q)\n                        flags |= flag_map[q]\n                    pos = close + 1\n                    continue\n                if extension is '<':\n                    raise SyntaxError('Look behind assertions are not supported in JavaScript')\n                if extension is '(':\n                    raise SyntaxError('Group existence assertions are not supported in JavaScript')\n                if extension is 'P':\n                    pos += 2\n                    q = source[pos]\n                    if q is '<':\n                        close = source.indexOf('>', pos)\n                        if close is -1:\n                            raise SyntaxError('Named group not closed, expecting >')\n                        name = source[pos+1:close]\n                        if not Object.prototype.hasOwnProperty.call(group_map, name):\n                            group_map[name] = v'[]'\n                        group_map[name].push(v'++group_count')\n                        pos = close + 1\n                    elif q is '=':\n                        close = source.indexOf(')', pos)\n                        if close is -1:\n                            raise SyntaxError('Named group back-reference not closed, expecting a )')\n                        name = source[pos+1:close]\n                        if not isNaN(parseInt(name, 10)):\n                            ans += '\\\\' + name\n                        else:\n                            if not Object.prototype.hasOwnProperty.call(group_map, name):\n                                raise SyntaxError('Invalid back-reference. The named group: ' + name + ' has not yet been defined.')\n                            ans += '\\\\' + group_map[name][-1]\n                        pos = close + 1\n                        continue\n                    else:\n                        raise SyntaxError('Expecting < or = after (?P')\n            else:\n                group_count += 1\n        elif ch is '.' and (flags & DOTALL):\n            ans += r'[\\s\\S]'  # JavaScript has no DOTALL\n            continue\n\n        ans += ch\n\n    return ans, flags, group_map\n\nclass MatchObject:\n\n    def __init__(self, regex, match, pos, endpos):\n        self.re = regex\n        self.string = match.input\n        self._start_pos = match.index\n        self._groups = match\n        self.pos, self.endpos = pos, endpos\n\n    def _compute_extents(self):\n        # compute start/end for each group\n        match = self._groups\n        self._start = v'Array(match.length)'\n        self._end = v'Array(match.length)'\n        self._start[0] = self._start_pos\n        self._end[0] = self._start_pos + match[0].length\n        offset = self._start_pos\n        extent = match[0]\n        loc = 0\n        for v'var i = 1; i < match.length; i++':\n            g = match[i]\n            loc = extent.indexOf(g, loc)\n            if loc is -1:\n                self._start[i] = self._start[i-1]\n                self._end[i] = self._end[i-1]\n            else:\n                self._start[i] = offset + loc\n                loc += g.length\n                self._end[i] = offset + loc # noqa:undef\n\n    def groups(self, defval=None):\n        ans = v'[]'\n        for v'var i = 1; i < self._groups.length; i++':\n            val = self._groups[i]  # noqa:undef\n            if val is undefined:\n                val = defval\n            ans.push(val)\n        return ans\n\n    def _group_number(self, g):\n        if type(g) is 'number':\n            return g\n        if Object.prototype.hasOwnProperty.call(self.re.group_name_map, g):\n            return self.re.group_name_map[g][-1]\n        return g\n\n    def _group_val(self, q, defval):\n        val = undefined\n        if type(q) is 'number' and -1 < q < self._groups.length:\n            val = self._groups[q]\n        else:\n            if Object.prototype.hasOwnProperty.call(self.re.group_name_map, q):\n                val = self._groups[self.re.group_name_map[q][-1]]\n        if val is undefined:\n            val = defval\n        return val\n\n    def group(self):\n        if arguments.length is 0:\n            return self._groups[0]\n        ans = v'[]'\n        for v'var i = 0; i < arguments.length; i++':\n            q = arguments[i]  # noqa:undef\n            ans.push(self._group_val(q, None))\n        return ans[0] if ans.length is 1 else ans\n\n    def start(self, g):\n        if self._start is undefined:\n            self._compute_extents()\n        val = self._start[self._group_number(g or 0)]\n        if val is undefined:\n            val = -1\n        return val\n\n    def end(self, g):\n        if self._end is undefined:\n            self._compute_extents()\n        val = self._end[self._group_number(g or 0)]\n        if val is undefined:\n            val = -1\n        return val\n\n    def span(self, g):\n        return [self.start(g), self.end(g)]\n\n    def expand(self, repl):\n        return _expand(repl, this._groups, this.re.group_name_map)\n\n    def groupdict(self, defval=None):\n        gnm = self.re.group_name_map\n        names = Object.keys(gnm)\n        ans = {}\n        for v\"var i = 0; i < names.length; i++\":\n            name = names[i]  # noqa:undef\n            if Object.prototype.hasOwnProperty.call(gnm, name):\n                val = self._groups[gnm[name][-1]]\n                if val is undefined:\n                    val = defval\n                ans[name] = val\n        return ans\n\n    def captures(self, group_name):\n        ans = []\n        if not Object.prototype.hasOwnProperty.call(self.re.group_name_map, group_name):\n            return ans\n        groups = self.re.group_name_map[group_name]\n        for v'var i = 0; i < groups.length; i++':\n            val = self._groups[groups[i]]  # noqa:undef\n            if val is not undefined:\n                ans.push(val)\n        return ans\n\n    def capturesdict(self):\n        gnm = self.re.group_name_map\n        names = Object.keys(gnm)\n        ans = {}\n        for v'var i = 0; i < names.length; i++':\n            name = names[i]  # noqa:undef\n            ans[name] = self.captures(name)\n        return ans\n\nclass RegexObject:\n\n    def __init__(self, pattern, flags):\n        self.pattern = pattern.source if isinstance(pattern, RegExp) else pattern\n        self.js_pattern, self.flags, self.group_name_map = transform_regex(self.pattern, flags)\n\n        modifiers = ''\n        if self.flags & IGNORECASE: modifiers += 'i'\n        if self.flags & MULTILINE: modifiers += 'm'\n        if not (self.flags & ASCII) and supports_unicode:\n            modifiers += 'u'\n        self._modifiers = modifiers + 'g'\n        self._pattern = RegExp(self.js_pattern, self._modifiers)\n\n    def _do_search(self, pat, string, pos, endpos):\n        pat.lastIndex = 0\n        if endpos is not None:\n            string = string[:endpos]\n        while True:\n            n = pat.exec(string)\n            if n is None:\n                return None\n            if n.index >= pos:\n                return MatchObject(self, n, pos, endpos)\n\n    def search(self, string, pos=0, endpos=None):\n        return self._do_search(self._pattern, string, pos, endpos)\n\n    def match(self, string, pos=0, endpos=None):\n        return self._do_search(RegExp('^' + self.js_pattern, self._modifiers), string, pos, endpos)\n\n    def split(self, string, maxsplit=0):\n        self._pattern.lastIndex = 0\n        return string.split(self._pattern, maxsplit or undefined)\n\n    def findall(self, string):\n        self._pattern.lastIndex = 0\n        return _$rapyd$_list_decorate(string.match(self._pattern) or v'[]')\n\n    def finditer(self, string):\n        pat = RegExp(this._pattern.source, this._modifiers)  # We have to do this since lastIndex is mutable\n        return {\n            '_string':string,\n            '_r': pat,\n            '_self': self,\n            _$rapyd$_iterator_symbol: def (): return this;,\n            'next': def ():\n                m = this._r.exec(this._string)\n                if m is None:\n                    return {'done':True}\n                return {'done':False, 'value':MatchObject(this._self, m, 0, None)}\n        }\n\n    def subn(self, repl, string, count=0):\n        expand = _expand\n        if type(repl) is 'function':\n            expand = def(m, repl, gnm): return '' + repl(MatchObject(self, m, 0, None))\n        this._pattern.lastIndex = 0\n        num = 0\n        matches = v'[]'\n\n        while count < 1 or num < count:\n            m = this._pattern.exec(string)\n            if m is None:\n                break\n            matches.push(m)\n            num += 1\n\n        for v'var i = matches.length - 1; i > -1; i--':\n            m = matches[i]  # noqa:undef\n            start = m.index\n            end = start + m[0].length\n            string = string[:start] + expand(m, repl, self.group_name_map) + string[end:]\n        return string, matches.length\n\n    def sub(self, repl, string, count=0):\n        return self.subn(repl, string, count)[0]\n\ndef _get_from_cache(pattern, flags):\n    if isinstance(pattern, RegExp):\n        pattern = pattern.source\n    key = JSON.stringify(v'[pattern, flags]')\n    if Object.prototype.hasOwnProperty.call(_re_cache_map, key):\n        return _re_cache_map[key]\n    if _re_cache_items.length >= 100:\n        v'delete _re_cache_map[_re_cache_items.shift()]'\n    ans = RegexObject(pattern, flags)\n    _re_cache_map[key] = ans\n    _re_cache_items.push(key)\n    return ans\n\ndef compile(pattern, flags=0):\n    return _get_from_cache(pattern, flags)\n\ndef search(pattern, string, flags=0):\n    return _get_from_cache(pattern, flags).search(string)\n\ndef match(pattern, string, flags=0):\n    return _get_from_cache(pattern, flags).match(string)\n\ndef split(pattern, string, maxsplit=0, flags=0):\n    return _get_from_cache(pattern, flags).split(string)\n\ndef findall(pattern, string, flags=0):\n    return _get_from_cache(pattern, flags).findall(string)\n\ndef finditer(pattern, string, flags=0):\n    return _get_from_cache(pattern, flags).finditer(string)\n\ndef sub(pattern, repl, string, count=0, flags=0):\n    return _get_from_cache(pattern, flags).sub(repl, string, count)\n\ndef subn(pattern, repl, string, count=0, flags=0):\n    return _get_from_cache(pattern, flags).subn(repl, string, count)\n\ndef escape(string):\n    return string.replace(_RE_ESCAPE, '\\\\$&')\n\ndef purge():\n    nonlocal _re_cache_map, _re_cache_items\n    _re_cache_map = {}\n    _re_cache_items = v'[]'\n"};

// End embedded modules }}}

/* vim:fileencoding=utf-8
 * 
 * Copyright (C) 2016 Kovid Goyal <kovid at kovidgoyal.net>
 *
 * Distributed under terms of the BSD license
 */

var namespace = {}, jsSHA = {};

var write_cache = {};

var builtin_modules = {
    'crypto' : {
        'createHash': function create_hash() {
            var ans = new jsSHA.jsSHA('SHA-1', 'TEXT');
            ans.digest = function hex_digest() { return ans.getHash('HEX'); };
            return ans;
        },
    },

    'vm': {
        'createContext': function create_context(ctx) {
            var iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            document.body.appendChild(iframe);
            var win = iframe.contentWindow;
            if(!ctx) ctx = {};
            if (!ctx.sha1sum) ctx.sha1sum = sha1sum;
            if (!ctx.require) ctx.require = require;
            Object.keys(ctx).forEach(function(k) { win[k] = ctx[k]; });
            return win;
        },

        'runInContext': function run_in_context(code, ctx) {
            return ctx.eval(code);
        },

        'runInThisContext': eval,
    },
    'path': {
        'join': function path_join() { return Array.prototype.slice.call(arguments).join('/'); },
        'dirname': function path_dirname(path) {
            return path.split('/').slice(0, -1).join('/');
        },
    },
    'inspect': function inspect(x) { return x.toString(); },

    'fs': {
        'readFileSync': function readfile(name) {
            var data = namespace.file_data[name];
            if (data) return data;
            data = write_cache[name];
            if (data) return data;
            var err = Error();
            err.code = 'ENOENT';
            throw err;
        },

        'writeFileSync': function writefile(name, data) {
            write_cache[name] = data;
        },

    },
};

function require(name) {
    return builtin_modules[name] || {};
}

// Embedded sha1 implementation {{{
(function() {
/*
 A JavaScript implementation of the SHA family of hashes, as
 defined in FIPS PUB 180-2 as well as the corresponding HMAC implementation
 as defined in FIPS PUB 198a

 Copyright Brian Turek 2008-2015
 Distributed under the BSD License
 See http://caligatio.github.com/jsSHA/ for more information

 Several functions taken from Paul Johnston
*/
'use strict';(function(E){function t(e,a,c){var g=0,b=[],d=0,f,k,l,h,m,w,n,q=!1,r=!1,p=[],t=[],v,u=!1;c=c||{};f=c.encoding||"UTF8";v=c.numRounds||1;l=y(a,f);if(v!==parseInt(v,10)||1>v)throw Error("numRounds must a integer >= 1");if("SHA-1"===e)m=512,w=z,n=F,h=160;else throw Error("Chosen SHA variant is not supported");k=x(e);this.setHMACKey=function(a,b,d){var c;if(!0===r)throw Error("HMAC key already set");if(!0===q)throw Error("Cannot set HMAC key after finalizing hash");if(!0===u)throw Error("Cannot set HMAC key after calling update");
f=(d||{}).encoding||"UTF8";b=y(b,f)(a);a=b.binLen;b=b.value;c=m>>>3;d=c/4-1;if(c<a/8){for(b=n(b,a,0,x(e));b.length<=d;)b.push(0);b[d]&=4294967040}else if(c>a/8){for(;b.length<=d;)b.push(0);b[d]&=4294967040}for(a=0;a<=d;a+=1)p[a]=b[a]^909522486,t[a]=b[a]^1549556828;k=w(p,k);g=m;r=!0};this.update=function(a){var e,c,f,h=0,n=m>>>5;e=l(a,b,d);a=e.binLen;c=e.value;e=a>>>5;for(f=0;f<e;f+=n)h+m<=a&&(k=w(c.slice(f,f+n),k),h+=m);g+=h;b=c.slice(h>>>5);d=a%m;u=!0};this.getHash=function(a,c){var f,l,m;if(!0===
r)throw Error("Cannot call getHash after setting HMAC key");m=A(c);switch(a){case "HEX":f=function(a){return B(a,m)};break;case "B64":f=function(a){return C(a,m)};break;case "BYTES":f=D;break;default:throw Error("format must be HEX, B64, or BYTES");}if(!1===q)for(k=n(b,d,g,k),l=1;l<v;l+=1)k=n(k,h,0,x(e));q=!0;return f(k)};this.getHMAC=function(a,c){var f,l,p;if(!1===r)throw Error("Cannot call getHMAC without first setting HMAC key");p=A(c);switch(a){case "HEX":f=function(a){return B(a,p)};break;case "B64":f=
function(a){return C(a,p)};break;case "BYTES":f=D;break;default:throw Error("outputFormat must be HEX, B64, or BYTES");}!1===q&&(l=n(b,d,g,k),k=w(t,x(e)),k=n(l,h,m,k));q=!0;return f(k)}}function G(e,a,c){var g=e.length,b,d,f,k,l;a=a||[0];c=c||0;l=c>>>3;if(0!==g%2)throw Error("String of HEX type must be in byte increments");for(b=0;b<g;b+=2){d=parseInt(e.substr(b,2),16);if(isNaN(d))throw Error("String of HEX type contains invalid characters");k=(b>>>1)+l;for(f=k>>>2;a.length<=f;)a.push(0);a[f]|=d<<
8*(3-k%4)}return{value:a,binLen:4*g+c}}function H(e,a,c){var g=[],b,d,f,k,g=a||[0];c=c||0;d=c>>>3;for(b=0;b<e.length;b+=1)a=e.charCodeAt(b),k=b+d,f=k>>>2,g.length<=f&&g.push(0),g[f]|=a<<8*(3-k%4);return{value:g,binLen:8*e.length+c}}function I(e,a,c){var g=[],b=0,d,f,k,l,h,m,g=a||[0];c=c||0;a=c>>>3;if(-1===e.search(/^[a-zA-Z0-9=+\/]+$/))throw Error("Invalid character in base-64 string");f=e.indexOf("=");e=e.replace(/\=/g,"");if(-1!==f&&f<e.length)throw Error("Invalid '=' found in base-64 string");
for(f=0;f<e.length;f+=4){h=e.substr(f,4);for(k=l=0;k<h.length;k+=1)d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(h[k]),l|=d<<18-6*k;for(k=0;k<h.length-1;k+=1){m=b+a;for(d=m>>>2;g.length<=d;)g.push(0);g[d]|=(l>>>16-8*k&255)<<8*(3-m%4);b+=1}}return{value:g,binLen:8*b+c}}function B(e,a){var c="",g=4*e.length,b,d;for(b=0;b<g;b+=1)d=e[b>>>2]>>>8*(3-b%4),c+="0123456789abcdef".charAt(d>>>4&15)+"0123456789abcdef".charAt(d&15);return a.outputUpper?c.toUpperCase():c}function C(e,
a){var c="",g=4*e.length,b,d,f;for(b=0;b<g;b+=3)for(f=b+1>>>2,d=e.length<=f?0:e[f],f=b+2>>>2,f=e.length<=f?0:e[f],f=(e[b>>>2]>>>8*(3-b%4)&255)<<16|(d>>>8*(3-(b+1)%4)&255)<<8|f>>>8*(3-(b+2)%4)&255,d=0;4>d;d+=1)8*b+6*d<=32*e.length?c+="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(f>>>6*(3-d)&63):c+=a.b64Pad;return c}function D(e){var a="",c=4*e.length,g,b;for(g=0;g<c;g+=1)b=e[g>>>2]>>>8*(3-g%4)&255,a+=String.fromCharCode(b);return a}function A(e){var a={outputUpper:!1,b64Pad:"="};
e=e||{};a.outputUpper=e.outputUpper||!1;!0===e.hasOwnProperty("b64Pad")&&(a.b64Pad=e.b64Pad);if("boolean"!==typeof a.outputUpper)throw Error("Invalid outputUpper formatting option");if("string"!==typeof a.b64Pad)throw Error("Invalid b64Pad formatting option");return a}function y(e,a){var c;switch(a){case "UTF8":case "UTF16BE":case "UTF16LE":break;default:throw Error("encoding must be UTF8, UTF16BE, or UTF16LE");}switch(e){case "HEX":c=G;break;case "TEXT":c=function(e,b,d){var f=[],c=[],l=0,h,m,p,
n,q,f=b||[0];b=d||0;p=b>>>3;if("UTF8"===a)for(h=0;h<e.length;h+=1)for(d=e.charCodeAt(h),c=[],128>d?c.push(d):2048>d?(c.push(192|d>>>6),c.push(128|d&63)):55296>d||57344<=d?c.push(224|d>>>12,128|d>>>6&63,128|d&63):(h+=1,d=65536+((d&1023)<<10|e.charCodeAt(h)&1023),c.push(240|d>>>18,128|d>>>12&63,128|d>>>6&63,128|d&63)),m=0;m<c.length;m+=1){q=l+p;for(n=q>>>2;f.length<=n;)f.push(0);f[n]|=c[m]<<8*(3-q%4);l+=1}else if("UTF16BE"===a||"UTF16LE"===a)for(h=0;h<e.length;h+=1){d=e.charCodeAt(h);"UTF16LE"===a&&
(m=d&255,d=m<<8|d>>>8);q=l+p;for(n=q>>>2;f.length<=n;)f.push(0);f[n]|=d<<8*(2-q%4);l+=2}return{value:f,binLen:8*l+b}};break;case "B64":c=I;break;case "BYTES":c=H;break;default:throw Error("format must be HEX, TEXT, B64, or BYTES");}return c}function r(e,a){return e<<a|e>>>32-a}function p(e,a){var c=(e&65535)+(a&65535);return((e>>>16)+(a>>>16)+(c>>>16)&65535)<<16|c&65535}function u(e,a,c,g,b){var d=(e&65535)+(a&65535)+(c&65535)+(g&65535)+(b&65535);return((e>>>16)+(a>>>16)+(c>>>16)+(g>>>16)+(b>>>16)+
(d>>>16)&65535)<<16|d&65535}function x(e){if("SHA-1"===e)e=[1732584193,4023233417,2562383102,271733878,3285377520];else throw Error("No SHA variants supported");return e}function z(e,a){var c=[],g,b,d,f,k,l,h;g=a[0];b=a[1];d=a[2];f=a[3];k=a[4];for(h=0;80>h;h+=1)c[h]=16>h?e[h]:r(c[h-3]^c[h-8]^c[h-14]^c[h-16],1),l=20>h?u(r(g,5),b&d^~b&f,k,1518500249,c[h]):40>h?u(r(g,5),b^d^f,k,1859775393,c[h]):60>h?u(r(g,5),b&d^b&f^d&f,k,2400959708,c[h]):u(r(g,5),b^d^f,k,3395469782,c[h]),k=f,f=d,d=r(b,30),b=g,g=l;a[0]=
p(g,a[0]);a[1]=p(b,a[1]);a[2]=p(d,a[2]);a[3]=p(f,a[3]);a[4]=p(k,a[4]);return a}function F(e,a,c,g){var b;for(b=(a+65>>>9<<4)+15;e.length<=b;)e.push(0);e[a>>>5]|=128<<24-a%32;e[b]=a+c;c=e.length;for(a=0;a<c;a+=16)g=z(e.slice(a,a+16),g);return g}"function"===typeof define&&define.amd?define(function(){return t}):"undefined"!==typeof exports?"undefined"!==typeof module&&module.exports?module.exports=exports=t:exports=t:E.jsSHA=t})(this);
}).call(jsSHA);
// End embedded sha1 implementation }}}

var exports = namespace;
/* 
 * Copyright (C) 2015 Kovid Goyal <kovid at kovidgoyal.net>
 *
 * Distributed under terms of the BSD license
 */

var vm = require('vm');
var native_require = require;

function normalize_array(parts, allowAboveRoot) {
  var res = [];
  for (var i = 0; i < parts.length; i++) {
    var p = parts[i];

    // ignore empty parts
    if (!p || p === '.')
      continue;

    if (p === '..') {
      if (res.length && res[res.length - 1] !== '..') {
        res.pop();
      } else if (allowAboveRoot) {
        res.push('..');
      }
    } else {
      res.push(p);
    }
  }

  return res;
}

function normalize(path) {
    var is_abs = path && path[0] === '/';
    var trailing_slash = path && path[path.length - 1] === '/';
    path = normalize_array(path.split('/'), !is_abs).join('/');

    if (!path && !is_abs) {
        path = '.';
    }
    if (path && trailing_slash) {
        path += '/';
    }

    return (is_abs ? '/' : '') + path;
}

function dirname(path) {
    var idx = path.lastIndexOf('/');
    if (idx != -1) path = path.slice(0, idx);
    else path = '';
    return path;
}

function basename(path) {
    var idx = path.lastIndexOf('/');
    if (idx != -1) path = path.slice(idx + 1);
    return path;
}

var cache = {};

function load(filepath) {
    var cached = cache[filepath];
    if (cached) return cached.exports;
    var module = {'id':filepath, 'exports':{}};
    cache[filepath] = module;

    var content = data[filepath];
    if (Array.isArray(content)) content = data[content[0]];
    if (!content) throw 'Failed to load: ' + JSON.stringify(filepath);

    if (filepath.slice(-5) == '.json') { module.exports = JSON.parse(content); return module.exports; }

    var base = dirname(filepath);
    function mrequire(x) {
        return vrequire(x, base);
    }
    content = content.replace(/^\#\!.*/, '');
    var wrapped = '(function(exports, require, module, __filename, __dirname, create_rapydscript_compiler) { ';
    wrapped += content + '\n;})';
    try {
        vm.runInThisContext(wrapped, {'filename': filepath})(module.exports, mrequire, module, filepath, dirname(filepath), create_compiler);
    } catch (e) {
        console.error(e);
        delete cache[filepath];
        throw e;
    }
    return module.exports;
}

function has(x, y) { return Object.prototype.hasOwnProperty.call(x, y); }

function try_files(candidate) {
    if (has(data, candidate)) return candidate;
    if (has(data, candidate + '.js')) return candidate + '.js';
    if (has(data, candidate + '.json')) return candidate + '.json';
    return null;
}

function find_in_modules_dir(name, base) {
    var candidate = normalize(base + (base ? '/':'') + 'node_modules/' + name);
    var q = try_files(candidate);
    if (q) return q;

    var pj = candidate + '/package.json';
    if (has(data, pj)) {
        var ans = normalize(candidate + '/' + JSON.parse(data[pj]).main);
        if (has(data, ans)) return ans;
    }
    var index = candidate + '/index.js';
    if (has(data, index)) return index;

    var p = dirname(base);
    if (p) return find_in_modules_dir(name, p);
    return null;
}

function find_module(name, base) {
    if (name[0] == '/') throw 'Cannot find absolute module: ' + name;
    if (name.slice(0, 2) == './' || name.slice(0, 3) == '../') {
        var candidate = normalize((base ? base + '/' : base) + name);
        return try_files(candidate);
    }
    var q = try_files(name);
    if (q) return q;
    return find_in_modules_dir(name, base);
}

function vrequire(name, base) {
    var exports = {};
    var modpath = '';
    base = base || '';
    // console.log('vrequire', name, base);
    if (!name) throw new Error('Cannot load a module from an empty name');

    modpath = find_module(name, base);
    if (!modpath && name && './'.indexOf(name[0]) === -1) {
            try {
                return native_require(name);
            } catch (e) {}
        }

    if (!modpath) throw new Error("Failed to find module: " + JSON.stringify(name) + " with base: " + JSON.stringify(base));
    return load(modpath);
}

var UglifyJS = null, regenerator = null;
var crypto = null, fs = require('fs');

function uglify(x) {
    if (!UglifyJS) UglifyJS = vrequire("uglify-js");
    return UglifyJS.minify(ans, {fromString:true}).code;
}

function regenerate(code, beautify) {
    var orig = fs.readFileSync;
    fs.readFileSync = function(name) { 
        if (!has(data, name)) {
            throw {message: "Failed to readfile from data: " + name};
        }
        return data[name]; 
    };
    if (!regenerator) regenerator = vrequire('regenerator');
    var ans;
    if (code) {
        try {
            ans = regenerator.compile(code).code;
        } catch (e) {
            console.error('regenerator failed for code: ' + code + 'with error stack:\n' + e.stack);
            throw e;
        }
        if (!beautify) ans = uglify(ans);
    } else {
        // Return the runtime
        ans = regenerator.compile('', {includeRuntime:true}).code;
        ans = ans.slice(ans.indexOf('!'), ans.lastIndexOf(')(')) + ')';
        if (!beautify) ans = uglify(ans+'();').slice(0, -3);
    }
    fs.readFileSync = orig;
    return ans;
}

if (typeof this != 'object' || typeof this.sha1sum !== 'function') {
    var sha1sum = function (data) { 
        if (!crypto) crypto = require('crypto');
        var h = crypto.createHash('sha1');
        h.update(data);
        return h.digest('hex');
    };
} else var sha1sum = this.sha1sum;

function create_compiler() {
    var compilerjs = data['compiler.js'];
    var module = {'id':'compiler', 'exports':{}};
    var wrapped = '(function(module, exports, readfile, writefile, sha1sum, regenerate) {' + data['compiler.js'] + ';\n})';
    vm.runInThisContext(wrapped, {'filename': 'compiler.js'})(module, module.exports, fs.readFileSync, fs.writeFileSync, sha1sum, regenerate);
    return module.exports;
}

var RapydScript = null;

function compile(code, filename, options) {
    if (!RapydScript) RapydScript = create_compiler();
    options = options || {};
    var ast = RapydScript.parse(code, {
        filename: filename || '<eval>',
        auto_bind: !!options.auto_bind,
        basedir: options.basedir || dirname(filename || ''),
        libdir: options.libdir,
    });
    var out_ops = {
        beautify: (options.beautify === undefined ? true : options.beautify),
        private_scope: !options.bare,
        auto_bind: !!options.auto_bind,
        omit_baselib: !!options.omit_baselib,
        js_version: options.js_version || 5,
    };
    if (!out_ops.omit_baselib) out_ops.baselib = data['baselib-' + (out_ops.beautify ? 'pretty' : 'ugly') + '.js'];
    var out = new RapydScript.OutputStream(out_ops);
    ast.print(out);
    return out.get();
}

function create_embedded_compiler(runjs) {
    var c = vrequire('tools/embedded_compiler.js');
    return c(create_compiler(), data['baselib-plain-pretty.js'], runjs);
}

function web_repl() {
    var repl = vrequire('tools/web_repl.js');
    return repl(create_compiler(), data['baselib-plain-pretty.js']);
}

function init_repl(options) {
    var repl = vrequire('tools/repl.js');
    options.baselib = data['baselib-plain-pretty.js'];
    return repl(options);
}

function gettext_parse(catalog, code, filename) {
    g = vrequire('tools/gettext.js');
    g.gettext(catalog, code, filename);
}

function gettext_output(catalog, options, write) {
    g = vrequire('tools/gettext.js');
    g.write_output(catalog, options, write);
}

function msgfmt(data, options) {
    m = vrequire('tools/msgfmt.js');
    return m.build(data, options);
}

function completer(compiler, options) {
    m = vrequire('tools/completer.js');
    return m(compiler, options);
}

if (typeof exports === 'object') {
    exports.compile = compile;
    exports.create_embedded_compiler = create_embedded_compiler;
    exports.web_repl = web_repl;
    exports.init_repl = init_repl;
    exports.gettext_parse = gettext_parse;
    exports.gettext_output = gettext_output;
    exports.msgfmt = msgfmt;
    exports.rs_version = rs_version;
    exports.file_data = data;
    exports.completer = completer;
    if (typeof rs_commit_sha === 'string') exports.rs_commit_sha = rs_commit_sha;
}
external_namespace.RapydScript = namespace;
})(this)